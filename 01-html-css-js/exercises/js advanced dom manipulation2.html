<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DOM Mastery Bootcamp | Advanced JavaScript</title>
    <style>
        :root {
            --bg-dark: #0d1117;
            --bg-card: #161b22;
            --border: #30363d;
            --text-main: #c9d1d9;
            --text-muted: #8b949e;
            --accent-blue: #58a6ff;
            --accent-green: #238636;
            --accent-orange: #f85149;
            --accent-purple: #a371f7;
            --accent-yellow: #d29922;
            --font-mono: 'Consolas', 'Monaco', 'Courier New', monospace;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
            background: var(--bg-dark);
            color: var(--text-main);
            line-height: 1.6;
            overflow-x: hidden;
        }

        /* Navigation */
        .nav {
            background: var(--bg-card);
            border-bottom: 1px solid var(--border);
            padding: 1rem 2rem;
            position: sticky;
            top: 0;
            z-index: 100;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: bold;
            background: linear-gradient(45deg, var(--accent-blue), var(--accent-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .progress-bar {
            width: 300px;
            height: 8px;
            background: var(--border);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: var(--accent-green);
            width: 0%;
            transition: width 0.3s ease;
        }

        .nav-links {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .nav-btn {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-muted);
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.9rem;
        }

        .nav-btn:hover, .nav-btn.active {
            background: var(--accent-blue);
            color: white;
            border-color: var(--accent-blue);
        }

        /* Main Layout */
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
        }

        @media (max-width: 968px) {
            .container {
                grid-template-columns: 1fr;
            }
        }

        .panel {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 2rem;
            position: relative;
            overflow: hidden;
        }

        .panel h2 {
            color: var(--accent-blue);
            margin-bottom: 1rem;
            font-size: 1.8rem;
        }

        .panel h3 {
            color: var(--accent-purple);
            margin: 1.5rem 0 0.5rem;
        }

        .tag {
            display: inline-block;
            background: var(--accent-blue);
            color: white;
            padding: 0.2rem 0.6rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: bold;
            margin-bottom: 1rem;
            text-transform: uppercase;
        }

        .tag.warning {
            background: var(--accent-orange);
        }

        .tag.success {
            background: var(--accent-green);
        }

        /* Code Blocks */
        pre {
            background: #0d1117;
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 1rem;
            overflow-x: auto;
            font-family: var(--font-mono);
            font-size: 0.9rem;
            margin: 1rem 0;
            position: relative;
        }

        code {
            font-family: var(--font-mono);
            color: var(--text-main);
        }

        .keyword { color: #ff7b72; }
        .function { color: #d2a8ff; }
        .string { color: #a5d6ff; }
        .comment { color: #8b949e; font-style: italic; }
        .number { color: #79c0ff; }

        /* Interactive Playground */
        .playground {
            background: #010409;
            border: 2px solid var(--border);
            border-radius: 8px;
            min-height: 300px;
            position: relative;
        }

        .playground-header {
            background: var(--bg-card);
            padding: 0.5rem 1rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
            color: var(--text-muted);
        }

        .playground-content {
            padding: 1rem;
            min-height: 250px;
            position: relative;
        }

        .controls {
            display: flex;
            gap: 0.5rem;
            margin: 1rem 0;
            flex-wrap: wrap;
        }

        button {
            background: var(--accent-blue);
            color: white;
            border: none;
            padding: 0.6rem 1.2rem;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: transform 0.1s, opacity 0.2s;
        }

        button:hover {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        button.danger {
            background: var(--accent-orange);
        }

        button.success {
            background: var(--accent-green);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Visual Elements */
        .dom-tree {
            font-family: var(--font-mono);
            font-size: 0.85rem;
            line-height: 1.8;
        }

        .node {
            padding-left: 20px;
            border-left: 2px solid var(--border);
            margin-left: 10px;
            position: relative;
        }

        .node::before {
            content: '';
            position: absolute;
            left: -2px;
            top: 12px;
            width: 10px;
            height: 2px;
            background: var(--border);
        }

        .node-tag {
            color: var(--accent-blue);
        }

        .node-content {
            color: var(--accent-green);
        }

        .highlight-pulse {
            animation: pulse 2s infinite;
            background: rgba(88, 166, 255, 0.1);
            border-radius: 4px;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .metric {
            display: inline-block;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            padding: 0.5rem 1rem;
            border-radius: 6px;
            margin: 0.5rem 0.5rem 0 0;
            font-family: var(--font-mono);
            font-size: 0.9rem;
        }

        .metric-value {
            color: var(--accent-green);
            font-weight: bold;
        }

        .metric-value.bad {
            color: var(--accent-orange);
        }

        /* Quiz Styles */
        .quiz-option {
            background: var(--bg-dark);
            border: 1px solid var(--border);
            padding: 1rem;
            margin: 0.5rem 0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .quiz-option:hover {
            border-color: var(--accent-blue);
            transform: translateX(5px);
        }

        .quiz-option.correct {
            border-color: var(--accent-green);
            background: rgba(35, 134, 54, 0.1);
        }

        .quiz-option.wrong {
            border-color: var(--accent-orange);
            background: rgba(248, 81, 73, 0.1);
        }

        .explanation {
            background: rgba(88, 166, 255, 0.1);
            border-left: 4px solid var(--accent-blue);
            padding: 1rem;
            margin-top: 1rem;
            border-radius: 0 8px 8px 0;
            display: none;
        }

        .pitfall {
            background: rgba(248, 81, 73, 0.1);
            border: 1px solid var(--accent-orange);
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
        }

        .pitfall-title {
            color: var(--accent-orange);
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-dark);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }

        /* Animations for demos */
        .scroll-container {
            height: 300px;
            overflow-y: auto;
            border: 1px solid var(--border);
            padding: 1rem;
            background: var(--bg-dark);
        }

        .lazy-item {
            height: 100px;
            margin: 1rem 0;
            background: linear-gradient(90deg, var(--bg-card), var(--border));
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
            transition: all 0.3s;
            opacity: 0.3;
        }

        .lazy-item.visible {
            opacity: 1;
            background: linear-gradient(90deg, var(--accent-blue), var(--accent-purple));
            color: white;
        }

        .mutation-log {
            height: 200px;
            overflow-y: auto;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            padding: 0.5rem;
            font-family: var(--font-mono);
            font-size: 0.85rem;
            margin-top: 1rem;
        }

        .log-entry {
            padding: 0.25rem 0;
            border-bottom: 1px solid var(--border);
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-10px); }
            to { opacity: 1; transform: translateX(0); }
        }

        .custom-element-demo {
            padding: 2rem;
            background: var(--bg-dark);
            border-radius: 8px;
            text-align: center;
        }

        star-rating {
            display: inline-block;
            font-size: 2rem;
            cursor: pointer;
        }

        .hidden { display: none; }
        
        .badge {
            position: fixed;
            bottom: 2rem;
            right: 2rem;
            background: var(--accent-green);
            color: white;
            padding: 1rem 2rem;
            border-radius: 50px;
            font-weight: bold;
            box-shadow: 0 4px 12px rgba(35, 134, 54, 0.4);
            display: none;
            animation: slideUp 0.5s ease;
        }

        @keyframes slideUp {
            from { transform: translateY(100px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
    </style>
</head>
<body>

<nav class="nav">
    <div class="logo">‚ö° DOM Mastery Bootcamp</div>
    <div class="progress-bar">
        <div class="progress-fill" id="progressFill"></div>
    </div>
    <div class="nav-links">
        <button class="nav-btn active" onclick="showModule('fragments')">Fragments</button>
        <button class="nav-btn" onclick="showModule('vdom')">Virtual DOM</button>
        <button class="nav-btn" onclick="showModule('intersection')">Intersection</button>
        <button class="nav-btn" onclick="showModule('mutation')">Mutation</button>
        <button class="nav-btn" onclick="showModule('custom')">Custom Elements</button>
        <button class="nav-btn" onclick="showModule('final')">Final Boss</button>
    </div>
</nav>

<div id="fragments" class="module container">
    <div class="panel">
        <span class="tag">Module 1</span>
        <h2>DocumentFragment & Performance</h2>
        
        <p>The DOM is slow. Every time you touch it, the browser recalculates layout (reflow). Batch your operations!</p>
        
        <h3>üî• The Problem</h3>
        <pre><code><span class="comment">// ‚ùå NAIVE: 1000 reflows!</span>
<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i < <span class="number">1000</span>; i++) {
    <span class="keyword">const</span> li = document.<span class="function">createElement</span>(<span class="string">'li'</span>);
    li.textContent = <span class="string">`Item ${i}`</span>;
    list.<span class="function">appendChild</span>(li); <span class="comment">// Reflow happens here!</span>
}</code></pre>

        <h3>‚ú® The Solution: DocumentFragment</h3>
        <p>A <code>DocumentFragment</code> is a minimal document object that has no parent. It's a staging area.</p>
        
        <pre><code><span class="comment">// ‚úÖ OPTIMIZED: 1 reflow</span>
<span class="keyword">const</span> fragment = document.<span class="function">createDocumentFragment</span>();

<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i < <span class="number">1000</span>; i++) {
    <span class="keyword">const</span> li = document.<span class="function">createElement</span>(<span class="string">'li'</span>);
    li.textContent = <span class="string">`Item ${i}`</span>;
    fragment.<span class="function">appendChild</span>(li); <span class="comment">// No reflow!</span>
}

list.<span class="function">appendChild</span>(fragment); <span class="comment">// Single reflow</span></code></pre>

        <div class="pitfall">
            <div class="pitfall-title">‚ö†Ô∏è Pitfall: The Empty Container</div>
            <p>Once you append a fragment to the DOM, the fragment becomes empty! The nodes move, not copy.</p>
            <pre><code>fragment.<span class="function">appendChild</span>(node);
container.<span class="function">appendChild</span>(fragment);
console.<span class="function">log</span>(fragment.children.length); <span class="comment">// 0!</span></code></pre>
        </div>
    </div>

    <div class="panel">
        <h3>üèéÔ∏è Performance Race</h3>
        <p>Click both buttons. Watch the reflow counter.</p>
        
        <div class="controls">
            <button class="danger" onclick="naiveAppend()">Naive Loop (Slow)</button>
            <button class="success" onclick="fragmentAppend()">DocumentFragment (Fast)</button>
            <button onclick="clearList()">Clear</button>
        </div>

        <div class="metrics">
            <div class="metric">Items: <span class="metric-value" id="itemCount">0</span></div>
            <div class="metric">Time: <span class="metric-value" id="timeMetric">0</span>ms</div>
            <div class="metric">Reflows: <span class="metric-value bad" id="reflowMetric">0</span></div>
        </div>

        <div class="playground">
            <div class="playground-header">Live DOM</div>
            <div class="playground-content" id="listContainer" style="max-height: 300px; overflow-y: auto;">
                <ul id="demoList" style="list-style: none; padding: 0;"></ul>
            </div>
        </div>

        <div class="pitfall" style="margin-top: 1rem;">
            <div class="pitfall-title">üíÄ Interview Trap</div>
            <p><strong>Question:</strong> "Is innerHTML faster than DocumentFragment?"</p>
            <p><strong>Answer:</strong> For massive HTML strings, innerHTML can be faster (parser is C++ optimized), but it destroys event listeners and is XSS-prone. Fragments are safer and preserve references.</p>
        </div>
    </div>
</div>

<div id="vdom" class="module container hidden">
    <div class="panel">
        <span class="tag">Module 2</span>
        <h2>Virtual DOM Concepts</h2>
        
        <p>React made this famous, but you can implement the pattern in vanilla JS. The idea: compare new state with current DOM, update only differences.</p>

        <h3>The Algorithm</h3>
        <ol>
            <li>Create lightweight JS representation (Virtual Tree)</li>
            <li>Diff against real DOM</li>
            <li>Apply patches (minimal changes)</li>
        </ol>

        <pre><code><span class="comment">// Simplified VNode structure</span>
<span class="keyword">const</span> vNode = {
  tag: <span class="string">'div'</span>,
  props: { id: <span class="string">'app'</span> },
  children: [
    { tag: <span class="string">'h1'</span>, text: <span class="string">'Hello'</span> }
  ]
};</code></pre>

        <h3>üß† Key Insight</h3>
        <p>Reading from DOM is as expensive as writing to it. The Virtual DOM caches state in JavaScript memory.</p>

        <div class="pitfall">
            <div class="pitfall-title">‚ö†Ô∏è Pitfall: Over-engineering</div>
            <p>Don't build a VDOM for simple static pages. The overhead isn't worth it for < 50 nodes.</p>
        </div>
    </div>

    <div class="panel">
        <h3>üéÆ Diffing Visualizer</h3>
        <p>Edit the text and click "Reconcile". Watch only changed nodes update (green flash).</p>
        
        <div class="controls">
            <input type="text" id="vdomInput" value="Hello World" style="padding: 0.5rem; background: var(--bg-dark); border: 1px solid var(--border); color: white; border-radius: 4px; width: 200px;">
            <button onclick="updateVDOM()">Reconcile</button>
            <button onclick="forceFullRender()">Full Render (Slow)</button>
        </div>

        <div class="playground">
            <div class="playground-header">Virtual DOM Tree Visualization</div>
            <div class="playground-content" id="vdomTree">
                <!-- Dynamic content -->
            </div>
        </div>

        <div class="metrics" style="margin-top: 1rem;">
            <div class="metric">Operations: <span class="metric-value" id="opCount">0</span></div>
            <div class="metric">Nodes Changed: <span class="metric-value" id="changeCount">0</span></div>
        </div>

        <div class="quiz" style="margin-top: 2rem;">
            <h4>üéØ Quick Quiz</h4>
            <p>Why is Virtual DOM faster than direct DOM manipulation in complex apps?</p>
            <div class="quiz-option" onclick="checkAnswer(this, false)">
                A. JavaScript objects are faster than browser APIs
            </div>
            <div class="quiz-option" onclick="checkAnswer(this, true)">
                B. It batches updates and minimizes reflows via diffing
            </div>
            <div class="quiz-option" onclick="checkAnswer(this, false)">
                C. It uses Web Workers
            </div>
            <div class="explanation">
                Correct! The Virtual DOM allows us to compute the minimal set of changes first, then apply them in a single batch, avoiding expensive intermediate reflows.
            </div>
        </div>
    </div>
</div>

<div id="intersection" class="module container hidden">
    <div class="panel">
        <span class="tag">Module 3</span>
        <h2>IntersectionObserver</h2>
        
        <p>The scroll event fires thousands of times per second. <code>IntersectionObserver</code> is async and efficient for detecting when elements enter/leave viewport.</p>

        <pre><code><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="function">IntersectionObserver</span>((entries) => {
  entries.<span class="function">forEach</span>(entry => {
    <span class="keyword">if</span> (entry.isIntersecting) {
      entry.target.classList.<span class="function">add</span>(<span class="string">'visible'</span>);
      observer.<span class="function">unobserve</span>(entry.target); <span class="comment">// Cleanup!</span>
    }
  });
}, {
  threshold: <span class="number">0.5</span>, <span class="comment">// 50% visible</span>
  rootMargin: <span class="string">'0px'</span>
});</code></pre>

        <div class="pitfall">
            <div class="pitfall-title">‚ö†Ô∏è Pitfall: Memory Leaks</div>
            <p>Always <code>unobserve()</code> or <code>disconnect()</code> when components destroy, or observers persist forever.</p>
        </div>

        <div class="pitfall">
            <div class="pitfall-title">‚ö†Ô∏è Pitfall: Root Must Be Ancestor</div>
            <p>The <code>root</code> option must be an ancestor of the target. You can't observe intersections with arbitrary elements.</p>
        </div>
    </div>

    <div class="panel">
        <h3>üëÅÔ∏è Lazy Loader Simulator</h3>
        <p>Scroll down. Items load (turn green) only when 50% visible. Check the console log.</p>
        
        <div class="controls">
            <label style="color: var(--text-muted); font-size: 0.9rem;">
                Threshold: 
                <input type="range" id="thresholdSlider" min="0" max="1" step="0.1" value="0.5" onchange="updateThreshold(this.value)" style="vertical-align: middle;">
                <span id="thresholdValue">0.5</span>
            </label>
            <button onclick="resetObserver()">Reset Demo</button>
        </div>

        <div class="scroll-container" id="scrollContainer">
            <!-- Generated items -->
        </div>

        <div class="metrics">
            <div class="metric">Callbacks Fired: <span class="metric-value" id="callbackCount">0</span></div>
            <div class="metric">Active Observers: <span class="metric-value" id="activeObservers">10</span></div>
        </div>

        <div class="quiz" style="margin-top: 1rem;">
            <h4>üéØ Debugging Challenge</h4>
            <p>This code has a bug. What's wrong?</p>
            <pre style="font-size: 0.8rem;"><code>window.<span class="function">addEventListener</span>(<span class="string">'scroll'</span>, () => {
  document.<span class="function">querySelectorAll</span>(<span class="string">'.item'</span>).<span class="function">forEach</span>(item => {
    <span class="keyword">if</span> (item.<span class="function">getBoundingClientRect</span>().top < window.innerHeight) {
      item.classList.<span class="function">add</span>(<span class="string">'visible'</span>);
    }
  });
});</code></pre>
            <div class="quiz-option" onclick="checkAnswer(this, true)">
                A. Scroll events fire too frequently; causes jank & battery drain
            </div>
            <div class="quiz-option" onclick="checkAnswer(this, false)">
                B. getBoundingClientRect is deprecated
            </div>
            <div class="explanation">
                Correct! Scroll events can fire 60-120 times/second, forcing layout thrashing. IntersectionObserver is the modern, performant solution.
            </div>
        </div>
    </div>
</div>

<div id="mutation" class="module container hidden">
    <div class="panel">
        <span class="tag">Module 4</span>
        <h2>MutationObserver</h2>
        
        <p>Spy on DOM changes. Useful for debugging, reacting to third-party widgets, or implementing undo systems.</p>

        <pre><code><span class="keyword">const</span> observer = <span class="keyword">new</span> <span class="function">MutationObserver</span>((mutations) => {
  mutations.<span class="function">forEach</span>(mutation => {
    console.<span class="function">log</span>(<span class="string">'Type:'</span>, mutation.type); <span class="comment">// childList, attributes, characterData</span>
    console.<span class="function">log</span>(<span class="string">'Added:'</span>, mutation.addedNodes);
    console.<span class="function">log</span>(<span class="string">'Removed:'</span>, mutation.removedNodes);
  });
});

observer.<span class="function">observe</span>(target, {
  childList: <span class="keyword">true</span>,
  attributes: <span class="keyword">true</span>,
  subtree: <span class="keyword">true</span>, <span class="comment">// Watch descendants too</span>
  characterData: <span class="keyword">true</span>
});</code></pre>

        <h3>Use Cases</h3>
        <ul style="margin-left: 1.5rem; color: var(--text-muted);">
            <li>Auto-resizing textareas when content injected</li>
            <li>Capturing analytics on dynamic content</li>
            <li>Sanitizing third-party HTML</li>
        </ul>

        <div class="pitfall">
            <div class="pitfall-title">‚ö†Ô∏è Pitfall: The Subtree Tax</div>
            <p><code>subtree: true</code> on a large tree is expensive. Be as specific as possible with your target.</p>
        </div>

        <div class="pitfall">
            <div class="pitfall-title">‚ö†Ô∏è Pitfall: Async Gaps</div>
            <p>Mutations between scheduled tasks might be missed if you don't check <code>takeRecords()</code> before disconnecting.</p>
            <pre><code><span class="comment">// Always flush pending records</span>
<span class="keyword">const</span> pending = observer.<span class="function">takeRecords</span>();
<span class="function">handleMutations</span>(pending);
observer.<span class="function">disconnect</span>();</code></pre>
        </div>
    </div>

    <div class="panel">
        <h3>üïµÔ∏è DOM Detective</h3>
        <p>Click "Add Chaos" to simulate random DOM changes. Watch the observer catch them in real-time.</p>
        
        <div class="controls">
            <button onclick="addNode()">Add Node</button>
            <button onclick="removeNode()">Remove Node</button>
            <button onclick="modifyAttribute()">Change Attribute</button>
            <button onclick="addChaos()">‚ö° Add Chaos</button>
            <button class="danger" onclick="clearLog()">Clear Log</button>
        </div>

        <div class="playground" style="min-height: 150px; margin-bottom: 1rem;">
            <div class="playground-header">Target Container (Under Surveillance)</div>
            <div class="playground-content" id="mutationTarget" style="display: flex; flex-wrap: wrap; gap: 0.5rem; align-content: flex-start;">
                <div class="node-box" style="padding: 1rem; background: var(--accent-blue); border-radius: 4px;">Target 1</div>
            </div>
        </div>

        <div class="mutation-log" id="mutationLog">
            <div class="log-entry" style="color: var(--text-muted);">Waiting for mutations...</div>
        </div>

        <div class="controls" style="margin-top: 1rem;">
            <button onclick="toggleObserver()" id="toggleBtn">Disconnect Observer</button>
        </div>
    </div>
</div>

<div id="custom" class="module container hidden">
    <div class="panel">
        <span class="tag">Module 5</span>
        <h2>Custom Elements</h2>
        
        <p>Web Components: Define new HTML tags with encapsulated behavior.</p>

        <pre><code><span class="keyword">class</span> <span class="function">StarRating</span> <span class="keyword">extends</span> HTMLElement {
  <span class="function">constructor</span>() {
    <span class="keyword">super</span>();
    <span class="keyword">this</span>.value = <span class="number">0</span>;
  }
  
  <span class="comment">// Lifecycle: element added to DOM</span>
  <span class="function">connectedCallback</span>() {
    <span class="keyword">this</span>.<span class="function">render</span>();
  }
  
  <span class="comment">// Lifecycle: attribute changed</span>
  <span class="function">attributeChangedCallback</span>(name, oldVal, newVal) {
    <span class="keyword">if</span> (name === <span class="string">'value'</span>) <span class="keyword">this</span>.<span class="function">render</span>();
  }
  
  <span class="keyword">static</span> <span class="keyword">get</span> <span class="function">observedAttributes</span>() {
    <span class="keyword">return</span> [<span class="string">'value'</span>];
  }
}

customElements.<span class="function">define</span>(<span class="string">'star-rating'</span>, StarRating);</code></pre>

        <div class="pitfall">
            <div class="pitfall-title">‚ö†Ô∏è Pitfall: Hyphen Requirement</div>
            <p>Custom element names <strong>must</strong> contain a hyphen (kebab-case). <code>&lt;mybutton&gt;</code> fails; <code>&lt;my-button&gt;</code> works. This prevents collisions with future HTML elements.</p>
        </div>

        <div class="pitfall">
            <div class="pitfall-title">‚ö†Ô∏è Pitfall: Upgrade Timing</div>
            <p>If you write HTML before defining the element, it exists as <code>HTMLUnknownElement</code> until defined. Use <code>customElements.whenDefined('tag-name')</code> to wait.</p>
        </div>
    </div>

    <div class="panel">
        <h3>üß© Live Component Builder</h3>
        <p>Edit the code below to customize the star rating, then click Register.</p>
        
        <textarea id="customElementCode" style="width: 100%; height: 200px; background: var(--bg-dark); color: var(--text-main); border: 1px solid var(--border); padding: 1rem; font-family: var(--font-mono); font-size: 0.85rem; border-radius: 8px; resize: vertical;">
class StarRating extends HTMLElement {
  constructor() {
    super();
    this.innerHTML = '‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ';
    this.style.color = '#8b949e';
    this.style.cursor = 'pointer';
    
    this.addEventListener('click', (e) => {
      const rect = this.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const width = rect.width;
      const rating = Math.ceil((x / width) * 5);
      this.style.color = '#58a6ff';
      this.innerHTML = '‚òÖ'.repeat(rating) + '‚òÜ'.repeat(5-rating);
    });
  }
}</textarea>

        <div class="controls">
            <button onclick="registerCustomElement()">Register Element</button>
            <button onclick="resetCustomElement()">Reset</button>
        </div>

        <div class="custom-element-demo" id="customElementDemo">
            <p style="color: var(--text-muted); margin-bottom: 1rem;">&lt;star-rating&gt; will appear here:</p>
            <star-rating id="demoStar"></star-rating>
        </div>

        <div class="quiz" style="margin-top: 1rem;">
            <h4>üéØ Lifecycle Order</h4>
            <p>What is the correct lifecycle order?</p>
            <div class="quiz-option" onclick="checkAnswer(this, true)">
                constructor ‚Üí attributeChangedCallback ‚Üí connectedCallback
            </div>
            <div class="quiz-option" onclick="checkAnswer(this, false)">
                connectedCallback ‚Üí constructor ‚Üí attributeChangedCallback
            </div>
            <div class="explanation">
                Constructor runs first (when instance created), then attributes are processed, then it's connected to DOM.
            </div>
        </div>
    </div>
</div>

<div id="final" class="module container hidden">
    <div class="panel" style="grid-column: 1 / -1;">
        <span class="tag success">Final Challenge</span>
        <h2>üéÆ The Performance Rescue Mission</h2>
        
        <p>You're hired to fix a broken news feed. It currently crashes mobile browsers. Use what you learned:</p>
        
        <div style="background: var(--bg-dark); padding: 1.5rem; border-radius: 8px; margin: 1rem 0; border: 1px solid var(--border);">
            <h4 style="color: var(--accent-orange); margin-bottom: 0.5rem;">Requirements:</h4>
            <ul style="margin-left: 1.5rem; color: var(--text-muted);">
                <li>Render 500 articles efficiently (no fragment? no hire!)</li>
                <li>Implement infinite scroll with IntersectionObserver</li>
                <li>Track which articles were read (MutationObserver on visibility)</li>
                <li>Create a reusable <code>&lt;article-card&gt;</code> custom element</li>
            </ul>
        </div>

        <div class="controls">
            <button class="success" onclick="runFinalChallenge()">Start Simulation</button>
            <button onclick="showSolution()">Show Solution Approach</button>
        </div>

        <div id="finalOutput" class="playground" style="margin-top: 1rem; min-height: 400px; display: none;">
            <div class="playground-header">News Feed Simulation</div>
            <div class="playground-content" id="newsFeed" style="max-height: 400px; overflow-y: auto;">
                <!-- Dynamic feed -->
            </div>
        </div>

        <div id="solution" style="display: none; margin-top: 1rem; padding: 1rem; background: rgba(88, 166, 255, 0.1); border-radius: 8px;">
            <h4>Solution Strategy:</h4>
            <ol style="margin-left: 1.5rem; color: var(--text-muted);">
                <li>Use <strong>DocumentFragment</strong> to batch append the initial 500 items</li>
                <li>Implement <strong>IntersectionObserver</strong> at the bottom sentinel to load more</li>
                <li>Use <strong>IntersectionObserver</strong> again on each article to track "read" status (time > 2s)</li>
                <li>Define <code>&lt;article-card&gt;</code> as Custom Element with shadow DOM for style encapsulation</li>
                <li>Disconnect observers in <code>disconnectedCallback</code> to prevent memory leaks</li>
            </ol>
        </div>
    </div>
</div>

<div class="badge" id="completionBadge">
    üèÜ Job Ready! All modules completed.
</div>

<script>
// State Management
const state = {
    currentModule: 'fragments',
    completed: new Set(),
    reflowCount: 0,
    observerCallbacks: 0
};

// Navigation
function showModule(moduleId) {
    document.querySelectorAll('.module').forEach(m => m.classList.add('hidden'));
    document.getElementById(moduleId).classList.remove('hidden');
    
    document.querySelectorAll('.nav-btn').forEach(btn => btn.classList.remove('active'));
    event.target.classList.add('active');
    
    state.currentModule = moduleId;
    
    // Initialize module-specific demos
    if (moduleId === 'intersection') initIntersectionDemo();
    if (moduleId === 'mutation') initMutationObserver();
    if (moduleId === 'custom') initCustomElement();
    
    updateProgress();
}

function updateProgress() {
    const modules = ['fragments', 'vdom', 'intersection', 'mutation', 'custom', 'final'];
    const index = modules.indexOf(state.currentModule);
    const progress = ((index + 1) / modules.length) * 100;
    document.getElementById('progressFill').style.width = progress + '%';
    
    state.completed.add(state.currentModule);
    if (state.completed.size === modules.length) {
        document.getElementById('completionBadge').style.display = 'block';
    }
}

// Module 1: DocumentFragment
let fragmentList = [];
function naiveAppend() {
    const list = document.getElementById('demoList');
    const start = performance.now();
    state.reflowCount = 0;
    
    for (let i = 0; i < 100; i++) {
        const li = document.createElement('li');
        li.textContent = `Item ${i}`;
        li.style.padding = '4px';
        li.style.borderBottom = '1px solid var(--border)';
        list.appendChild(li);
        state.reflowCount++; // Simulated reflow count
    }
    
    const end = performance.now();
    updateMetrics(100, end - start, state.reflowCount);
}

function fragmentAppend() {
    const list = document.getElementById('demoList');
    const fragment = document.createDocumentFragment();
    const start = performance.now();
    
    for (let i = 0; i < 100; i++) {
        const li = document.createElement('li');
        li.textContent = `Item ${i}`;
        li.style.padding = '4px';
        li.style.borderBottom = '1px solid var(--border)';
        fragment.appendChild(li);
    }
    
    list.appendChild(fragment);
    
    const end = performance.now();
    updateMetrics(100, end - start, 1);
}

function clearList() {
    document.getElementById('demoList').innerHTML = '';
    updateMetrics(0, 0, 0);
}

function updateMetrics(items, time, reflows) {
    document.getElementById('itemCount').textContent = items;
    document.getElementById('timeMetric').textContent = time.toFixed(2);
    const reflowEl = document.getElementById('reflowMetric');
    reflowEl.textContent = reflows;
    reflowEl.className = reflows > 10 ? 'metric-value bad' : 'metric-value';
}

// Module 2: Virtual DOM
let vdomState = {
    text: 'Hello World',
    clicks: 0
};

function updateVDOM() {
    const newText = document.getElementById('vdomInput').value;
    const container = document.getElementById('vdomTree');
    
    // Simulate diffing - only update text node if changed
    const oldText = vdomState.text;
    const changes = oldText !== newText ? 1 : 0;
    
    if (changes > 0) {
        // In real VDOM, we'd patch only the text node
        container.innerHTML = `
            <div class="node">
                <span class="node-tag">&lt;div&gt;</span>
                <div class="node">
                    <span class="node-tag">&lt;h1&gt;</span>
                    <span class="node-content highlight-pulse">${newText}</span>
                    <span class="node-tag">&lt;/h1&gt;</span>
                </div>
            </div>
        `;
        vdomState.text = newText;
    }
    
    document.getElementById('opCount').textContent = changes > 0 ? '1 patch' : '0 patches';
    document.getElementById('changeCount').textContent = changes;
}

function forceFullRender() {
    // Simulates innerHTML or naive re-render
    const container = document.getElementById('vdomTree');
    container.innerHTML = '';
    for (let i = 0; i < 50; i++) {
        const div = document.createElement('div');
        div.textContent = 'Node ' + i;
        container.appendChild(div);
    }
    document.getElementById('opCount').textContent = '50 operations';
    document.getElementById('changeCount').textContent = '50';
}

// Module 3: IntersectionObserver
let ioObserver;
function initIntersectionDemo() {
    const container = document.getElementById('scrollContainer');
    container.innerHTML = '';
    state.observerCallbacks = 0;
    updateObserverMetrics();
    
    // Generate items
    for (let i = 0; i < 20; i++) {
        const div = document.createElement('div');
        div.className = 'lazy-item';
        div.textContent = `Item ${i + 1} (Scroll to me)`;
        div.dataset.loaded = 'false';
        container.appendChild(div);
    }
    
    setupObserver(0.5);
}

function setupObserver(threshold) {
    if (ioObserver) ioObserver.disconnect();
    
    const options = {
        root: document.getElementById('scrollContainer'),
        threshold: parseFloat(threshold)
    };
    
    ioObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting && entry.target.dataset.loaded === 'false') {
                entry.target.classList.add('visible');
                entry.target.textContent = '‚úì Loaded!';
                entry.target.dataset.loaded = 'true';
                ioObserver.unobserve(entry.target); // Cleanup!
                state.observerCallbacks++;
                updateObserverMetrics();
            }
        });
    }, options);
    
    document.querySelectorAll('.lazy-item').forEach(item => {
        ioObserver.observe(item);
    });
}

function updateThreshold(val) {
    document.getElementById('thresholdValue').textContent = val;
    setupObserver(val);
}

function resetObserver() {
    initIntersectionDemo();
}

function updateObserverMetrics() {
    document.getElementById('callbackCount').textContent = state.observerCallbacks;
    const active = document.querySelectorAll('.lazy-item[data-loaded="false"]').length;
    document.getElementById('activeObservers').textContent = active;
}

// Module 4: MutationObserver
let moObserver;
let moActive = true;

function initMutationObserver() {
    const target = document.getElementById('mutationTarget');
    
    moObserver = new MutationObserver((mutations) => {
        const log = document.getElementById('mutationLog');
        mutations.forEach(mutation => {
            const entry = document.createElement('div');
            entry.className = 'log-entry';
            const time = new Date().toLocaleTimeString();
            
            if (mutation.type === 'childList') {
                entry.innerHTML = `<span style="color: var(--accent-blue)">[${time}]</span> ChildList: ${mutation.addedNodes.length} added, ${mutation.removedNodes.length} removed`;
            } else if (mutation.type === 'attributes') {
                entry.innerHTML = `<span style="color: var(--accent-orange)">[${time}]</span> Attribute: ${mutation.attributeName} on ${mutation.target.nodeName}`;
            }
            
            log.prepend(entry);
        });
    });
    
    moObserver.observe(target, {
        childList: true,
        attributes: true,
        subtree: true,
        attributeOldValue: true
    });
}

function addNode() {
    const target = document.getElementById('mutationTarget');
    const div = document.createElement('div');
    div.className = 'node-box';
    div.style.cssText = 'padding: 1rem; background: var(--accent-green); border-radius: 4px; animation: slideIn 0.3s ease;';
    div.textContent = 'New Node ' + Math.floor(Math.random() * 100);
    target.appendChild(div);
}

function removeNode() {
    const target = document.getElementById('mutationTarget');
    if (target.children.length > 0) {
        target.removeChild(target.lastElementChild);
    }
}

function modifyAttribute() {
    const target = document.getElementById('mutationTarget');
    if (target.children.length > 0) {
        const colors = ['var(--accent-blue)', 'var(--accent-green)', 'var(--accent-orange)', 'var(--accent-purple)'];
        const randomColor = colors[Math.floor(Math.random() * colors.length)];
        target.children[0].style.background = randomColor;
    }
}

function addChaos() {
    for (let i = 0; i < 3; i++) {
        setTimeout(() => {
            if (Math.random() > 0.5) addNode();
            else removeNode();
        }, i * 100);
    }
}

function clearLog() {
    document.getElementById('mutationLog').innerHTML = '<div class="log-entry" style="color: var(--text-muted);">Log cleared...</div>';
}

function toggleObserver() {
    const btn = document.getElementById('toggleBtn');
    if (moActive) {
        moObserver.disconnect();
        btn.textContent = 'Connect Observer';
        btn.className = 'success';
    } else {
        initMutationObserver();
        btn.textContent = 'Disconnect Observer';
        btn.className = 'danger';
    }
    moActive = !moActive;
}

// Module 5: Custom Elements
function initCustomElement() {
    // Default star rating defined in HTML
    if (!customElements.get('star-rating')) {
        registerCustomElement();
    }
}

function registerCustomElement() {
    const code = document.getElementById('customElementCode').value;
    
    try {
        // Dangerous eval for demo purposes - in production use proper modules
        eval(`
            if (customElements.get('star-rating')) {
                customElements.define('star-rating-temp', class extends HTMLElement {});
            }
            ${code}
            if (!customElements.get('star-rating')) {
                customElements.define('star-rating', StarRating);
            }
        `);
        
        // Refresh the demo
        const demo = document.getElementById('demoStar');
        const newDemo = document.createElement('star-rating');
        demo.replaceWith(newDemo);
        newDemo.id = 'demoStar';
        
        alert('Custom element registered successfully!');
    } catch (e) {
        alert('Error: ' + e.message);
    }
}

function resetCustomElement() {
    document.getElementById('customElementCode').value = `class StarRating extends HTMLElement {
  constructor() {
    super();
    this.innerHTML = '‚òÖ‚òÖ‚òÖ‚òÖ‚òÖ';
    this.style.color = '#8b949e';
    this.style.cursor = 'pointer';
    
    this.addEventListener('click', (e) => {
      const rect = this.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const width = rect.width;
      const rating = Math.ceil((x / width) * 5);
      this.style.color = '#58a6ff';
      this.innerHTML = '‚òÖ'.repeat(rating) + '‚òÜ'.repeat(5-rating);
    });
  }
}`;
}

// Quiz Logic
function checkAnswer(element, isCorrect) {
    const parent = element.parentElement;
    parent.querySelectorAll('.quiz-option').forEach(opt => {
        opt.classList.remove('correct', 'wrong');
        opt.style.pointerEvents = 'none';
    });
    
    if (isCorrect) {
        element.classList.add('correct');
        parent.querySelector('.explanation').style.display = 'block';
    } else {
        element.classList.add('wrong');
        // Find and show correct one
        parent.querySelectorAll('.quiz-option').forEach(opt => {
            if (opt.onclick.toString().includes('true')) {
                setTimeout(() => opt.classList.add('correct'), 500);
            }
        });
        parent.querySelector('.explanation').style.display = 'block';
    }
}

// Final Challenge
function runFinalChallenge() {
    document.getElementById('finalOutput').style.display = 'block';
    const feed = document.getElementById('newsFeed');
    feed.innerHTML = '<div style="color: var(--accent-blue); text-align: center; padding: 2rem;">Initializing optimized feed...</div>';
    
    // Simulate optimized rendering
    setTimeout(() => {
        feed.innerHTML = '';
        const fragment = document.createDocumentFragment();
        
        for (let i = 0; i < 20; i++) {
            const article = document.createElement('div');
            article.style.cssText = 'padding: 1rem; margin: 0.5rem 0; background: var(--bg-card); border-left: 3px solid var(--accent-green); border-radius: 4px;';
            article.innerHTML = `
                <h4 style="margin: 0 0 0.5rem 0;">Article ${i + 1}</h4>
                <p style="margin: 0; color: var(--text-muted); font-size: 0.9rem;">Optimized rendering with DocumentFragment ‚Ä¢ IntersectionObserver ready</p>
            `;
            fragment.appendChild(article);
        }
        
        feed.appendChild(fragment);
        
        // Add sentinel for infinite scroll
        const sentinel = document.createElement('div');
        sentinel.id = 'scroll-sentinel';
        sentinel.style.height = '20px';
        sentinel.style.background = 'var(--accent-blue)';
        sentinel.style.marginTop = '1rem';
        feed.appendChild(sentinel);
        
        // Setup infinite scroll observer
        const io = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    const more = document.createElement('div');
                    more.style.cssText = 'padding: 1rem; margin: 0.5rem 0; background: var(--bg-card); border-left: 3px solid var(--accent-purple); border-radius: 4px; animation: slideIn 0.3s ease;';
                    more.innerHTML = '<h4 style="margin: 0;">Dynamic Load</h4><p style="margin: 0; color: var(--text-muted);">Loaded via IntersectionObserver!</p>';
                    feed.insertBefore(more, sentinel);
                }
            });
        }, { root: feed, threshold: 0.5 });
        
        io.observe(sentinel);
        
    }, 1000);
}

function showSolution() {
    document.getElementById('solution').style.display = 'block';
}

// Initialize
window.onload = () => {
    updateVDOM();
};
</script>

</body>
</html>