<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ğŸ”„ Event Loop Mastery</title>
<style>
:root {
  --bg: #0f0f23;
  --card: #1a1a2e;
  --card2: #16213e;
  --text: #e0e0e0;
  --muted: #8892b0;
  --accent: #00d4ff;
  --stack: #ff6b6b;
  --micro: #4ecdc4;
  --macro: #ffd93d;
  --webapi: #a29bfe;
  --loop: #00b894;
  --raf: #fd79a8;
  --code-bg: #0d1117;
  --success: #00b894;
  --error: #ff6b6b;
  --border: #2d2d5e;
  --radius: 12px;
}
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: 'Segoe UI', system-ui, -apple-system, sans-serif; background: var(--bg); color: var(--text); line-height: 1.7; min-height: 100vh; }
a { color: var(--accent); }
header { background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); border-bottom: 1px solid var(--border); position: sticky; top: 0; z-index: 100; }
.header-top { display: flex; align-items: center; justify-content: space-between; padding: 12px 24px; }
.logo { font-size: 1.4rem; font-weight: 800; background: linear-gradient(90deg, var(--accent), var(--micro), var(--macro)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
.progress-bar { height: 3px; background: var(--border); border-radius: 2px; overflow: hidden; }
.progress-fill { height: 100%; width: 0%; background: linear-gradient(90deg, var(--accent), var(--micro)); transition: width 0.5s ease; }
nav { display: flex; overflow-x: auto; scrollbar-width: none; padding: 0 16px; gap: 4px; }
nav::-webkit-scrollbar { display: none; }
.tab-btn { padding: 10px 16px; background: none; border: none; color: var(--muted); font-size: 0.85rem; font-weight: 600; cursor: pointer; white-space: nowrap; border-bottom: 3px solid transparent; transition: all 0.3s; font-family: inherit; }
.tab-btn:hover { color: var(--text); background: rgba(255,255,255,0.03); }
.tab-btn.active { color: var(--accent); border-bottom-color: var(--accent); }
main { max-width: 1200px; margin: 0 auto; padding: 24px 16px 60px; }
.section { display: none; animation: fadeIn 0.4s ease; }
.section.active { display: block; }
@keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
@keyframes slideIn { from { opacity: 0; transform: translateX(-20px); } to { opacity: 1; transform: translateX(0); } }
@keyframes popIn { from { opacity: 0; transform: scale(0.8); } to { opacity: 1; transform: scale(1); } }
@keyframes pulse { 0%,100% { box-shadow: 0 0 0 0 rgba(0,212,255,0.4); } 50% { box-shadow: 0 0 0 8px rgba(0,212,255,0); } }
h1 { font-size: 2.2rem; margin-bottom: 8px; font-weight: 800; }
h2 { font-size: 1.6rem; margin-bottom: 16px; font-weight: 700; color: var(--accent); }
h3 { font-size: 1.2rem; margin-bottom: 12px; font-weight: 700; }
p { margin-bottom: 16px; color: var(--muted); }
.card { background: var(--card); border: 1px solid var(--border); border-radius: var(--radius); padding: 24px; margin-bottom: 20px; }
.card-accent { border-left: 4px solid var(--accent); }
.card-warn { border-left: 4px solid var(--macro); }
.card-success { border-left: 4px solid var(--success); }
.card-error { border-left: 4px solid var(--error); }
.grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
.grid-3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 16px; }
.badge { display: inline-block; padding: 3px 10px; border-radius: 20px; font-size: 0.75rem; font-weight: 700; }
.badge-stack { background: rgba(255,107,107,0.2); color: var(--stack); }
.badge-micro { background: rgba(78,205,196,0.2); color: var(--micro); }
.badge-macro { background: rgba(255,217,61,0.2); color: var(--macro); }
.badge-webapi { background: rgba(162,155,254,0.2); color: var(--webapi); }
.badge-raf { background: rgba(253,121,168,0.2); color: var(--raf); }
code { background: var(--code-bg); padding: 2px 7px; border-radius: 4px; font-family: 'Fira Code', 'Cascadia Code', 'Consolas', monospace; font-size: 0.9em; color: var(--accent); }
pre { background: var(--code-bg); padding: 16px 20px; border-radius: 8px; overflow-x: auto; font-family: 'Fira Code','Cascadia Code','Consolas', monospace; font-size: 0.88rem; line-height: 1.8; margin-bottom: 16px; border: 1px solid var(--border); }
.key-point { background: rgba(0,212,255,0.08); border-left: 4px solid var(--accent); padding: 16px 20px; border-radius: 0 8px 8px 0; margin: 16px 0; }
.key-point strong { color: var(--accent); }
/* Hero */
.hero { text-align: center; padding: 40px 0 32px; }
.hero h1 { font-size: 2.8rem; margin-bottom: 12px; }
.hero p { font-size: 1.1rem; max-width: 700px; margin: 0 auto 24px; }
.hero-diagram { display: flex; align-items: center; justify-content: center; gap: 12px; flex-wrap: wrap; margin: 32px auto; max-width: 700px; }
.hero-box { padding: 14px 22px; border-radius: 10px; font-weight: 700; font-size: 0.9rem; animation: popIn 0.5s ease both; }
.hero-box:nth-child(1) { background: rgba(255,107,107,0.15); color: var(--stack); border: 2px solid var(--stack); animation-delay: 0.1s; }
.hero-box:nth-child(2) { background: rgba(0,184,148,0.15); color: var(--loop); border: 2px solid var(--loop); animation-delay: 0.2s; }
.hero-box:nth-child(3) { background: rgba(78,205,196,0.15); color: var(--micro); border: 2px solid var(--micro); animation-delay: 0.3s; }
.hero-box:nth-child(4) { background: rgba(255,217,61,0.15); color: var(--macro); border: 2px solid var(--macro); animation-delay: 0.4s; }
.hero-box:nth-child(5) { background: rgba(253,121,168,0.15); color: var(--raf); border: 2px solid var(--raf); animation-delay: 0.5s; }
.hero-arrow { font-size: 1.4rem; color: var(--muted); animation: popIn 0.5s ease both; }
/* SIMULATOR */
.sim-container { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0; }
.sim-code-panel { background: var(--code-bg); border: 1px solid var(--border); border-radius: var(--radius); overflow: hidden; }
.sim-code-header { padding: 10px 16px; background: rgba(255,255,255,0.03); border-bottom: 1px solid var(--border); font-size: 0.8rem; font-weight: 700; color: var(--muted); display: flex; justify-content: space-between; }
.sim-code-body { padding: 12px 0; }
.sim-code-line { padding: 3px 16px; font-family: 'Fira Code','Cascadia Code','Consolas', monospace; font-size: 0.82rem; line-height: 1.7; transition: background 0.3s; display: flex; align-items: flex-start; gap: 12px; }
.sim-code-line .line-num { color: var(--muted); opacity: 0.4; min-width: 20px; text-align: right; user-select: none; }
.sim-code-line.highlighted { background: rgba(255,217,61,0.1); border-left: 3px solid var(--macro); }
.sim-viz { display: flex; flex-direction: column; gap: 12px; }
.sim-component { background: var(--card); border: 2px solid var(--border); border-radius: var(--radius); padding: 12px; min-height: 56px; transition: border-color 0.4s, box-shadow 0.4s; }
.sim-component.glow-stack { border-color: var(--stack); box-shadow: 0 0 15px rgba(255,107,107,0.2); }
.sim-component.glow-micro { border-color: var(--micro); box-shadow: 0 0 15px rgba(78,205,196,0.2); }
.sim-component.glow-macro { border-color: var(--macro); box-shadow: 0 0 15px rgba(255,217,61,0.2); }
.sim-component.glow-webapi { border-color: var(--webapi); box-shadow: 0 0 15px rgba(162,155,254,0.2); }
.sim-component.glow-loop { border-color: var(--loop); box-shadow: 0 0 15px rgba(0,184,148,0.2); }
.comp-title { font-size: 0.75rem; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; display: flex; align-items: center; gap: 6px; }
.comp-title .dot { width: 8px; height: 8px; border-radius: 50%; }
.dot-stack { background: var(--stack); }
.dot-micro { background: var(--micro); }
.dot-macro { background: var(--macro); }
.dot-webapi { background: var(--webapi); }
.dot-output { background: var(--success); }
.comp-items { display: flex; flex-direction: column; gap: 4px; }
.stack-items { flex-direction: column-reverse; }
.queue-items { flex-direction: row; flex-wrap: wrap; gap: 6px; }
.sim-item { padding: 5px 10px; border-radius: 6px; font-size: 0.78rem; font-family: 'Consolas', monospace; font-weight: 600; animation: popIn 0.3s ease; white-space: nowrap; }
.item-stack { background: rgba(255,107,107,0.15); color: var(--stack); border: 1px solid rgba(255,107,107,0.3); }
.item-micro { background: rgba(78,205,196,0.15); color: var(--micro); border: 1px solid rgba(78,205,196,0.3); }
.item-macro { background: rgba(255,217,61,0.15); color: var(--macro); border: 1px solid rgba(255,217,61,0.3); }
.item-webapi { background: rgba(162,155,254,0.15); color: var(--webapi); border: 1px solid rgba(162,155,254,0.3); }
.item-output { background: rgba(0,184,148,0.1); color: var(--success); border: 1px solid rgba(0,184,148,0.2); }
.sim-controls { display: flex; gap: 10px; margin: 16px 0; flex-wrap: wrap; align-items: center; }
.sim-desc { background: var(--card); border: 1px solid var(--border); border-radius: 8px; padding: 14px 18px; font-size: 0.92rem; min-height: 52px; line-height: 1.6; margin-bottom: 12px; }
.sim-desc .emoji { font-size: 1.1rem; }
.btn { padding: 10px 20px; border: none; border-radius: 8px; font-weight: 700; font-size: 0.88rem; cursor: pointer; transition: all 0.2s; font-family: inherit; }
.btn:active { transform: scale(0.96); }
.btn-primary { background: var(--accent); color: #000; }
.btn-primary:hover { background: #33ddff; }
.btn-secondary { background: var(--card2); color: var(--text); border: 1px solid var(--border); }
.btn-secondary:hover { background: var(--card); border-color: var(--accent); }
.btn-success { background: var(--success); color: #000; }
.btn-success:hover { background: #00d9a3; }
.btn-danger { background: var(--error); color: #fff; }
.btn-sm { padding: 7px 14px; font-size: 0.82rem; }
.btn-group { display: flex; gap: 6px; flex-wrap: wrap; margin-bottom: 16px; }
.btn-group .btn { border-radius: 6px; }
.btn-group .btn.active { background: var(--accent); color: #000; }
.scenario-tabs { display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap; }
.scenario-tab { padding: 8px 16px; background: var(--card2); border: 1px solid var(--border); border-radius: 8px; cursor: pointer; font-size: 0.82rem; font-weight: 600; color: var(--muted); transition: all 0.3s; font-family: inherit; }
.scenario-tab:hover { border-color: var(--accent); color: var(--text); }
.scenario-tab.active { background: rgba(0,212,255,0.1); border-color: var(--accent); color: var(--accent); }
.step-counter { font-size: 0.85rem; color: var(--muted); font-weight: 600; display: flex; align-items: center; gap: 4px; }
/* Challenges */
.challenge-card { background: var(--card); border: 1px solid var(--border); border-radius: var(--radius); padding: 24px; margin-bottom: 24px; }
.challenge-num { font-size: 0.8rem; font-weight: 700; color: var(--accent); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; }
.challenge-input { width: 100%; padding: 12px 16px; background: var(--code-bg); border: 2px solid var(--border); border-radius: 8px; color: var(--text); font-family: 'Consolas', monospace; font-size: 0.9rem; margin: 12px 0; resize: vertical; min-height: 60px; transition: border-color 0.3s; }
.challenge-input:focus { outline: none; border-color: var(--accent); }
.challenge-input::placeholder { color: var(--muted); opacity: 0.5; }
.challenge-result { margin-top: 12px; padding: 16px; border-radius: 8px; display: none; animation: fadeIn 0.3s ease; }
.challenge-result.show { display: block; }
.challenge-result.correct { background: rgba(0,184,148,0.1); border: 1px solid rgba(0,184,148,0.3); }
.challenge-result.wrong { background: rgba(255,107,107,0.1); border: 1px solid rgba(255,107,107,0.3); }
.challenge-result h4 { margin-bottom: 8px; }
.challenge-result.correct h4 { color: var(--success); }
.challenge-result.wrong h4 { color: var(--error); }
.hint-btn { background: none; border: 1px solid var(--border); color: var(--muted); padding: 4px 12px; border-radius: 6px; font-size: 0.8rem; cursor: pointer; font-family: inherit; }
.hint-text { color: var(--macro); font-size: 0.88rem; margin-top: 8px; display: none; }
.hint-text.show { display: block; }
/* Quiz */
.quiz-card { background: var(--card); border: 1px solid var(--border); border-radius: var(--radius); padding: 24px; margin-bottom: 20px; }
.quiz-q { font-weight: 700; margin-bottom: 16px; font-size: 1.05rem; }
.quiz-options { display: flex; flex-direction: column; gap: 8px; margin-bottom: 12px; }
.quiz-opt { padding: 12px 16px; background: var(--card2); border: 2px solid var(--border); border-radius: 8px; cursor: pointer; font-size: 0.92rem; transition: all 0.3s; display: flex; align-items: flex-start; gap: 10px; }
.quiz-opt:hover { border-color: var(--accent); background: rgba(0,212,255,0.05); }
.quiz-opt.selected { border-color: var(--accent); background: rgba(0,212,255,0.1); }
.quiz-opt.correct-answer { border-color: var(--success); background: rgba(0,184,148,0.15); }
.quiz-opt.wrong-answer { border-color: var(--error); background: rgba(255,107,107,0.15); }
.quiz-opt.disabled { pointer-events: none; opacity: 0.7; }
.quiz-opt .opt-letter { min-width: 28px; height: 28px; border-radius: 50%; background: var(--card); display: flex; align-items: center; justify-content: center; font-weight: 700; font-size: 0.8rem; }
.quiz-explanation { margin-top: 12px; padding: 14px; border-radius: 8px; background: rgba(0,184,148,0.08); border: 1px solid rgba(0,184,148,0.2); display: none; font-size: 0.9rem; color: var(--muted); }
.quiz-explanation.show { display: block; }
.quiz-score { text-align: center; padding: 32px; background: linear-gradient(135deg, var(--card), var(--card2)); border: 2px solid var(--border); border-radius: var(--radius); margin: 24px 0; }
.quiz-score .score-num { font-size: 3rem; font-weight: 800; color: var(--accent); }
.quiz-score .score-label { color: var(--muted); font-size: 1.1rem; }
/* Pitfalls */
.pitfall-card { background: var(--card); border: 1px solid var(--border); border-radius: var(--radius); margin-bottom: 16px; overflow: hidden; }
.pitfall-header { padding: 18px 24px; cursor: pointer; display: flex; align-items: center; justify-content: space-between; transition: background 0.2s; }
.pitfall-header:hover { background: rgba(255,255,255,0.02); }
.pitfall-header h3 { font-size: 1rem; display: flex; align-items: center; gap: 10px; }
.pitfall-arrow { transition: transform 0.3s; font-size: 1.2rem; color: var(--muted); }
.pitfall-card.open .pitfall-arrow { transform: rotate(180deg); }
.pitfall-body { max-height: 0; overflow: hidden; transition: max-height 0.4s ease; }
.pitfall-card.open .pitfall-body { max-height: 800px; }
.pitfall-content { padding: 0 24px 24px; }
.pitfall-content pre { margin-bottom: 12px; }
.pitfall-label { font-size: 0.78rem; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 6px; }
.pitfall-label.bad { color: var(--error); }
.pitfall-label.good { color: var(--success); }
/* Comparison table */
.comp-table { width: 100%; border-collapse: collapse; margin: 16px 0; }
.comp-table th, .comp-table td { padding: 12px 16px; text-align: left; border-bottom: 1px solid var(--border); font-size: 0.9rem; }
.comp-table th { background: var(--card2); font-weight: 700; color: var(--accent); font-size: 0.82rem; text-transform: uppercase; letter-spacing: 0.5px; }
.comp-table tr:hover td { background: rgba(255,255,255,0.02); }
/* rAF Demo */
.raf-demo-area { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 20px 0; }
.raf-lane { background: var(--card); border: 1px solid var(--border); border-radius: var(--radius); padding: 16px; }
.raf-lane h4 { margin-bottom: 12px; font-size: 0.9rem; text-align: center; }
.raf-track { background: var(--code-bg); border-radius: 8px; height: 50px; position: relative; overflow: hidden; margin-bottom: 8px; }
.raf-ball { width: 40px; height: 40px; border-radius: 50%; position: absolute; top: 5px; left: 5px; transition: none; }
.raf-ball.timeout-ball { background: linear-gradient(135deg, var(--macro), #ff9f43); }
.raf-ball.raf-ball-anim { background: linear-gradient(135deg, var(--raf), var(--micro)); }
.raf-fps { text-align: center; font-size: 0.85rem; color: var(--muted); font-weight: 600; }
.raf-fps span { color: var(--accent); font-size: 1.1rem; }
/* Scrollbar */
::-webkit-scrollbar { width: 6px; height: 6px; }
::-webkit-scrollbar-track { background: var(--bg); }
::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
.tag { display: inline-flex; align-items: center; gap: 4px; padding: 2px 8px; border-radius: 4px; font-size: 0.75rem; font-weight: 700; }
.tag-sync { background: rgba(0,212,255,0.15); color: var(--accent); }
.tag-async { background: rgba(253,121,168,0.15); color: var(--raf); }
.completed-check { color: var(--success); margin-left: 4px; }
/* Event Loop Diagram */
.loop-diagram { display: flex; justify-content: center; align-items: center; flex-wrap: wrap; gap: 16px; margin: 30px 0; }
.loop-phase { padding: 16px 24px; border-radius: 10px; text-align: center; font-weight: 700; font-size: 0.9rem; position: relative; }
.loop-phase::after { content: 'â†’'; position: absolute; right: -14px; top: 50%; transform: translateY(-50%); color: var(--muted); font-size: 1.2rem; }
.loop-phase:last-child::after { content: 'â†©'; }
/* Responsive */
@media (max-width: 768px) {
  .sim-container { grid-template-columns: 1fr; }
  .grid-2, .grid-3 { grid-template-columns: 1fr; }
  .raf-demo-area { grid-template-columns: 1fr; }
  .hero h1 { font-size: 1.8rem; }
  h2 { font-size: 1.3rem; }
  .tab-btn { padding: 8px 12px; font-size: 0.78rem; }
  main { padding: 16px 12px 60px; }
}
.console-line { font-family: 'Consolas', monospace; font-size: 0.85rem; padding: 2px 0; color: var(--success); }
.console-line::before { content: '> '; color: var(--muted); opacity: 0.5; }
.counter-pill { display: inline-flex; align-items: center; justify-content: center; min-width: 32px; height: 32px; background: var(--card2); border: 1px solid var(--border); border-radius: 50%; font-weight: 700; font-size: 0.85rem; }
.stat-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 12px; margin: 20px 0; }
.stat-card { background: var(--card2); border: 1px solid var(--border); border-radius: 10px; padding: 16px; text-align: center; }
.stat-card .stat-num { font-size: 1.8rem; font-weight: 800; }
.stat-card .stat-label { font-size: 0.78rem; color: var(--muted); text-transform: uppercase; letter-spacing: 0.5px; }
</style>
</head>
<body>

<header>
  <div class="header-top">
    <div class="logo">ğŸ”„ Event Loop Mastery</div>
    <div class="step-counter" id="progressText">0/8 Complete</div>
  </div>
  <div class="progress-bar"><div class="progress-fill" id="progressBar"></div></div>
  <nav id="tabNav"></nav>
</header>

<main>
  <!-- ===== SECTION: INTRO ===== -->
  <div class="section active" id="sec-intro">
    <div class="hero">
      <h1>ğŸ”„ Master the Event Loop</h1>
      <p>The event loop is the heartbeat of JavaScript. Understanding it separates junior developers from senior engineers. Let's master it together â€” visually, interactively, and deeply.</p>
      <div class="hero-diagram">
        <div class="hero-box">ğŸ“¦ Call Stack</div>
        <div class="hero-arrow">â†’</div>
        <div class="hero-box">ğŸ”„ Event Loop</div>
        <div class="hero-arrow">â†’</div>
        <div class="hero-box">âš¡ Microtasks</div>
        <div class="hero-arrow">â†’</div>
        <div class="hero-box">ğŸ“‹ Macrotasks</div>
        <div class="hero-arrow">â†’</div>
        <div class="hero-box">ğŸ¬ rAF & Paint</div>
      </div>
    </div>
    <div class="grid-3">
      <div class="card card-accent">
        <h3>ğŸ“– Learn</h3>
        <p>Visual explanations with animated diagrams that show exactly how code executes.</p>
      </div>
      <div class="card card-accent">
        <h3>ğŸ® Practice</h3>
        <p>6 interactive "Predict the Output" challenges and a step-through simulator.</p>
      </div>
      <div class="card card-accent">
        <h3>ğŸ“ Test</h3>
        <p>10-question quiz plus common pitfalls that catch even experienced devs.</p>
      </div>
    </div>
    <div class="card">
      <h3>Why This Matters for Interviews ğŸ¯</h3>
      <p>Event loop questions appear in 80%+ of senior JS interviews. They test whether you truly understand JavaScript's execution model â€” not just how to write code, but <strong style="color:var(--accent)">why</strong> code behaves the way it does.</p>
      <div class="key-point">
        <strong>ğŸ’¡ After this module, you'll be able to:</strong><br>
        â€¢ Predict the exact output order of any async code<br>
        â€¢ Explain microtask vs macrotask priority<br>
        â€¢ Debug subtle timing bugs with confidence<br>
        â€¢ Ace event loop interview questions
      </div>
    </div>
  </div>

  <!-- ===== SECTION: CALL STACK ===== -->
  <div class="section" id="sec-callstack">
    <h2>ğŸ“¦ The Call Stack</h2>
    <div class="card card-accent">
      <h3>What is the Call Stack?</h3>
      <p>The call stack is a <strong style="color:var(--stack)">LIFO (Last In, First Out)</strong> data structure that tracks function execution. When a function is called, it's <strong>pushed</strong> onto the stack. When it returns, it's <strong>popped</strong> off.</p>
      <p style="color:var(--text)">JavaScript is <strong>single-threaded</strong> â€” it has exactly <strong>one</strong> call stack. This means it can only do one thing at a time.</p>
    </div>

    <div class="grid-2">
      <div class="card">
        <h3 style="color:var(--success)">ğŸŸ¢ Push (Function Call)</h3>
        <p>When a function is <strong>invoked</strong>, a new frame is pushed onto the stack with its arguments and local variables.</p>
        <pre><span style="color:#e06c75">function</span> <span style="color:#61afef">greet</span>() {
  <span style="color:#c678dd">return</span> <span style="color:#98c379">"Hello!"</span>;
}
<span style="color:#61afef">greet</span>(); <span style="color:#5c6370">// pushed â†’ executed â†’ popped</span></pre>
      </div>
      <div class="card">
        <h3 style="color:var(--error)">ğŸ”´ Pop (Return)</h3>
        <p>When a function <strong>returns</strong> (explicitly or implicitly), it's removed from the top of the stack.</p>
        <pre><span style="color:#5c6370">// Stack grows down â†“</span>
<span style="color:#ffd93d">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span>
<span style="color:#ffd93d">â”‚ multiply(4,4)â”‚</span> â† top (runs first)
<span style="color:#ffd93d">â”‚ square(4)    â”‚</span>
<span style="color:#ffd93d">â”‚ main()       â”‚</span> â† bottom
<span style="color:#ffd93d">â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span></pre>
      </div>
    </div>

    <h3 style="margin-top:24px">ğŸ® Interactive Call Stack Simulator</h3>
    <p>Step through this code and watch the call stack change in real-time:</p>
    <div class="sim-container" id="stackSim"></div>
    <div class="sim-desc" id="stackDesc">Click <strong>"Step â†’"</strong> to start stepping through the code.</div>
    <div class="sim-controls">
      <button class="btn btn-primary" onclick="stepStack()">Step â†’ </button>
      <button class="btn btn-secondary" onclick="autoPlayStack()">â–¶ Auto Play</button>
      <button class="btn btn-secondary" onclick="resetStack()">â†© Reset</button>
      <span class="step-counter" id="stackCounter">Step 0/0</span>
    </div>

    <div class="card card-warn" style="margin-top:24px">
      <h3>âš ï¸ Stack Overflow</h3>
      <p>If the stack gets too deep (e.g., infinite recursion), you get a <strong style="color:var(--error)">RangeError: Maximum call stack size exceeded</strong>.</p>
      <pre><span style="color:#e06c75">function</span> <span style="color:#61afef">oops</span>() {
  <span style="color:#61afef">oops</span>(); <span style="color:#5c6370">// calls itself forever â†’ ğŸ’¥ Stack Overflow!</span>
}
<span style="color:#61afef">oops</span>();</pre>
      <p style="color:var(--error);font-weight:700">Each call adds a frame. With no base case, the stack fills up and crashes (~10,000-15,000 frames in most browsers).</p>
    </div>
  </div>

  <!-- ===== SECTION: EVENT LOOP ===== -->
  <div class="section" id="sec-eventloop">
    <h2>ğŸ”„ The Event Loop</h2>
    <div class="card card-accent">
      <h3>How JavaScript Handles Async</h3>
      <p>JS is single-threaded, but the <strong style="color:var(--loop)">event loop</strong> gives it the <em>appearance</em> of concurrency. The browser provides <strong style="color:var(--webapi)">Web APIs</strong> (timers, fetch, DOM events) that run on separate threads. When they complete, their callbacks are placed into queues for the event loop to process.</p>
    </div>

    <div class="key-point">
      <strong>ğŸ”„ The Event Loop Algorithm (Simplified):</strong><br>
      1. Execute everything on the <span class="badge badge-stack">Call Stack</span><br>
      2. When stack is empty â†’ drain ALL <span class="badge badge-micro">Microtasks</span><br>
      3. (Optional: render/paint step + <span class="badge badge-raf">rAF</span>)<br>
      4. Pick ONE <span class="badge badge-macro">Macrotask</span> â†’ execute it<br>
      5. Go to step 2 and repeat â™»ï¸
    </div>

    <h3 style="margin:24px 0 12px">ğŸ® Event Loop Visual Simulator</h3>
    <p>Choose a scenario and step through it to see exactly how the event loop processes code:</p>

    <div class="scenario-tabs" id="scenarioTabs"></div>
    <div class="sim-container" id="loopSim"></div>
    <div class="sim-desc" id="loopDesc">Select a scenario and click <strong>"Step â†’"</strong> to begin.</div>
    <div class="sim-controls">
      <button class="btn btn-primary" onclick="stepLoop()">Step â†’</button>
      <button class="btn btn-secondary" onclick="autoPlayLoop()">â–¶ Auto Play</button>
      <button class="btn btn-secondary" onclick="resetLoop()">â†© Reset</button>
      <span class="step-counter" id="loopCounter">Step 0/0</span>
    </div>
  </div>

  <!-- ===== SECTION: MICRO VS MACRO ===== -->
  <div class="section" id="sec-micromacro">
    <h2>âš¡ Microtasks vs Macrotasks</h2>
    <div class="card card-accent">
      <h3>The Two Queues</h3>
      <p>Async callbacks don't all go to the same queue. There are two types, and understanding their <strong style="color:var(--accent)">priority difference</strong> is crucial.</p>
    </div>

    <div class="grid-2">
      <div class="card" style="border-top:3px solid var(--micro)">
        <h3 style="color:var(--micro)">âš¡ Microtasks (High Priority)</h3>
        <p style="color:var(--text)">Run <strong>immediately</strong> after current task, before ANY macrotask or rendering. The entire queue is drained each time.</p>
        <ul style="color:var(--muted);list-style:none;padding:0;">
          <li>âœ… <code>Promise.then/catch/finally</code></li>
          <li>âœ… <code>queueMicrotask()</code></li>
          <li>âœ… <code>MutationObserver</code></li>
          <li>âœ… <code>await</code> (continuation after await)</li>
        </ul>
      </div>
      <div class="card" style="border-top:3px solid var(--macro)">
        <h3 style="color:var(--macro)">ğŸ“‹ Macrotasks (Normal Priority)</h3>
        <p style="color:var(--text)">Only <strong>one</strong> macrotask runs per event loop iteration. Then microtasks get checked again.</p>
        <ul style="color:var(--muted);list-style:none;padding:0;">
          <li>âœ… <code>setTimeout / setInterval</code></li>
          <li>âœ… <code>setImmediate</code> (Node.js)</li>
          <li>âœ… I/O callbacks</li>
          <li>âœ… UI rendering events</li>
          <li>âœ… <code>MessageChannel</code></li>
        </ul>
      </div>
    </div>

    <div class="card" style="margin-top:20px">
      <h3>ğŸ“Š Comparison Table</h3>
      <table class="comp-table">
        <thead>
          <tr><th>Feature</th><th style="color:var(--micro)">Microtasks</th><th style="color:var(--macro)">Macrotasks</th></tr>
        </thead>
        <tbody>
          <tr><td>Priority</td><td>âš¡ High â€” always first</td><td>ğŸ“‹ Normal â€” one at a time</td></tr>
          <tr><td>Queue draining</td><td>Entire queue drained</td><td>One per loop iteration</td></tr>
          <tr><td>Blocking render?</td><td>Yes! Can starve rendering</td><td>No â€” render can happen between</td></tr>
          <tr><td>Common source</td><td>Promises, queueMicrotask</td><td>setTimeout, events</td></tr>
          <tr><td>When processed</td><td>After current task completes</td><td>After microtasks + render</td></tr>
        </tbody>
      </table>
    </div>

    <div class="key-point">
      <strong>â­ THE GOLDEN RULE:</strong><br>
      After <em>every</em> task (including each macrotask), <strong>ALL</strong> pending microtasks run before <em>anything</em> else â€” even before the browser can render!
    </div>

    <div class="card card-warn">
      <h3>ğŸ”¥ Critical: Microtasks Inside Macrotasks</h3>
      <p>If a macrotask creates microtasks, those microtasks run <strong>before</strong> the next macrotask:</p>
      <pre><span style="color:#61afef">setTimeout</span>(() => {
  <span style="color:#61afef">console</span>.<span style="color:#61afef">log</span>(<span style="color:#98c379">'macro 1'</span>);
  <span style="color:#c678dd">Promise</span>.<span style="color:#61afef">resolve</span>().<span style="color:#61afef">then</span>(() => <span style="color:#61afef">console</span>.<span style="color:#61afef">log</span>(<span style="color:#98c379">'micro from macro'</span>));
}, <span style="color:#d19a66">0</span>);

<span style="color:#61afef">setTimeout</span>(() => {
  <span style="color:#61afef">console</span>.<span style="color:#61afef">log</span>(<span style="color:#98c379">'macro 2'</span>);
}, <span style="color:#d19a66">0</span>);

<span style="color:#5c6370">// Output: macro 1 â†’ micro from macro â†’ macro 2</span>
<span style="color:#5c6370">// The microtask squeezes in before macro 2!</span></pre>
    </div>

    <div class="card">
      <h3>ğŸ”„ Microtask Interleaving</h3>
      <p>When multiple promise chains exist, their <code>.then()</code> callbacks interleave:</p>
      <pre><span style="color:#c678dd">Promise</span>.<span style="color:#61afef">resolve</span>()
  .<span style="color:#61afef">then</span>(() => <span style="color:#61afef">console</span>.<span style="color:#61afef">log</span>(<span style="color:#98c379">'A1'</span>))
  .<span style="color:#61afef">then</span>(() => <span style="color:#61afef">console</span>.<span style="color:#61afef">log</span>(<span style="color:#98c379">'A2'</span>));

<span style="color:#c678dd">Promise</span>.<span style="color:#61afef">resolve</span>()
  .<span style="color:#61afef">then</span>(() => <span style="color:#61afef">console</span>.<span style="color:#61afef">log</span>(<span style="color:#98c379">'B1'</span>))
  .<span style="color:#61afef">then</span>(() => <span style="color:#61afef">console</span>.<span style="color:#61afef">log</span>(<span style="color:#98c379">'B2'</span>));

<span style="color:#5c6370">// Output: A1 â†’ B1 â†’ A2 â†’ B2 (interleaved!)</span>
<span style="color:#5c6370">// NOT: A1 â†’ A2 â†’ B1 â†’ B2</span></pre>
      <p>After sync code, the microtask queue has <code>[A1-cb, B1-cb]</code>. A1-cb runs and queues A2-cb. B1-cb runs and queues B2-cb. Then A2-cb and B2-cb run.</p>
    </div>
  </div>

  <!-- ===== SECTION: rAF ===== -->
  <div class="section" id="sec-raf">
    <h2>ğŸ¬ requestAnimationFrame</h2>
    <div class="card card-accent">
      <h3>What is requestAnimationFrame?</h3>
      <p><code>requestAnimationFrame(callback)</code> tells the browser to call your function <strong>before the next repaint</strong> â€” typically 60 times per second (every ~16.7ms). It's the right way to do JavaScript animations.</p>
    </div>

    <div class="key-point">
      <strong>ğŸ“ Where rAF fits in the Event Loop:</strong><br>
      Call Stack â†’ <span class="badge badge-micro">Microtasks</span> â†’ <span class="badge badge-raf">rAF callbacks</span> â†’ ğŸ¨ Browser Paint â†’ <span class="badge badge-macro">Next Macrotask</span>
    </div>

    <div class="grid-2">
      <div class="card" style="border-top:3px solid var(--macro)">
        <h3 style="color:var(--macro)">âŒ setTimeout for Animation</h3>
        <pre><span style="color:#e06c75">function</span> <span style="color:#61afef">animate</span>() {
  <span style="color:#61afef">moveBox</span>();
  <span style="color:#61afef">setTimeout</span>(<span style="color:#61afef">animate</span>, <span style="color:#d19a66">16</span>);
}
<span style="color:#61afef">animate</span>();</pre>
        <p>âŒ Not synced with display refresh<br>
           âŒ May fire too fast or too slow<br>
           âŒ Runs even in background tabs<br>
           âŒ Can cause jank and tearing</p>
      </div>
      <div class="card" style="border-top:3px solid var(--raf)">
        <h3 style="color:var(--raf)">âœ… requestAnimationFrame</h3>
        <pre><span style="color:#e06c75">function</span> <span style="color:#61afef">animate</span>() {
  <span style="color:#61afef">moveBox</span>();
  <span style="color:#61afef">requestAnimationFrame</span>(<span style="color:#61afef">animate</span>);
}
<span style="color:#61afef">requestAnimationFrame</span>(<span style="color:#61afef">animate</span>);</pre>
        <p>âœ… Synced with display refresh rate<br>
           âœ… Automatically throttled (60fps)<br>
           âœ… Paused in background tabs<br>
           âœ… Smooth, tear-free animations</p>
      </div>
    </div>

    <h3 style="margin:24px 0 12px">ğŸ® Live Animation Comparison</h3>
    <p>See the difference! Click "Start" and then "Add Jank" to simulate main thread blocking:</p>
    <div class="sim-controls">
      <button class="btn btn-primary" onclick="startRAFDemo()">â–¶ Start</button>
      <button class="btn btn-danger btn-sm" onclick="addJank()">ğŸ’¥ Add Jank (block 100ms)</button>
      <button class="btn btn-secondary btn-sm" onclick="stopRAFDemo()">â¹ Stop</button>
    </div>
    <div class="raf-demo-area">
      <div class="raf-lane">
        <h4 style="color:var(--macro)">setTimeout(fn, 16)</h4>
        <div class="raf-track"><div class="raf-ball timeout-ball" id="timeoutBall"></div></div>
        <div class="raf-fps">FPS: <span id="timeoutFPS">0</span></div>
      </div>
      <div class="raf-lane">
        <h4 style="color:var(--raf)">requestAnimationFrame</h4>
        <div class="raf-track"><div class="raf-ball raf-ball-anim" id="rafBall"></div></div>
        <div class="raf-fps">FPS: <span id="rafFPS">0</span></div>
      </div>
    </div>

    <div class="card" style="margin-top:20px">
      <h3>ğŸ“ rAF Key Patterns</h3>
      <pre><span style="color:#5c6370">// Pattern 1: Animation loop with timestamp</span>
<span style="color:#e06c75">function</span> <span style="color:#61afef">animate</span>(<span style="color:#d19a66">timestamp</span>) {
  <span style="color:#e06c75">const</span> elapsed = timestamp - lastTime;
  <span style="color:#5c6370">// Use elapsed for frame-rate independent animation</span>
  position += speed * elapsed;
  <span style="color:#61afef">element</span>.style.transform = <span style="color:#98c379">`translateX(</span>${position}<span style="color:#98c379">px)`</span>;
  lastTime = timestamp;
  <span style="color:#61afef">requestAnimationFrame</span>(<span style="color:#61afef">animate</span>);
}
<span style="color:#61afef">requestAnimationFrame</span>(<span style="color:#61afef">animate</span>);

<span style="color:#5c6370">// Pattern 2: Read/write batching to avoid layout thrashing</span>
<span style="color:#61afef">requestAnimationFrame</span>(() => {
  <span style="color:#5c6370">// READ layout properties</span>
  <span style="color:#e06c75">const</span> height = <span style="color:#61afef">el</span>.offsetHeight;
  <span style="color:#5c6370">// WRITE changes</span>
  <span style="color:#61afef">el</span>.style.height = height * <span style="color:#d19a66">2</span> + <span style="color:#98c379">'px'</span>;
});</pre>
    </div>
  </div>

  <!-- ===== SECTION: CHALLENGES ===== -->
  <div class="section" id="sec-challenges">
    <h2>ğŸ¯ Predict the Output</h2>
    <p>Test your understanding! Type the expected console output (one value per line), then check your answer.</p>
    <div class="stat-grid">
      <div class="stat-card"><div class="stat-num" id="challengeScore" style="color:var(--success)">0</div><div class="stat-label">Correct</div></div>
      <div class="stat-card"><div class="stat-num" id="challengeTotal">0</div><div class="stat-label">Attempted</div></div>
    </div>
    <div id="challengeContainer"></div>
  </div>

  <!-- ===== SECTION: QUIZ ===== -->
  <div class="section" id="sec-quiz">
    <h2>ğŸ“ Knowledge Quiz</h2>
    <p>10 questions to test your event loop mastery. Select an answer and see the explanation.</p>
    <div class="quiz-score" id="quizScoreCard" style="display:none">
      <div class="score-num" id="quizScoreNum">0/10</div>
      <div class="score-label" id="quizScoreLabel">Keep studying!</div>
    </div>
    <div id="quizContainer"></div>
    <div style="text-align:center;margin-top:20px">
      <button class="btn btn-primary" onclick="submitQuiz()">ğŸ“Š Show Final Score</button>
      <button class="btn btn-secondary" onclick="resetQuiz()">â†© Reset Quiz</button>
    </div>
  </div>

  <!-- ===== SECTION: PITFALLS ===== -->
  <div class="section" id="sec-pitfalls">
    <h2>âš ï¸ Common Mistakes & Pitfalls</h2>
    <p>These traps catch even experienced developers. Click each card to expand and learn how to avoid them.</p>
    <div id="pitfallContainer"></div>
  </div>
</main>

<script>
// ============================================================
//  TAB NAVIGATION
// ============================================================
const tabs = [
  { id: 'intro', label: 'ğŸ  Intro', icon: 'ğŸ ' },
  { id: 'callstack', label: 'ğŸ“¦ Call Stack', icon: 'ğŸ“¦' },
  { id: 'eventloop', label: 'ğŸ”„ Event Loop', icon: 'ğŸ”„' },
  { id: 'micromacro', label: 'âš¡ Micro vs Macro', icon: 'âš¡' },
  { id: 'raf', label: 'ğŸ¬ rAF', icon: 'ğŸ¬' },
  { id: 'challenges', label: 'ğŸ¯ Challenges', icon: 'ğŸ¯' },
  { id: 'quiz', label: 'ğŸ“ Quiz', icon: 'ğŸ“' },
  { id: 'pitfalls', label: 'âš ï¸ Pitfalls', icon: 'âš ï¸' }
];
const visited = new Set(['intro']);

function renderTabs() {
  const nav = document.getElementById('tabNav');
  nav.innerHTML = tabs.map(t =>
    `<button class="tab-btn${t.id === 'intro' ? ' active' : ''}" data-tab="${t.id}">
      ${t.label}${visited.has(t.id) && t.id !== 'intro' ? '<span class="completed-check">âœ“</span>' : ''}
    </button>`
  ).join('');
  nav.querySelectorAll('.tab-btn').forEach(btn => {
    btn.addEventListener('click', () => switchTab(btn.dataset.tab));
  });
}

function switchTab(id) {
  visited.add(id);
  document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
  document.getElementById('sec-' + id).classList.add('active');
  document.querySelectorAll('.tab-btn').forEach(b => {
    b.classList.toggle('active', b.dataset.tab === id);
  });
  updateProgress();
  renderTabs();
  window.scrollTo({ top: 0, behavior: 'smooth' });
}

function updateProgress() {
  const count = visited.size;
  const total = tabs.length;
  document.getElementById('progressText').textContent = `${count}/${total} Visited`;
  document.getElementById('progressBar').style.width = ((count / total) * 100) + '%';
}

renderTabs();
updateProgress();

// ============================================================
//  CALL STACK SIMULATOR
// ============================================================
const stackScenario = {
  code: [
    'function multiply(a, b) {',
    '  return a * b;',
    '}',
    'function square(n) {',
    '  return multiply(n, n);',
    '}',
    'const result = square(4);',
    'console.log(result);'
  ],
  steps: [
    { line: -1, stack: [], output: [], desc: 'ğŸ“ Program ready. The engine will start executing line by line.' },
    { line: 6, stack: ['main()'], output: [], desc: 'â–¶ï¸ Execution begins. The global execution context <strong>main()</strong> is pushed onto the call stack.' },
    { line: 6, stack: ['main()', 'square(4)'], output: [], desc: 'ğŸ“¥ <strong>square(4)</strong> is called and pushed onto the stack. Execution jumps into the function body.' },
    { line: 4, stack: ['main()', 'square(4)', 'multiply(4, 4)'], output: [], desc: 'ğŸ“¥ Inside square, <strong>multiply(4, 4)</strong> is called and pushed onto the stack.' },
    { line: 1, stack: ['main()', 'square(4)', 'multiply(4, 4)'], output: [], desc: 'ğŸ”¢ multiply calculates 4 Ã— 4 = 16.' },
    { line: 1, stack: ['main()', 'square(4)'], output: [], desc: 'ğŸ“¤ <strong>multiply</strong> returns 16 and is <strong>popped</strong> off the stack.' },
    { line: 4, stack: ['main()'], output: [], desc: 'ğŸ“¤ <strong>square</strong> returns 16 and is <strong>popped</strong> off the stack. result = 16.' },
    { line: 7, stack: ['main()', 'console.log(16)'], output: ['16'], desc: 'ğŸ“¥ <strong>console.log(16)</strong> is called. It prints "16" to the console.' },
    { line: 7, stack: ['main()'], output: ['16'], desc: 'ğŸ“¤ <strong>console.log</strong> is popped off the stack.' },
    { line: -1, stack: [], output: ['16'], desc: 'âœ… Program complete! <strong>main()</strong> is popped. The call stack is empty.' }
  ]
};

let stackStep = 0;
let stackAutoId = null;

function renderStackSim() {
  const container = document.getElementById('stackSim');
  const s = stackScenario;
  const step = s.steps[stackStep];
  container.innerHTML = `
    <div class="sim-code-panel">
      <div class="sim-code-header"><span>ğŸ“„ script.js</span><span class="tag tag-sync">SYNC</span></div>
      <div class="sim-code-body">
        ${s.code.map((line, i) => `<div class="sim-code-line${step.line === i ? ' highlighted' : ''}"><span class="line-num">${i + 1}</span><span>${escapeHtml(line)}</span></div>`).join('')}
      </div>
    </div>
    <div class="sim-viz">
      <div class="sim-component${step.stack.length ? ' glow-stack' : ''}">
        <div class="comp-title"><span class="dot dot-stack"></span> Call Stack</div>
        <div class="comp-items stack-items">
          ${step.stack.length === 0 ? '<span style="color:var(--muted);font-size:0.8rem;opacity:0.5">Empty</span>' : step.stack.map(item => `<div class="sim-item item-stack">${escapeHtml(item)}</div>`).join('')}
        </div>
      </div>
      <div class="sim-component">
        <div class="comp-title"><span class="dot dot-output"></span> Console Output</div>
        <div class="comp-items">
          ${step.output.length === 0 ? '<span style="color:var(--muted);font-size:0.8rem;opacity:0.5">No output yet</span>' : step.output.map(o => `<div class="console-line">${escapeHtml(o)}</div>`).join('')}
        </div>
      </div>
    </div>`;
  document.getElementById('stackDesc').innerHTML = step.desc;
  document.getElementById('stackCounter').textContent = `Step ${stackStep}/${s.steps.length - 1}`;
}

function stepStack() {
  if (stackStep < stackScenario.steps.length - 1) { stackStep++; renderStackSim(); }
  else { clearInterval(stackAutoId); stackAutoId = null; }
}
function autoPlayStack() {
  if (stackAutoId) { clearInterval(stackAutoId); stackAutoId = null; return; }
  if (stackStep >= stackScenario.steps.length - 1) resetStack();
  stackAutoId = setInterval(() => {
    if (stackStep >= stackScenario.steps.length - 1) { clearInterval(stackAutoId); stackAutoId = null; return; }
    stepStack();
  }, 1200);
}
function resetStack() { stackStep = 0; clearInterval(stackAutoId); stackAutoId = null; renderStackSim(); }

renderStackSim();

// ============================================================
//  EVENT LOOP SIMULATOR
// ============================================================
const loopScenarios = [
  {
    id: 'basic',
    title: '1ï¸âƒ£ Basic setTimeout',
    code: [
      'console.log("Start");',
      'setTimeout(() => {',
      '  console.log("Timeout");',
      '}, 0);',
      'console.log("End");'
    ],
    steps: [
      { line: -1, stack: [], webapis: [], micro: [], macro: [], output: [], glow: '', desc: 'ğŸ“ Ready. Let\'s see why setTimeout(fn, <strong>0</strong>) doesn\'t run immediately!' },
      { line: 0, stack: ['main()'], webapis: [], micro: [], macro: [], output: [], glow: 'stack', desc: 'â–¶ï¸ Execution begins. main() pushed to call stack.' },
      { line: 0, stack: ['main()','console.log("Start")'], webapis: [], micro: [], macro: [], output: ['Start'], glow: 'stack', desc: 'ğŸ“¥ console.log("Start") executes â†’ prints <strong>"Start"</strong>' },
      { line: 0, stack: ['main()'], webapis: [], micro: [], macro: [], output: ['Start'], glow: '', desc: 'ğŸ“¤ console.log popped from stack.' },
      { line: 1, stack: ['main()','setTimeout(cb, 0)'], webapis: [], micro: [], macro: [], output: ['Start'], glow: 'stack', desc: 'ğŸ“¥ setTimeout is called. It hands the callback to the <strong>Web API</strong>.' },
      { line: 1, stack: ['main()'], webapis: ['â± Timer(0ms)'], micro: [], macro: [], output: ['Start'], glow: 'webapi', desc: 'ğŸ“¤ setTimeout pops. The Web API starts a 0ms timer.' },
      { line: 1, stack: ['main()'], webapis: [], micro: [], macro: ['cb: log("Timeout")'], output: ['Start'], glow: 'macro', desc: 'â° Timer fires instantly! Callback moves to <strong>Macrotask Queue</strong>. But the stack isn\'t empty yet!' },
      { line: 4, stack: ['main()','console.log("End")'], webapis: [], micro: [], macro: ['cb: log("Timeout")'], output: ['Start','End'], glow: 'stack', desc: 'ğŸ“¥ console.log("End") executes â†’ prints <strong>"End"</strong>. The timeout callback is STILL waiting!' },
      { line: 4, stack: ['main()'], webapis: [], micro: [], macro: ['cb: log("Timeout")'], output: ['Start','End'], glow: '', desc: 'ğŸ“¤ console.log popped.' },
      { line: -1, stack: [], webapis: [], micro: [], macro: ['cb: log("Timeout")'], output: ['Start','End'], glow: 'loop', desc: 'ğŸ”„ <strong>main() pops. Stack is empty!</strong> Event loop wakes up. Checks microtasks (empty). Checks macrotasks (has one!).' },
      { line: 2, stack: ['callback()','console.log("Timeout")'], webapis: [], micro: [], macro: [], output: ['Start','End','Timeout'], glow: 'stack', desc: 'ğŸ“¥ Event loop pushes the callback. console.log("Timeout") runs â†’ prints <strong>"Timeout"</strong>' },
      { line: -1, stack: [], webapis: [], micro: [], macro: [], output: ['Start','End','Timeout'], glow: '', desc: 'âœ… Done! Output: <strong>Start â†’ End â†’ Timeout</strong>. Even with 0ms delay, setTimeout waits for the stack to clear!' }
    ]
  },
  {
    id: 'promise',
    title: '2ï¸âƒ£ Promise + setTimeout',
    code: [
      'console.log("1");',
      'setTimeout(() => console.log("2"), 0);',
      'Promise.resolve()',
      '  .then(() => console.log("3"));',
      'console.log("4");'
    ],
    steps: [
      { line: -1, stack: [], webapis: [], micro: [], macro: [], output: [], glow: '', desc: 'ğŸ“ This shows the <strong>priority difference</strong> between microtasks and macrotasks.' },
      { line: 0, stack: ['main()','console.log("1")'], webapis: [], micro: [], macro: [], output: ['1'], glow: 'stack', desc: 'ğŸ“¥ console.log("1") â†’ prints <strong>"1"</strong>' },
      { line: 1, stack: ['main()','setTimeout(cb, 0)'], webapis: [], micro: [], macro: [], output: ['1'], glow: 'stack', desc: 'ğŸ“¥ setTimeout called. Registers callback with Web API.' },
      { line: 1, stack: ['main()'], webapis: [], micro: [], macro: ['cb: log("2")'], output: ['1'], glow: 'macro', desc: 'â° Timer fires â†’ callback goes to <strong style="color:var(--macro)">Macrotask Queue</strong>.' },
      { line: 2, stack: ['main()','Promise.resolve().then(cb)'], webapis: [], micro: [], macro: ['cb: log("2")'], output: ['1'], glow: 'stack', desc: 'ğŸ“¥ Promise.resolve().then() is called. The .then callback is a <strong>microtask</strong>!' },
      { line: 2, stack: ['main()'], webapis: [], micro: ['cb: log("3")'], macro: ['cb: log("2")'], output: ['1'], glow: 'micro', desc: 'âš¡ Promise callback goes to <strong style="color:var(--micro)">Microtask Queue</strong>. Notice both queues have items now!' },
      { line: 4, stack: ['main()','console.log("4")'], webapis: [], micro: ['cb: log("3")'], macro: ['cb: log("2")'], output: ['1','4'], glow: 'stack', desc: 'ğŸ“¥ console.log("4") â†’ prints <strong>"4"</strong>. Both callbacks still waiting!' },
      { line: -1, stack: [], webapis: [], micro: ['cb: log("3")'], macro: ['cb: log("2")'], output: ['1','4'], glow: 'loop', desc: 'ğŸ”„ <strong>Stack empty!</strong> Event loop checks: microtasks first or macrotasks? <strong style="color:var(--micro)">MICROTASKS ALWAYS WIN!</strong>' },
      { line: 3, stack: ['Promise cb','console.log("3")'], webapis: [], micro: [], macro: ['cb: log("2")'], output: ['1','4','3'], glow: 'micro', desc: 'âš¡ <strong>Microtask runs first!</strong> console.log("3") â†’ prints <strong>"3"</strong>. setTimeout callback still waiting!' },
      { line: -1, stack: [], webapis: [], micro: [], macro: ['cb: log("2")'], output: ['1','4','3'], glow: 'loop', desc: 'ğŸ”„ Microtask queue empty. NOW check macrotask queue.' },
      { line: 1, stack: ['setTimeout cb','console.log("2")'], webapis: [], micro: [], macro: [], output: ['1','4','3','2'], glow: 'macro', desc: 'ğŸ“‹ Macrotask runs: console.log("2") â†’ prints <strong>"2"</strong>' },
      { line: -1, stack: [], webapis: [], micro: [], macro: [], output: ['1','4','3','2'], glow: '', desc: 'âœ… Done! Output: <strong>1 â†’ 4 â†’ 3 â†’ 2</strong>. Promise (.then) ran BEFORE setTimeout, even though both had 0 delay!' }
    ]
  },
  {
    id: 'complex',
    title: '3ï¸âƒ£ Complex Nesting',
    code: [
      'console.log("1");',
      'setTimeout(() => {',
      '  console.log("2");',
      '  Promise.resolve().then(() => console.log("3"));',
      '}, 0);',
      'Promise.resolve().then(() => {',
      '  console.log("4");',
      '  setTimeout(() => console.log("5"), 0);',
      '});',
      'console.log("6");'
    ],
    steps: [
      { line: -1, stack: [], webapis: [], micro: [], macro: [], output: [], glow: '', desc: 'ğŸ“ Expert level! Nested async operations. Let\'s trace every step.' },
      { line: 0, stack: ['main()','console.log("1")'], webapis: [], micro: [], macro: [], output: ['1'], glow: 'stack', desc: 'ğŸ“¥ console.log("1") â†’ prints <strong>"1"</strong>' },
      { line: 1, stack: ['main()','setTimeout(cb1, 0)'], webapis: [], micro: [], macro: [], output: ['1'], glow: 'stack', desc: 'ğŸ“¥ setTimeout registers cb1 (lines 2-4).' },
      { line: 1, stack: ['main()'], webapis: [], micro: [], macro: ['cb1: log("2")...'], output: ['1'], glow: 'macro', desc: 'â° Timer fires â†’ cb1 goes to <strong>Macrotask Queue</strong>.' },
      { line: 5, stack: ['main()','Promise.then(cb2)'], webapis: [], micro: [], macro: ['cb1: log("2")...'], output: ['1'], glow: 'stack', desc: 'ğŸ“¥ Promise.resolve().then() registers cb2 (lines 6-8).' },
      { line: 5, stack: ['main()'], webapis: [], micro: ['cb2: log("4")...'], macro: ['cb1: log("2")...'], output: ['1'], glow: 'micro', desc: 'âš¡ cb2 goes to <strong>Microtask Queue</strong>.' },
      { line: 9, stack: ['main()','console.log("6")'], webapis: [], micro: ['cb2: log("4")...'], macro: ['cb1: log("2")...'], output: ['1','6'], glow: 'stack', desc: 'ğŸ“¥ console.log("6") â†’ prints <strong>"6"</strong>' },
      { line: -1, stack: [], webapis: [], micro: ['cb2: log("4")...'], macro: ['cb1: log("2")...'], output: ['1','6'], glow: 'loop', desc: 'ğŸ”„ <strong>Stack empty!</strong> Event loop â†’ drain microtasks first!' },
      { line: 6, stack: ['cb2','console.log("4")'], webapis: [], micro: [], macro: ['cb1: log("2")...'], output: ['1','6','4'], glow: 'micro', desc: 'âš¡ Microtask cb2 runs: console.log("4") â†’ prints <strong>"4"</strong>' },
      { line: 7, stack: ['cb2','setTimeout(cb3,0)'], webapis: [], micro: [], macro: ['cb1: log("2")...','cb3: log("5")'], output: ['1','6','4'], glow: 'macro', desc: 'ğŸ“¥ cb2 calls setTimeout â†’ cb3 goes to <strong>Macrotask Queue</strong>. Two macrotasks waiting now!' },
      { line: -1, stack: [], webapis: [], micro: [], macro: ['cb1: log("2")...','cb3: log("5")'], output: ['1','6','4'], glow: 'loop', desc: 'ğŸ”„ Microtask queue empty. Pick <strong>one</strong> macrotask (cb1).' },
      { line: 2, stack: ['cb1','console.log("2")'], webapis: [], micro: [], macro: ['cb3: log("5")'], output: ['1','6','4','2'], glow: 'stack', desc: 'ğŸ“‹ Macrotask cb1 runs: console.log("2") â†’ prints <strong>"2"</strong>' },
      { line: 3, stack: ['cb1','Promise.then(cb4)'], webapis: [], micro: ['cb4: log("3")'], macro: ['cb3: log("5")'], output: ['1','6','4','2'], glow: 'micro', desc: 'âš¡ cb1 creates a Promise â†’ cb4 goes to <strong>Microtask Queue</strong>' },
      { line: -1, stack: [], webapis: [], micro: ['cb4: log("3")'], macro: ['cb3: log("5")'], output: ['1','6','4','2'], glow: 'loop', desc: 'ğŸ”„ cb1 done. Check microtasks <strong>before</strong> next macrotask!' },
      { line: 3, stack: ['cb4','console.log("3")'], webapis: [], micro: [], macro: ['cb3: log("5")'], output: ['1','6','4','2','3'], glow: 'micro', desc: 'âš¡ Microtask cb4 runs: console.log("3") â†’ prints <strong>"3"</strong>. Microtask squeezed in between macrotasks!' },
      { line: -1, stack: [], webapis: [], micro: [], macro: ['cb3: log("5")'], output: ['1','6','4','2','3'], glow: 'loop', desc: 'ğŸ”„ Microtask queue empty. Pick next macrotask (cb3).' },
      { line: 7, stack: ['cb3','console.log("5")'], webapis: [], micro: [], macro: [], output: ['1','6','4','2','3','5'], glow: 'stack', desc: 'ğŸ“‹ Macrotask cb3 runs: console.log("5") â†’ prints <strong>"5"</strong>' },
      { line: -1, stack: [], webapis: [], micro: [], macro: [], output: ['1','6','4','2','3','5'], glow: '', desc: 'âœ… Done! Output: <strong>1 â†’ 6 â†’ 4 â†’ 2 â†’ 3 â†’ 5</strong>. Notice how microtasks always run between macrotasks!' }
    ]
  }
];

let currentScenario = 0;
let loopStep = 0;
let loopAutoId = null;

function renderScenarioTabs() {
  document.getElementById('scenarioTabs').innerHTML = loopScenarios.map((s, i) =>
    `<button class="scenario-tab${i === currentScenario ? ' active' : ''}" onclick="selectScenario(${i})">${s.title}</button>`
  ).join('');
}

function selectScenario(i) {
  currentScenario = i;
  loopStep = 0;
  clearInterval(loopAutoId); loopAutoId = null;
  renderScenarioTabs();
  renderLoopSim();
}

function renderLoopSim() {
  const s = loopScenarios[currentScenario];
  const step = s.steps[loopStep];
  const container = document.getElementById('loopSim');

  container.innerHTML = `
    <div class="sim-code-panel">
      <div class="sim-code-header"><span>ğŸ“„ script.js</span><span class="tag tag-async">ASYNC</span></div>
      <div class="sim-code-body">
        ${s.code.map((line, i) => `<div class="sim-code-line${step.line === i ? ' highlighted' : ''}"><span class="line-num">${i + 1}</span><span>${escapeHtml(line)}</span></div>`).join('')}
      </div>
    </div>
    <div class="sim-viz">
      <div class="sim-component${step.glow === 'stack' ? ' glow-stack' : ''}">
        <div class="comp-title"><span class="dot dot-stack"></span> Call Stack</div>
        <div class="comp-items stack-items">
          ${step.stack.length === 0 ? '<span style="color:var(--muted);font-size:0.8rem;opacity:0.5">Empty</span>' : step.stack.map(it => `<div class="sim-item item-stack">${escapeHtml(it)}</div>`).join('')}
        </div>
      </div>
      <div class="sim-component${step.glow === 'webapi' ? ' glow-webapi' : ''}">
        <div class="comp-title"><span class="dot dot-webapi"></span> Web APIs</div>
        <div class="comp-items queue-items">
          ${step.webapis.length === 0 ? '<span style="color:var(--muted);font-size:0.8rem;opacity:0.5">â€”</span>' : step.webapis.map(it => `<div class="sim-item item-webapi">${it}</div>`).join('')}
        </div>
      </div>
      <div class="sim-component${step.glow === 'micro' ? ' glow-micro' : ''}">
        <div class="comp-title"><span class="dot dot-micro"></span> Microtask Queue <span class="badge badge-micro">HIGH PRIORITY</span></div>
        <div class="comp-items queue-items">
          ${step.micro.length === 0 ? '<span style="color:var(--muted);font-size:0.8rem;opacity:0.5">Empty</span>' : step.micro.map(it => `<div class="sim-item item-micro">${escapeHtml(it)}</div>`).join('')}
        </div>
      </div>
      <div class="sim-component${step.glow === 'macro' ? ' glow-macro' : ''}">
        <div class="comp-title"><span class="dot dot-macro"></span> Macrotask Queue</div>
        <div class="comp-items queue-items">
          ${step.macro.length === 0 ? '<span style="color:var(--muted);font-size:0.8rem;opacity:0.5">Empty</span>' : step.macro.map(it => `<div class="sim-item item-macro">${escapeHtml(it)}</div>`).join('')}
        </div>
      </div>
      <div class="sim-component${step.glow === 'loop' ? ' glow-loop' : ''}">
        <div class="comp-title"><span class="dot dot-output"></span> Console Output</div>
        <div class="comp-items">
          ${step.output.length === 0 ? '<span style="color:var(--muted);font-size:0.8rem;opacity:0.5">No output yet</span>' : step.output.map(o => `<div class="console-line">${escapeHtml(o)}</div>`).join('')}
        </div>
      </div>
    </div>`;

  document.getElementById('loopDesc').innerHTML = step.desc;
  document.getElementById('loopCounter').textContent = `Step ${loopStep}/${s.steps.length - 1}`;
}

function stepLoop() {
  const s = loopScenarios[currentScenario];
  if (loopStep < s.steps.length - 1) { loopStep++; renderLoopSim(); }
  else { clearInterval(loopAutoId); loopAutoId = null; }
}
function autoPlayLoop() {
  if (loopAutoId) { clearInterval(loopAutoId); loopAutoId = null; return; }
  const s = loopScenarios[currentScenario];
  if (loopStep >= s.steps.length - 1) resetLoop();
  loopAutoId = setInterval(() => {
    const s = loopScenarios[currentScenario];
    if (loopStep >= s.steps.length - 1) { clearInterval(loopAutoId); loopAutoId = null; return; }
    stepLoop();
  }, 1500);
}
function resetLoop() { loopStep = 0; clearInterval(loopAutoId); loopAutoId = null; renderLoopSim(); }

renderScenarioTabs();
renderLoopSim();

// ============================================================
//  CHALLENGES
// ============================================================
const challenges = [
  {
    code: `setTimeout(() => console.log('A'), 0);\nconsole.log('B');`,
    answer: 'B\nA',
    hint: 'setTimeout callback goes to the macrotask queue and waits for the stack to clear.',
    explanation: '<strong>B</strong> is synchronous and runs immediately. <strong>A</strong> is a macrotask â€” it goes to the queue and runs only after the call stack is empty. Even 0ms delay doesn\'t mean "immediate"!'
  },
  {
    code: `console.log('A');\nsetTimeout(() => console.log('B'), 0);\nPromise.resolve().then(() => console.log('C'));\nconsole.log('D');`,
    answer: 'A\nD\nC\nB',
    hint: 'Microtasks (Promise.then) always run before macrotasks (setTimeout).',
    explanation: '<strong>A, D</strong> are synchronous. Then the event loop drains microtasks: <strong>C</strong> (Promise.then). Then macrotasks: <strong>B</strong> (setTimeout). Microtasks ALWAYS have priority!'
  },
  {
    code: `new Promise((resolve) => {\n  console.log('A');\n  resolve();\n}).then(() => console.log('B'));\nconsole.log('C');`,
    answer: 'A\nC\nB',
    hint: 'âš ï¸ The Promise CONSTRUCTOR callback runs synchronously! Only .then() is async.',
    explanation: 'The function passed to <code>new Promise(fn)</code> runs <strong>synchronously</strong>! So <strong>A</strong> prints immediately. <strong>C</strong> is also sync. <strong>B</strong> (.then callback) is a microtask and runs after sync code. This catches many developers off guard!'
  },
  {
    code: `async function foo() {\n  console.log('A');\n  await Promise.resolve();\n  console.log('B');\n}\nconsole.log('C');\nfoo();\nconsole.log('D');`,
    answer: 'C\nA\nD\nB',
    hint: 'Code before await runs synchronously. Code after await is a microtask.',
    explanation: '<strong>C</strong> prints first (sync). Then <strong>foo()</strong> is called â€” <strong>A</strong> prints (sync, before await). The await suspends foo, scheduling the rest as a microtask. <strong>D</strong> prints (sync). Then the microtask runs: <strong>B</strong>. Remember: await = .then() under the hood!'
  },
  {
    code: `Promise.resolve()\n  .then(() => console.log('A'))\n  .then(() => console.log('B'));\n\nPromise.resolve()\n  .then(() => console.log('C'))\n  .then(() => console.log('D'));`,
    answer: 'A\nC\nB\nD',
    hint: 'Multiple promise chains interleave their .then() callbacks.',
    explanation: 'After sync code, the microtask queue has <strong>[A-cb, C-cb]</strong>. A-cb runs (logs A) and queues B-cb. C-cb runs (logs C) and queues D-cb. Queue now: <strong>[B-cb, D-cb]</strong>. They run in order: B, D. The chains <strong>interleave</strong>!'
  },
  {
    code: `setTimeout(() => {\n  console.log('A');\n  Promise.resolve().then(() => console.log('B'));\n}, 0);\n\nsetTimeout(() => {\n  console.log('C');\n}, 0);\n\nPromise.resolve().then(() => console.log('D'));`,
    answer: 'D\nA\nB\nC',
    hint: 'After EACH macrotask, ALL microtasks are drained before the next macrotask.',
    explanation: 'Sync code finishes. Microtask <strong>D</strong> runs first. Then macrotask 1: <strong>A</strong> prints and creates microtask B. Before macrotask 2 can run, microtask <strong>B</strong> runs. Then macrotask 2: <strong>C</strong>. Key insight: microtasks squeeze between macrotasks!'
  }
];

let challengeScore = 0;
let challengeAttempted = 0;

function renderChallenges() {
  document.getElementById('challengeContainer').innerHTML = challenges.map((c, i) => `
    <div class="challenge-card" id="challenge-${i}">
      <div class="challenge-num">Challenge ${i + 1} of ${challenges.length}</div>
      <h3>What is the console output?</h3>
      <pre>${escapeHtml(c.code)}</pre>
      <button class="hint-btn" onclick="toggleHint(${i})">ğŸ’¡ Show Hint</button>
      <div class="hint-text" id="hint-${i}">ğŸ’¡ ${c.hint}</div>
      <textarea class="challenge-input" id="input-${i}" placeholder="Type the output here, one value per line...&#10;Example:&#10;A&#10;B&#10;C" rows="4"></textarea>
      <button class="btn btn-primary btn-sm" onclick="checkChallenge(${i})">âœ” Check Answer</button>
      <div class="challenge-result" id="result-${i}">
        <h4></h4>
        <p></p>
      </div>
    </div>
  `).join('');
}

function toggleHint(i) {
  document.getElementById('hint-' + i).classList.toggle('show');
}

function checkChallenge(i) {
  const input = document.getElementById('input-' + i).value.trim();
  const result = document.getElementById('result-' + i);
  const expected = challenges[i].answer;
  const isCorrect = normalizeAnswer(input) === normalizeAnswer(expected);

  if (!result.classList.contains('show')) {
    challengeAttempted++;
    if (isCorrect) challengeScore++;
    document.getElementById('challengeScore').textContent = challengeScore;
    document.getElementById('challengeTotal').textContent = challengeAttempted;
  }

  result.className = 'challenge-result show ' + (isCorrect ? 'correct' : 'wrong');
  result.innerHTML = `
    <h4>${isCorrect ? 'ğŸ‰ Correct!' : 'âŒ Not quite!'}</h4>
    <p><strong>Expected output:</strong></p>
    <pre style="margin:8px 0">${escapeHtml(expected)}</pre>
    <p>${challenges[i].explanation}</p>`;
}

function normalizeAnswer(str) {
  return str.replace(/['"`,]/g, '').replace(/\s+/g, '\n').trim().toLowerCase();
}

renderChallenges();

// ============================================================
//  QUIZ
// ============================================================
const quizQuestions = [
  {
    q: 'What data structure does the JavaScript call stack use?',
    opts: ['Queue (FIFO)', 'Stack (LIFO)', 'Tree (hierarchical)', 'Hash Map'],
    correct: 1,
    explain: 'The call stack uses LIFO â€” Last In, First Out. The most recently called function is the first to return.'
  },
  {
    q: 'Which of these produces a <strong>microtask</strong>?',
    opts: ['setTimeout(fn, 0)', 'setInterval(fn, 100)', 'Promise.resolve().then(fn)', 'addEventListener("click", fn)'],
    correct: 2,
    explain: 'Promise.then/catch/finally callbacks are microtasks. setTimeout and setInterval create macrotasks. Event listeners create macrotasks when the event fires.'
  },
  {
    q: 'What is the output?<br><code>setTimeout(() => console.log(1), 0);<br>Promise.resolve().then(() => console.log(2));<br>console.log(3);</code>',
    opts: ['1, 2, 3', '3, 1, 2', '3, 2, 1', '2, 3, 1'],
    correct: 2,
    explain: '3 is synchronous (first). 2 is a microtask (second â€” higher priority). 1 is a macrotask (last). Microtasks always execute before macrotasks.'
  },
  {
    q: 'When does a <code>requestAnimationFrame</code> callback execute?',
    opts: ['Immediately when called', 'Before the next browser repaint', 'After all macrotasks complete', 'Every 100 milliseconds'],
    correct: 1,
    explain: 'rAF callbacks run right before the browser performs its next repaint, typically ~60 times per second (every ~16.7ms). This makes animations smooth and synchronized with the display.'
  },
  {
    q: 'What happens if microtasks keep scheduling more microtasks?',
    opts: ['They\'re moved to the macrotask queue', 'The browser renders between them', 'They ALL run before any macrotask (potentially blocking)', 'The browser throws an error after 1000 microtasks'],
    correct: 2,
    explain: 'The microtask queue is drained completely before moving on. If microtasks keep adding more microtasks, the loop continues until the queue is empty â€” potentially blocking rendering and macrotasks indefinitely!'
  },
  {
    q: 'What is the output?<br><code>new Promise((resolve) => {<br>&nbsp;&nbsp;console.log(1);<br>&nbsp;&nbsp;resolve();<br>}).then(() => console.log(2));<br>console.log(3);</code>',
    opts: ['1, 2, 3', '1, 3, 2', '3, 1, 2', '2, 1, 3'],
    correct: 1,
    explain: 'The Promise constructor callback runs SYNCHRONOUSLY â€” so 1 prints first. 3 is also sync. Only the .then() callback (2) is a microtask, running after sync code. Many people get this wrong!'
  },
  {
    q: 'Which is NOT a macrotask?',
    opts: ['setTimeout callback', 'setInterval callback', 'queueMicrotask callback', 'MessageChannel onmessage'],
    correct: 2,
    explain: 'queueMicrotask explicitly creates a microtask. All the others (setTimeout, setInterval, MessageChannel) create macrotasks.'
  },
  {
    q: 'After the call stack empties, what does the event loop check FIRST?',
    opts: ['Macrotask queue', 'Microtask queue', 'Render steps', 'setTimeout queue'],
    correct: 1,
    explain: 'The event loop always drains the microtask queue first before doing anything else â€” including rendering or processing macrotasks.'
  },
  {
    q: 'What causes a stack overflow?',
    opts: ['Too many setTimeout calls', 'Infinite recursion without a base case', 'Creating too many Promises', 'Using very large arrays'],
    correct: 1,
    explain: 'Infinite recursion keeps pushing frames onto the call stack without ever popping them, until the maximum stack size is exceeded (~10,000-15,000 frames).'
  },
  {
    q: 'What is the output?<br><code>console.log("start");<br>setTimeout(() => console.log("t1"), 0);<br>setTimeout(() => console.log("t2"), 0);<br>Promise.resolve().then(() => console.log("p1"));<br>Promise.resolve().then(() => console.log("p2"));<br>console.log("end");</code>',
    opts: [
      'start, end, p1, p2, t1, t2',
      'start, end, t1, t2, p1, p2',
      'start, p1, p2, end, t1, t2',
      'start, end, p1, t1, p2, t2'
    ],
    correct: 0,
    explain: 'Sync first: start, end. Then ALL microtasks: p1, p2 (microtask queue is fully drained). Then macrotasks in order: t1, t2. Microtasks always batch-complete before any macrotask runs.'
  }
];

let quizAnswered = {};

function renderQuiz() {
  document.getElementById('quizContainer').innerHTML = quizQuestions.map((q, i) => `
    <div class="quiz-card" id="quiz-${i}">
      <div class="quiz-q">${i + 1}. ${q.q}</div>
      <div class="quiz-options">
        ${q.opts.map((opt, j) => `
          <div class="quiz-opt" data-qi="${i}" data-oi="${j}" onclick="answerQuiz(${i},${j})">
            <span class="opt-letter">${String.fromCharCode(65 + j)}</span>
            <span>${opt}</span>
          </div>
        `).join('')}
      </div>
      <div class="quiz-explanation" id="quizexp-${i}">ğŸ’¡ ${q.explain}</div>
    </div>
  `).join('');
}

function answerQuiz(qi, oi) {
  if (quizAnswered[qi] !== undefined) return;
  quizAnswered[qi] = oi;
  const q = quizQuestions[qi];
  const opts = document.querySelectorAll(`[data-qi="${qi}"]`);
  opts.forEach((opt, j) => {
    opt.classList.add('disabled');
    if (j === q.correct) opt.classList.add('correct-answer');
    if (j === oi && j !== q.correct) opt.classList.add('wrong-answer');
  });
  document.getElementById('quizexp-' + qi).classList.add('show');
}

function submitQuiz() {
  const total = quizQuestions.length;
  let correct = 0;
  quizQuestions.forEach((q, i) => {
    if (quizAnswered[i] === q.correct) correct++;
  });
  const card = document.getElementById('quizScoreCard');
  card.style.display = 'block';
  document.getElementById('quizScoreNum').textContent = `${correct}/${total}`;
  const pct = (correct / total) * 100;
  const label = document.getElementById('quizScoreLabel');
  if (pct === 100) { label.textContent = 'ğŸ† Perfect! You\'ve mastered the event loop!'; label.style.color = 'var(--success)'; }
  else if (pct >= 80) { label.textContent = 'ğŸŒŸ Excellent! You have a strong understanding.'; label.style.color = 'var(--micro)'; }
  else if (pct >= 60) { label.textContent = 'ğŸ‘ Good effort! Review the sections you missed.'; label.style.color = 'var(--macro)'; }
  else { label.textContent = 'ğŸ“š Keep studying! Re-read the sections and try again.'; label.style.color = 'var(--error)'; }
  card.scrollIntoView({ behavior: 'smooth' });
}

function resetQuiz() {
  quizAnswered = {};
  document.getElementById('quizScoreCard').style.display = 'none';
  renderQuiz();
}

renderQuiz();

// ============================================================
//  PITFALLS
// ============================================================
const pitfalls = [
  {
    icon: 'â°',
    title: 'setTimeout(fn, 0) does NOT run immediately',
    bad: `setTimeout(() => {\n  console.log("I run first!");\n}, 0);\nconsole.log("Or do I?");\n// Output: "Or do I?" â†’ "I run first!"`,
    good: `// The 0ms delay is a MINIMUM, not exact.\n// The callback goes to the macrotask queue\n// and waits for the call stack to be empty\n// AND all microtasks to complete.`,
    detail: 'Even with a 0ms delay, setTimeout places the callback in the macrotask queue. It won\'t execute until: 1) The current script finishes, 2) All microtasks are drained. In practice, there\'s also a minimum ~4ms delay for nested setTimeouts.'
  },
  {
    icon: 'ğŸ—ï¸',
    title: 'Promise constructor runs SYNCHRONOUSLY',
    bad: `new Promise((resolve) => {\n  console.log("Am I async?"); // SYNC!\n  resolve();\n}).then(() => {\n  console.log("I am async"); // ASYNC\n});`,
    good: `// The executor function (passed to new Promise)\n// runs IMMEDIATELY and synchronously.\n// Only .then()/.catch()/.finally() callbacks\n// are scheduled as microtasks.`,
    detail: 'This is one of the most common misconceptions. The callback passed to new Promise(callback) executes synchronously when the Promise is created. Only the .then()/.catch()/.finally() handlers are asynchronous microtasks.'
  },
  {
    icon: 'ğŸ¥¶',
    title: 'Microtask starvation can freeze the UI',
    bad: `function forever() {\n  Promise.resolve().then(forever);\n}\nforever();\n// ğŸ’€ UI completely frozen!\n// Browser can never render or handle events`,
    good: `// If you need to yield to the browser, use:\nfunction work() {\n  doChunk();\n  setTimeout(work, 0); // macrotask â†’ allows render\n}\n// Or use scheduler.yield() (newer APIs)`,
    detail: 'The microtask queue is drained completely before rendering or processing macrotasks. If microtasks keep adding more microtasks, the browser can never paint or respond to user input. This is why infinite microtask loops are worse than infinite setTimeout loops (which at least allow rendering between tasks).'
  },
  {
    icon: 'â±ï¸',
    title: 'setTimeout delay is a MINIMUM, not exact',
    bad: `setTimeout(() => {\n  // Expects to run in exactly 1000ms\n  updateUI();\n}, 1000);\n// Could run at 1000ms, 1050ms, or even 2000ms+\n// if the main thread is busy!`,
    good: `// For precise timing, use:\nconst start = performance.now();\nrequestAnimationFrame(function check(now) {\n  if (now - start >= 1000) {\n    updateUI();\n  } else {\n    requestAnimationFrame(check);\n  }\n});`,
    detail: 'The delay argument specifies the minimum time before the callback is eligible to run. If the call stack is busy or there are other tasks ahead in the queue, the actual delay will be longer. For nested timeouts (depth > 5), browsers enforce a minimum 4ms delay.'
  },
  {
    icon: 'ğŸ”„',
    title: 'async/await is just Promise sugar',
    bad: `async function fetchData() {\n  console.log("before await"); // SYNC\n  const data = await fetch(url);\n  console.log("after await"); // MICROTASK!\n}\n// Many devs think the whole function is async`,
    good: `// Code BEFORE await runs synchronously\n// Code AFTER await is like a .then() callback\n// It becomes a microtask scheduled for later\n\n// This is equivalent to:\nfunction fetchData() {\n  console.log("before await"); // SYNC\n  return fetch(url).then(data => {\n    console.log("after await"); // MICROTASK\n  });\n}`,
    detail: 'Everything before the first await in an async function runs synchronously. The await keyword effectively splits the function â€” the rest becomes a .then() callback (a microtask). This is why console.log() before await prints immediately, but after await it\'s deferred.'
  },
  {
    icon: 'ğŸ”€',
    title: 'Each macrotask gets its own microtask checkpoint',
    bad: `// WRONG assumption:\n// "All macrotasks run, then all microtasks"\n\n// CORRECT behavior:\n// macrotask 1 â†’ drain ALL microtasks\n// â†’ macrotask 2 â†’ drain ALL microtasks\n// â†’ macrotask 3 â†’ drain ALL microtasks`,
    good: `setTimeout(() => {\n  console.log("macro 1");\n  queueMicrotask(() => console.log("micro A"));\n}, 0);\nsetTimeout(() => {\n  console.log("macro 2");\n}, 0);\n// Output: macro 1 â†’ micro A â†’ macro 2\n// micro A runs BETWEEN the two macrotasks!`,
    detail: 'The event loop processes ONE macrotask, then checks and fully drains the microtask queue, then optionally renders, then picks the next macrotask. This cycle repeats. Microtasks created during a macrotask run before the next macrotask starts.'
  },
  {
    icon: 'ğŸ§±',
    title: 'Blocking the event loop with synchronous code',
    bad: `button.addEventListener('click', () => {\n  // Heavy computation blocks EVERYTHING\n  for (let i = 0; i < 1e9; i++) { /* ... */ }\n  // During this loop:\n  // âŒ UI is frozen\n  // âŒ No animations\n  // âŒ No user input\n  // âŒ No timers fire\n});`,
    good: `// Solution 1: Web Workers (separate thread)\nconst worker = new Worker('heavy.js');\nworker.postMessage(data);\n\n// Solution 2: Break into chunks\nfunction processChunk(i) {\n  const end = Math.min(i + 1000, total);\n  for (; i < end; i++) { /* work */ }\n  if (i < total) setTimeout(() => processChunk(i), 0);\n}`,
    detail: 'JavaScript\'s single thread handles both your code AND the UI. Any long-running synchronous operation blocks rendering, event handling, and all async callbacks. Break heavy work into chunks or offload to Web Workers.'
  }
];

function renderPitfalls() {
  document.getElementById('pitfallContainer').innerHTML = pitfalls.map((p, i) => `
    <div class="pitfall-card" id="pitfall-${i}">
      <div class="pitfall-header" onclick="togglePitfall(${i})">
        <h3>${p.icon} ${p.title}</h3>
        <span class="pitfall-arrow">â–¼</span>
      </div>
      <div class="pitfall-body">
        <div class="pitfall-content">
          <div class="pitfall-label bad">âŒ The Mistake</div>
          <pre>${escapeHtml(p.bad)}</pre>
          <div class="pitfall-label good">âœ… The Reality / Fix</div>
          <pre>${escapeHtml(p.good)}</pre>
          <div class="key-point">
            <strong>ğŸ“ Why this matters:</strong><br>${p.detail}
          </div>
        </div>
      </div>
    </div>
  `).join('');
}

function togglePitfall(i) {
  document.getElementById('pitfall-' + i).classList.toggle('open');
}

renderPitfalls();

// ============================================================
//  rAF DEMO
// ============================================================
let rafRunning = false;
let timeoutAnimId = null;
let rafAnimId = null;
let timeoutPos = 5, rafPos = 5;
let timeoutDirection = 1, rafDirection = 1;
const BALL_SIZE = 40; // px
let timeoutLastTimestamp = 0;
let rafFrameCount = 0, timeoutFrameCount = 0;
let rafLastFPSUpdate = 0, timeoutLastFPSUpdate = 0;
let rafFPS = 0, timeoutFPS = 0;

function getTrackWidth() {
  // Use the first track element to get available width
  const track = document.querySelector('.raf-track');
  return track ? track.clientWidth - BALL_SIZE : 300; // fallback
}

function moveTimeoutBall() {
  if (!rafRunning) return;
  const trackWidth = getTrackWidth();
  timeoutPos += timeoutDirection * 2; // speed
  if (timeoutPos <= 5) {
    timeoutPos = 5;
    timeoutDirection = 1;
  } else if (timeoutPos >= trackWidth - 5) {
    timeoutPos = trackWidth - 5;
    timeoutDirection = -1;
  }
  document.getElementById('timeoutBall').style.left = timeoutPos + 'px';

  // FPS counting
  timeoutFrameCount++;
  const now = performance.now();
  if (now - timeoutLastFPSUpdate >= 1000) {
    timeoutFPS = Math.round((timeoutFrameCount * 1000) / (now - timeoutLastFPSUpdate));
    document.getElementById('timeoutFPS').textContent = timeoutFPS;
    timeoutFrameCount = 0;
    timeoutLastFPSUpdate = now;
  }

  // Schedule next move
  timeoutAnimId = setTimeout(moveTimeoutBall, 16); // ~60fps
}

function moveRAFBall(timestamp) {
  if (!rafRunning) {
    rafAnimId = null;
    return;
  }
  const trackWidth = getTrackWidth();
  rafPos += rafDirection * 2;
  if (rafPos <= 5) {
    rafPos = 5;
    rafDirection = 1;
  } else if (rafPos >= trackWidth - 5) {
    rafPos = trackWidth - 5;
    rafDirection = -1;
  }
  document.getElementById('rafBall').style.left = rafPos + 'px';

  // FPS counting
  rafFrameCount++;
  const now = performance.now();
  if (now - rafLastFPSUpdate >= 1000) {
    rafFPS = Math.round((rafFrameCount * 1000) / (now - rafLastFPSUpdate));
    document.getElementById('rafFPS').textContent = rafFPS;
    rafFrameCount = 0;
    rafLastFPSUpdate = now;
  }

  // Continue the loop
  rafAnimId = requestAnimationFrame(moveRAFBall);
}

function startRAFDemo() {
  if (rafRunning) return;
  rafRunning = true;
  // Reset positions
  timeoutPos = 5;
  rafPos = 5;
  timeoutDirection = 1;
  rafDirection = 1;
  document.getElementById('timeoutBall').style.left = '5px';
  document.getElementById('rafBall').style.left = '5px';
  // Reset FPS counters
  timeoutFrameCount = 0;
  rafFrameCount = 0;
  timeoutLastFPSUpdate = performance.now();
  rafLastFPSUpdate = performance.now();
  document.getElementById('timeoutFPS').textContent = '0';
  document.getElementById('rafFPS').textContent = '0';
  // Start animations
  moveTimeoutBall();
  rafAnimId = requestAnimationFrame(moveRAFBall);
}

function stopRAFDemo() {
  rafRunning = false;
  if (timeoutAnimId) {
    clearTimeout(timeoutAnimId);
    timeoutAnimId = null;
  }
  if (rafAnimId) {
    cancelAnimationFrame(rafAnimId);
    rafAnimId = null;
  }
}

function addJank() {
  // Block the main thread for ~100ms to simulate jank
  const start = performance.now();
  while (performance.now() - start < 100) {
    // Busy wait
  }
  // Also log to console for debugging
  console.log('ğŸ’¥ Jank added (blocked for 100ms)');
}

// Make sure buttons are wired (they are via onclick attributes)

// ============================================================
//  UTILITY FUNCTIONS
// ============================================================
function escapeHtml(unsafe) {
  if (!unsafe) return '';
  return unsafe
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&#039;");
}

// ============================================================
//  INITIALIZATION (ensure any remaining setup)
// ============================================================
// (All other sections have already been initialized above)
console.log('Event Loop Mastery App loaded.');
</script>
</body>
</html>