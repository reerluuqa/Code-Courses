<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fetch Mastery: The HTTP Adventure</title>
    <style>
        :root {
            --bg-dark: #0d1117;
            --bg-card: #161b22;
            --border: #30363d;
            --text-primary: #c9d1d9;
            --text-secondary: #8b949e;
            --accent-blue: #58a6ff;
            --accent-green: #238636;
            --accent-yellow: #d29922;
            --accent-red: #da3633;
            --accent-purple: #8957e5;
            --code-bg: #1f2937;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            line-height: 1.6;
            overflow-x: hidden;
        }

        /* Header & Progress */
        .header {
            background: var(--bg-card);
            border-bottom: 1px solid var(--border);
            padding: 1rem 2rem;
            position: sticky;
            top: 0;
            z-index: 100;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: bold;
            background: linear-gradient(45deg, var(--accent-blue), var(--accent-purple));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .xp-bar {
            display: flex;
            align-items: center;
            gap: 1rem;
            font-size: 0.9rem;
        }

        .progress-container {
            width: 200px;
            height: 8px;
            background: var(--bg-dark);
            border-radius: 4px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-green), var(--accent-blue));
            width: 0%;
            transition: width 0.5s ease;
        }

        /* Layout */
        .container {
            display: grid;
            grid-template-columns: 250px 1fr;
            max-width: 1400px;
            margin: 0 auto;
            min-height: calc(100vh - 70px);
        }

        /* Sidebar Navigation */
        .sidebar {
            background: var(--bg-card);
            border-right: 1px solid var(--border);
            padding: 2rem 1rem;
        }

        .nav-item {
            padding: 0.75rem 1rem;
            margin-bottom: 0.5rem;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            border: 1px solid transparent;
        }

        .nav-item:hover {
            background: rgba(88, 166, 255, 0.1);
            border-color: var(--border);
        }

        .nav-item.active {
            background: rgba(88, 166, 255, 0.15);
            border-color: var(--accent-blue);
            color: var(--accent-blue);
        }

        .nav-item.locked {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .nav-icon {
            width: 20px;
            text-align: center;
        }

        /* Main Content */
        .content {
            padding: 2rem;
            overflow-y: auto;
        }

        .section {
            display: none;
            animation: fadeIn 0.3s ease;
        }

        .section.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Cards */
        .card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 2rem;
            margin-bottom: 2rem;
            position: relative;
            overflow: hidden;
        }

        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, var(--accent-blue), var(--accent-purple));
        }

        h1 { font-size: 2.5rem; margin-bottom: 1rem; color: #fff; }
        h2 { font-size: 1.8rem; margin: 2rem 0 1rem; color: var(--accent-blue); }
        h3 { font-size: 1.3rem; margin: 1.5rem 0 0.5rem; color: var(--text-primary); }

        /* Visual Explanations */
        .http-visualizer {
            background: var(--code-bg);
            border-radius: 8px;
            padding: 2rem;
            margin: 2rem 0;
            position: relative;
            min-height: 300px;
        }

        .network-flow {
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: relative;
            padding: 2rem 0;
        }

        .network-node {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            position: relative;
            z-index: 2;
            transition: transform 0.3s;
        }

        .client { background: var(--accent-blue); }
        .server { background: var(--accent-green); }
        .error { background: var(--accent-red); }

        .network-line {
            flex: 1;
            height: 4px;
            background: var(--border);
            position: relative;
            margin: 0 1rem;
            overflow: hidden;
        }

        .packet {
            position: absolute;
            width: 12px;
            height: 12px;
            background: var(--accent-yellow);
            border-radius: 50%;
            top: 50%;
            transform: translateY(-50%);
            box-shadow: 0 0 10px var(--accent-yellow);
        }

        @keyframes sendPacket {
            0% { left: 0; }
            100% { left: 100%; }
        }

        @keyframes receivePacket {
            0% { left: 100%; }
            100% { left: 0; }
        }

        .sending .packet { animation: sendPacket 1.5s ease-in-out infinite; }
        .receiving .packet { animation: receivePacket 1.5s ease-in-out infinite; }

        /* Code Blocks */
        .code-block {
            background: var(--code-bg);
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1rem 0;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
            overflow-x: auto;
            position: relative;
            border: 1px solid var(--border);
        }

        .code-label {
            position: absolute;
            top: 0;
            right: 0;
            background: var(--border);
            padding: 0.25rem 0.75rem;
            font-size: 0.75rem;
            border-bottom-left-radius: 8px;
            color: var(--text-secondary);
        }

        .code-good { border-left: 4px solid var(--accent-green); }
        .code-bad { border-left: 4px solid var(--accent-red); }
        .code-warning { border-left: 4px solid var(--accent-yellow); }

        /* Interactive Playground */
        .playground {
            background: var(--code-bg);
            border-radius: 8px;
            border: 2px solid var(--border);
            margin: 2rem 0;
        }

        .playground-header {
            background: var(--bg-card);
            padding: 0.75rem 1rem;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .editor {
            width: 100%;
            min-height: 200px;
            background: transparent;
            color: var(--text-primary);
            font-family: monospace;
            font-size: 0.9rem;
            padding: 1rem;
            border: none;
            resize: vertical;
            outline: none;
            line-height: 1.5;
        }

        .console-output {
            background: #000;
            color: #0f0;
            padding: 1rem;
            font-family: monospace;
            font-size: 0.85rem;
            min-height: 150px;
            max-height: 300px;
            overflow-y: auto;
            border-top: 1px solid var(--border);
        }

        .console-line { margin: 0.25rem 0; }
        .console-error { color: var(--accent-red); }
        .console-success { color: var(--accent-green); }
        .console-info { color: var(--accent-blue); }

        /* Buttons */
        .btn {
            background: var(--accent-blue);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.9rem;
            font-weight: 600;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn:hover { background: #4791db; transform: translateY(-1px); }
        .btn:active { transform: translateY(0); }
        .btn-secondary { background: var(--border); }
        .btn-secondary:hover { background: #444c56; }
        .btn-success { background: var(--accent-green); }
        .btn-danger { background: var(--accent-red); }

        /* Quiz Styles */
        .quiz-option {
            background: var(--bg-dark);
            border: 2px solid var(--border);
            padding: 1rem;
            margin: 0.5rem 0;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .quiz-option:hover { border-color: var(--accent-blue); background: rgba(88, 166, 255, 0.05); }
        .quiz-option.selected { border-color: var(--accent-blue); background: rgba(88, 166, 255, 0.1); }
        .quiz-option.correct { border-color: var(--accent-green); background: rgba(35, 134, 54, 0.1); }
        .quiz-option.wrong { border-color: var(--accent-red); background: rgba(218, 54, 51, 0.1); }

        .quiz-indicator {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            border: 2px solid var(--text-secondary);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
        }

        .quiz-option.correct .quiz-indicator { background: var(--accent-green); border-color: var(--accent-green); color: white; }
        .quiz-option.wrong .quiz-indicator { background: var(--accent-red); border-color: var(--accent-red); color: white; }

        /* Pitfall Cards */
        .pitfall {
            background: linear-gradient(135deg, rgba(218, 54, 51, 0.1), rgba(218, 54, 51, 0.05));
            border: 1px solid var(--accent-red);
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1rem 0;
            position: relative;
        }

        .pitfall::before {
            content: '‚ö†Ô∏è PITFALL';
            position: absolute;
            top: -10px;
            left: 1rem;
            background: var(--accent-red);
            color: white;
            padding: 0.25rem 0.75rem;
            font-size: 0.75rem;
            font-weight: bold;
            border-radius: 4px;
        }

        .solution {
            background: linear-gradient(135deg, rgba(35, 134, 54, 0.1), rgba(35, 134, 54, 0.05));
            border: 1px solid var(--accent-green);
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1rem 0;
        }

        .solution::before {
            content: '‚úÖ SOLUTION';
            display: block;
            color: var(--accent-green);
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        /* Status Code Visualizer */
        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin: 2rem 0;
        }

        .status-card {
            background: var(--bg-dark);
            border: 1px solid var(--border);
            padding: 1rem;
            border-radius: 8px;
            border-left: 4px solid;
        }

        .status-2xx { border-left-color: var(--accent-green); }
        .status-3xx { border-left-color: var(--accent-yellow); }
        .status-4xx { border-left-color: #f0883e; }
        .status-5xx { border-left-color: var(--accent-red); }

        .status-code {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 0.5rem;
        }

        /* Exercise Validation */
        .validation-area {
            margin-top: 1rem;
            padding: 1rem;
            background: var(--bg-dark);
            border-radius: 8px;
            display: none;
        }

        .validation-area.show { display: block; }

        /* Achievement Badge */
        .badge {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue));
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
            margin: 0.5rem 0;
            box-shadow: 0 4px 12px rgba(137, 87, 229, 0.3);
        }

        .hidden { display: none !important; }

        /* Responsive */
        @media (max-width: 768px) {
            .container { grid-template-columns: 1fr; }
            .sidebar { display: none; position: fixed; z-index: 99; width: 100%; height: 100vh; }
            .network-flow { flex-direction: column; gap: 1rem; }
            .network-line { width: 4px; height: 50px; margin: 0; }
        }

        /* Animations */
        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .highlight-line {
            background: rgba(88, 166, 255, 0.3);
            display: block;
            margin: 0 -1.5rem;
            padding: 0 1.5rem;
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="logo">üåê Fetch Mastery</div>
        <div class="xp-bar">
            <span>Level <span id="level">1</span></span>
            <div class="progress-container">
                <div class="progress-fill" id="progressBar"></div>
            </div>
            <span id="xpText">0/100 XP</span>
        </div>
    </header>

    <div class="container">
        <nav class="sidebar">
            <div class="nav-item active" onclick="navigate('intro')">
                <span class="nav-icon">üöÄ</span>
                <span>Mission Brief</span>
            </div>
            <div class="nav-item" onclick="navigate('basics')">
                <span class="nav-icon">1Ô∏è‚É£</span>
                <span>Fetch Basics</span>
            </div>
            <div class="nav-item" onclick="navigate('options')">
                <span class="nav-icon">2Ô∏è‚É£</span>
                <span>Request Options</span>
            </div>
            <div class="nav-item" onclick="navigate('response')">
                <span class="nav-icon">3Ô∏è‚É£</span>
                <span>Response Handling</span>
            </div>
            <div class="nav-item" onclick="navigate('errors')">
                <span class="nav-icon">4Ô∏è‚É£</span>
                <span>Error Mastery</span>
            </div>
            <div class="nav-item" onclick="navigate('pitfalls')">
                <span class="nav-icon">‚ö†Ô∏è</span>
                <span>Common Traps</span>
            </div>
            <div class="nav-item" onclick="navigate('challenge')">
                <span class="nav-icon">üèÜ</span>
                <span>Final Challenge</span>
            </div>
        </nav>

        <main class="content">
            <!-- Section 1: Intro -->
            <section id="intro" class="section active">
                <div class="card">
                    <h1>Welcome to the HTTP Dojo ü•ã</h1>
                    <p style="font-size: 1.2rem; color: var(--text-secondary); margin-bottom: 2rem;">
                        Master the art of asynchronous communication. By the end of this mission, you'll handle API calls like a senior developer.
                    </p>
                    
                    <div class="badge">üéØ Goal: Job-Ready Fetch Skills</div>
                    <div class="badge">‚è±Ô∏è Time: 45 minutes</div>
                    <div class="badge">üéÆ Format: Interactive</div>

                    <h3>What You'll Master:</h3>
                    <ul style="margin-left: 2rem; color: var(--text-secondary);">
                        <li>Async/Await patterns that won't block the main thread</li>
                        <li>HTTP status codes and what they really mean</li>
                        <li>Error handling that distinguishes network failures from API errors</li>
                        <li>The "gotchas" that trip up even experienced devs in interviews</li>
                    </ul>

                    <button class="btn" style="margin-top: 2rem;" onclick="navigate('basics')">
                        Start Mission ‚Üí
                    </button>
                </div>
            </section>

            <!-- Section 2: Fetch Basics -->
            <section id="basics" class="section">
                <div class="card">
                    <h1>1. The Fetch Lifecycle</h1>
                    <p>Fetch returns a <strong>Promise</strong> that resolves to a Response. But here's what most tutorials don't show you: the network lifecycle.</p>

                    <div class="http-visualizer">
                        <div class="network-flow" id="networkFlow">
                            <div class="network-node client">
                                <span>üñ•Ô∏è</span>
                                <small>Client</small>
                            </div>
                            <div class="network-line">
                                <div class="packet"></div>
                            </div>
                            <div class="network-node server">
                                <span>üåê</span>
                                <small>Server</small>
                            </div>
                        </div>
                        <div style="text-align: center; margin-top: 1rem;">
                            <button class="btn btn-secondary" onclick="animateRequest()">Simulate Request</button>
                            <button class="btn" onclick="animateResponse()">Simulate Response</button>
                        </div>
                    </div>

                    <h2>The Basic Pattern</h2>
                    <div class="code-block code-good">
                        <span class="code-label">CORRECT</span>
<pre>// Modern approach using async/await
async function getUserData() {
    try {
        const response = await fetch('https://api.example.com/user');
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('Network error:', error);
    }
}</pre>
                    </div>

                    <div class="pitfall">
                        <h3>The "Floating Promise" Anti-Pattern</h3>
                        <div class="code-block code-bad">
                            <span class="code-label">WRONG</span>
<pre>// ‚ùå This is a race condition waiting to happen
function getData() {
    fetch('https://api.example.com/data')
        .then(res => res.json())
        .then(data => console.log(data));
    console.log('Data loaded'); // This runs BEFORE the fetch completes!
}</pre>
                        </div>
                        <p><strong>Why it's wrong:</strong> The function returns immediately, not waiting for the fetch. If another function depends on this data, you'll get undefined.</p>
                    </div>

                    <div class="solution">
                        <div class="code-block code-good">
<pre>// ‚úÖ Always return the promise or await it
async function getData() {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    console.log('Data loaded', data); // Now it waits!
    return data;
}</pre>
                        </div>
                    </div>

                    <h2>Quick Quiz</h2>
                    <div class="quiz-container" id="quiz1">
                        <p><strong>What does fetch() return immediately?</strong></p>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 1)">
                            <div class="quiz-indicator">A</div>
                            <div>The actual data from the API</div>
                        </div>
                        <div class="quiz-option" onclick="checkAnswer(this, true, 1)">
                            <div class="quiz-indicator">B</div>
                            <div>A Promise that will resolve to a Response object</div>
                        </div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 1)">
                            <div class="quiz-indicator">C</div>
                            <div>undefined</div>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <h2>üß™ Lab: Your First Fetch</h2>
                    <div class="playground">
                        <div class="playground-header">
                            <span>Fetch Playground</span>
                            <button class="btn btn-success" onclick="runBasicFetch()">‚ñ∂ Run Code</button>
                        </div>
                        <textarea class="editor" id="basicEditor">
// Task: Fetch a user from JSONPlaceholder
// Fix the bug in the code below

async function fetchUser() {
    const response = fetch('https://jsonplaceholder.typicode.com/users/1');
    const user = await response.json();
    console.log(user.name);
}

fetchUser();
                        </textarea>
                        <div class="console-output" id="basicConsole">
                            > Console ready...
                        </div>
                    </div>
                    <div class="validation-area" id="basicValidation">
                        <p id="basicFeedback"></p>
                    </div>
                </div>
            </section>

            <!-- Section 3: Request Options -->
            <section id="options" class="section">
                <div class="card">
                    <h1>2. Request Configuration</h1>
                    <p>HTTP methods tell the server what you want to do. GET reads, POST creates, PUT updates, DELETE removes.</p>

                    <div class="status-grid">
                        <div class="status-card">
                            <div class="status-code" style="color: var(--accent-blue);">GET</div>
                            <div>Retrieve data</div>
                            <small style="color: var(--text-secondary);">Idempotent & Safe</small>
                        </div>
                        <div class="status-card">
                            <div class="status-code" style="color: var(--accent-green);">POST</div>
                            <div>Create resource</div>
                            <small style="color: var(--text-secondary);">Not idempotent</small>
                        </div>
                        <div class="status-card">
                            <div class="status-code" style="color: var(--accent-yellow);">PUT</div>
                            <div>Update/Replace</div>
                            <small style="color: var(--text-secondary);">Idempotent</small>
                        </div>
                        <div class="status-card">
                            <div class="status-code" style="color: var(--accent-red);">DELETE</div>
                            <div>Remove resource</div>
                            <small style="color: var(--text-secondary);">Idempotent</small>
                        </div>
                    </div>

                    <h2>The Request Object Anatomy</h2>
                    <div class="code-block">
                        <span class="code-label">JAVASCRIPT</span>
<pre>const options = {
    method: 'POST',           // HTTP verb
    headers: {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer token123'
    },
    body: JSON.stringify({    // Data sent to server
        title: 'New Post',
        body: 'Hello World'
    }),
    mode: 'cors',             // CORS mode
    cache: 'no-cache',        // Cache behavior
    credentials: 'same-origin' // Cookie handling
};

const response = await fetch(url, options);</pre>
                    </div>

                    <div class="pitfall">
                        <h3>The "Double JSON" Mistake</h3>
                        <div class="code-block code-bad">
<pre>// ‚ùå Sending object directly (common beginner error)
fetch('/api/data', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: { name: 'John' }  // <-- Wrong! Must be stringified
});</pre>
                        </div>
                        <div class="solution">
                            <div class="code-block code-good">
<pre>// ‚úÖ Always stringify objects, and handle the Content-Type header
fetch('/api/data', {
    method: 'POST',
    headers: { 
        'Content-Type': 'application/json'  // Tells server we're sending JSON
    },
    body: JSON.stringify({ name: 'John' })  // Convert to string
});</pre>
                            </div>
                        </div>
                    </div>

                    <h2>Headers Deep Dive</h2>
                    <p>Headers are case-insensitive but conventionally Title-Case. The <code>Content-Type</code> header is crucial:</p>
                    
                    <div class="code-block">
<pre>// Common Content-Types:
'application/json'        // JSON data
'application/x-www-form-urlencoded'  // Form data (key=value&key2=value2)
'multipart/form-data'     // File uploads with boundaries
'text/plain'              // Raw text
'application/xml'         // XML (legacy APIs)</pre>
                    </div>
                </div>

                <div class="card">
                    <h2>üß™ Lab: POST Request Builder</h2>
                    <div class="playground">
                        <div class="playground-header">
                            <span>Create a New Post</span>
                            <button class="btn btn-success" onclick="runPostLab()">‚ñ∂ Send Request</button>
                        </div>
                        <textarea class="editor" id="postEditor">
// Task: Create a new post using JSONPlaceholder
// The endpoint accepts: { title: string, body: string, userId: number }

async function createPost() {
    const postData = {
        title: 'My First Post',
        body: 'Learning Fetch API is fun!',
        userId: 1
    };
    
    // TODO: Complete the fetch call with proper options
    const response = await fetch('https://jsonplaceholder.typicode.com/posts', {
        method: // Fill this in
        headers: // What header do we need?
        body: // How do we send the data?
    });
    
    const result = await response.json();
    console.log('Created:', result);
    return result.id; // Should return the new post ID (201)
}

createPost();
                        </textarea>
                        <div class="console-output" id="postConsole"></div>
                    </div>
                    <button class="btn btn-secondary" onclick="showHint('post')">üí° Need a Hint?</button>
                    <div id="postHint" class="hidden" style="margin-top: 1rem; padding: 1rem; background: rgba(88, 166, 255, 0.1); border-radius: 8px;">
                        Remember: method is 'POST', headers need 'Content-Type': 'application/json', and body needs JSON.stringify()
                    </div>
                </div>
            </section>

            <!-- Section 4: Response Handling -->
            <section id="response" class="section">
                <div class="card">
                    <h1>3. Response Mastery</h1>
                    <p>The Response object is a stream that can only be read once. This is the #1 source of "body already consumed" errors.</p>

                    <div class="http-visualizer">
                        <h3 style="margin-bottom: 1rem;">HTTP Status Codes Visualized</h3>
                        <div class="status-grid">
                            <div class="status-card status-2xx">
                                <div class="status-code">200 OK</div>
                                <div>Success</div>
                            </div>
                            <div class="status-card status-2xx">
                                <div class="status-code">201 Created</div>
                                <div>Resource made</div>
                            </div>
                            <div class="status-card status-4xx">
                                <div class="status-code">400 Bad Request</div>
                                <div>Client error</div>
                            </div>
                            <div class="status-card status-4xx">
                                <div class="status-code">401 Unauthorized</div>
                                <div>Need auth</div>
                            </div>
                            <div class="status-card status-4xx">
                                <div class="status-code">404 Not Found</div>
                                <div>Missing resource</div>
                            </div>
                            <div class="status-card status-5xx">
                                <div class="status-code">500 Server Error</div>
                                <div>Server crashed</div>
                            </div>
                        </div>
                    </div>

                    <h2>The Stream Problem (Critical!)</h2>
                    <div class="pitfall">
                        <h3>Reading the Body Twice</h3>
                        <div class="code-block code-bad">
<pre>// ‚ùå This throws "Failed to execute 'json' on 'Response': body stream already read"
const response = await fetch('/api/data');
const jsonData = await response.json();
const textData = await response.text();  // Error! Stream consumed!</pre>
                        </div>
                        <p><strong>Why:</strong> Response.body is a ReadableStream. Once you read it (via .json(), .text(), etc.), it's gone.</p>
                    </div>

                    <div class="solution">
                        <div class="code-block code-good">
<pre>// ‚úÖ Clone the response if you need multiple formats
const response = await fetch('/api/data');
const responseClone = response.clone();

const jsonData = await response.json();
const textData = await responseClone.text();  // Works!</pre>
                        </div>
                    </div>

                    <h2>Response Properties</h2>
                    <div class="code-block">
<pre>const response = await fetch(url);

// Boolean checks
response.ok;        // true if status 200-299
response.status;    // HTTP status code (200, 404, etc.)
response.statusText; // "OK", "Not Found", etc.

// Headers
response.headers.get('Content-Type');
response.headers.forEach((value, key) => console.log(key, value));

// Reading body (choose ONE):
await response.json();   // Parse as JSON
await response.text();   // Get as plain text
await response.blob();   // Get as binary (images/files)
await response.formData(); // Parse as FormData</pre>
                    </div>

                    <div class="quiz-container" id="quiz2">
                        <p><strong>fetch() resolves even with 404 or 500 status codes. True or False?</strong></p>
                        <div class="quiz-option" onclick="checkAnswer(this, true, 2)">
                            <div class="quiz-indicator">A</div>
                            <div>True - fetch only rejects on network failure, not HTTP errors</div>
                        </div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 2)">
                            <div class="quiz-indicator">B</div>
                            <div>False - fetch rejects on any non-2xx status</div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Section 5: Error Handling -->
            <section id="errors" class="section">
                <div class="card">
                    <h1>4. Error Handling Like a Pro</h1>
                    <p>There are two types of errors in Fetch: <strong>Network Errors</strong> (promise rejects) and <strong>HTTP Errors</strong> (promise resolves with bad status).</p>

                    <h2>The Two-Layer Defense</h2>
                    <div class="code-block code-good">
                        <span class="code-label">PRODUCTION-READY PATTERN</span>
<pre>async function robustFetch(url, options = {}) {
    try {
        const response = await fetch(url, options);
        
        // Layer 1: Check HTTP status
        if (!response.ok) {
            // Handle specific status codes
            if (response.status === 404) {
                throw new Error('Resource not found');
            } else if (response.status === 401) {
                throw new Error('Unauthorized - please login');
            } else if (response.status >= 500) {
                throw new Error('Server error - try again later');
            } else {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
        }
        
        // Layer 2: Parse response
        const data = await response.json();
        return data;
        
    } catch (error) {
        // Layer 3: Network or parsing errors
        if (error.name === 'TypeError' && error.message.includes('fetch')) {
            console.error('Network failure - check connection');
        } else if (error instanceof SyntaxError) {
            console.error('Invalid JSON response');
        }
        
        throw error; // Re-throw for caller to handle
    }
}</pre>
                    </div>

                    <h2>Timeout Implementation</h2>
                    <p>Fetch has no built-in timeout. You must implement it with AbortController:</p>
                    
                    <div class="code-block">
<pre>async function fetchWithTimeout(url, options = {}, timeout = 5000) {
    const controller = new AbortController();
    const id = setTimeout(() => controller.abort(), timeout);
    
    try {
        const response = await fetch(url, {
            ...options,
            signal: controller.signal
        });
        clearTimeout(id);
        return response;
    } catch (error) {
        clearTimeout(id);
        if (error.name === 'AbortError') {
            throw new Error('Request timeout');
        }
        throw error;
    }
}</pre>
                    </div>

                    <div class="pitfall">
                        <h3>The "Silent Failure"</h3>
                        <div class="code-block code-bad">
<pre>// ‚ùå Bad: Only catching, not checking status
try {
    const res = await fetch('/api/data');
    const data = await res.json(); // Might parse error HTML as JSON!
    return data;
} catch (e) {
    console.log('Error:', e);
}</pre>
                        </div>
                        <p><strong>Interview Question:</strong> "Why doesn't fetch throw on 404?"<br>
                        <strong>Answer:</strong> Because 404 is a valid HTTP response. The server responded successfully (network worked), it just said "I don't have that."</p>
                    </div>
                </div>

                <div class="card">
                    <h2>üß™ Lab: Error Handler</h2>
                    <p>Complete the function to handle all error cases properly:</p>
                    <div class="playground">
                        <div class="playground-header">
                            <span>Error Handling Challenge</span>
                            <button class="btn btn-success" onclick="runErrorLab()">‚ñ∂ Test Scenarios</button>
                        </div>
                        <textarea class="editor" id="errorEditor">
async function safeFetch(url) {
    try {
        const response = await fetch(url);
        
        // TODO: Check if response is OK (status 200-299)
        // If not OK, throw an error with the status
        
        return await response.json();
    } catch (error) {
        // TODO: Return object with error info instead of crashing
        return { error: true, message: error.message };
    }
}

// Test cases (uncomment to test):
// safeFetch('https://jsonplaceholder.typicode.com/posts/1'); // Should work
// safeFetch('https://jsonplaceholder.typicode.com/posts/999999'); // 404
// safeFetch('https://invalid-domain-that-doesnt-exist.com'); // Network error
                        </textarea>
                        <div class="console-output" id="errorConsole"></div>
                    </div>
                </div>
            </section>

            <!-- Section 6: Pitfalls -->
            <section id="pitfalls" class="section">
                <div class="card">
                    <h1>‚ö†Ô∏è The Hall of Mistakes</h1>
                    <p>These are the mistakes that cost developers hours in debugging and sometimes jobs in interviews.</p>

                    <div class="pitfall">
                        <h3>Mistake #1: The Undefined Race</h3>
                        <div class="code-block code-bad">
<pre>function getUser() {
    let user;
    fetch('/api/user')
        .then(res => res.json())
        .then(data => {
            user = data; // This happens LATER
        });
    return user; // Returns undefined immediately!
}</pre>
                        </div>
                        <div class="solution">
                            <p>Remember: fetch is asynchronous. The function returns before the network round-trip completes.</p>
                        </div>
                    </div>

                    <div class="pitfall">
                        <h3>Mistake #2: CORS Confusion</h3>
                        <p>You write perfect code. It works in Postman. It fails in browser. Why?</p>
                        <div class="code-block code-warning">
<pre>// Browser blocks this due to CORS policy, even with correct code
fetch('https://api.some-third-party.com/data')
    .then(res => res.json()); // CORS Error!</pre>
                        </div>
                        <p><strong>Key Insight:</strong> CORS is a browser security feature. Postman doesn't have CORS restrictions. The server must include <code>Access-Control-Allow-Origin</code> headers.</p>
                    </div>

                    <div class="pitfall">
                        <h3>Mistake #3: Forgetting Content-Type</h3>
                        <p>When sending JSON, if you forget the header, the server receives [object Object] or parses it as plain text.</p>
                    </div>

                    <div class="pitfall">
                        <h3>Mistake #4: Not Handling Non-JSON Responses</h3>
                        <div class="code-block code-bad">
<pre>// If server returns 500 HTML error page:
const data = await response.json(); // SyntaxError: Unexpected token <</pre>
                        </div>
                        <p>Always check Content-Type before parsing:</p>
                        <div class="code-block code-good">
<pre>const contentType = response.headers.get('content-type');
if (contentType && contentType.includes('application/json')) {
    return await response.json();
} else {
    return await response.text();
}</pre>
                        </div>
                    </div>

                    <h2>üß™ Quick Challenge</h2>
                    <p>Which of these is the most robust fetch wrapper?</p>
                    <div class="quiz-container" id="quiz3">
                        <div class="quiz-option" onclick="checkAnswer(this, false, 3)">
                            <div class="quiz-indicator">A</div>
                            <div>One that catches errors but ignores HTTP status codes</div>
                        </div>
                        <div class="quiz-option" onclick="checkAnswer(this, true, 3)">
                            <div class="quiz-indicator">B</div>
                            <div>One that checks response.ok, handles JSON parsing errors, and distinguishes network from HTTP errors</div>
                        </div>
                        <div class="quiz-option" onclick="checkAnswer(this, false, 3)">
                            <div class="quiz-indicator">C</div>
                            <div>One that uses .then() chaining without catch blocks</div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Section 7: Final Challenge -->
            <section id="challenge" class="section">
                <div class="card">
                    <h1>üèÜ Final Boss: Build a Robust API Client</h1>
                    <p>Create a reusable fetch wrapper that handles authentication, retries, and caching. This is interview-level code.</p>

                    <h2>Requirements:</h2>
                    <ul style="margin: 1rem 0 1rem 2rem; color: var(--text-secondary);">
                        <li>Automatic retry on network failure (3 attempts)</li>
                        <li>Request/Response interceptors</li>
                        <li>Automatic JSON parsing with fallback</li>
                        <li>Authorization header injection</li>
                        <li>Request deduplication (don't fire identical simultaneous requests)</li>
                    </ul>

                    <div class="playground">
                        <div class="playground-header">
                            <span>API Client Implementation</span>
                            <div>
                                <button class="btn btn-secondary" onclick="runTests()">üß™ Run Tests</button>
                                <button class="btn btn-success" onclick="checkSolution()">‚úÖ Check Solution</button>
                            </div>
                        </div>
                        <textarea class="editor" id="finalEditor" style="min-height: 400px;">
class ApiClient {
    constructor(baseURL) {
        this.baseURL = baseURL;
        this.pendingRequests = new Map();
    }
    
    async request(endpoint, options = {}) {
        // TODO: Implement retry logic
        // TODO: Handle request deduplication (use this.pendingRequests)
        // TODO: Add auth headers if token exists
        // TODO: Parse JSON safely
        
        const url = this.baseURL + endpoint;
        
        // Your implementation here:
        
        
    }
    
    // Bonus: Implement get(), post(), put(), delete() convenience methods
}

// Test your client:
const client = new ApiClient('https://jsonplaceholder.typicode.com');

// Should work:
client.request('/posts/1')
    .then(data => console.log('Success:', data))
    .catch(err => console.error('Failed:', err));
                        </textarea>
                        <div class="console-output" id="finalConsole"></div>
                    </div>

                    <div id="successMessage" class="hidden" style="margin-top: 2rem; text-align: center;">
                        <div style="font-size: 4rem; margin-bottom: 1rem;">üéâ</div>
                        <h2>Mission Complete!</h2>
                        <p>You've mastered the Fetch API. You're ready for production code and technical interviews.</p>
                        <div style="margin-top: 1rem;">
                            <span class="badge">üèÜ Fetch Master</span>
                            <span class="badge">üõ°Ô∏è Error Handler</span>
                            <span class="badge">‚ö° Async Expert</span>
                        </div>
                    </div>
                </div>
            </section>
        </main>
    </div>

    <script>
        // State Management
        let xp = 0;
        let level = 1;
        const maxXP = 100;
        
        function updateXP(points) {
            xp += points;
            if (xp >= maxXP) {
                level++;
                xp = xp - maxXP;
                alert(`üéâ Level Up! You're now level ${level}`);
            }
            document.getElementById('xpText').textContent = `${xp}/${maxXP} XP`;
            document.getElementById('level').textContent = level;
            document.getElementById('progressBar').style.width = `${(xp/maxXP)*100}%`;
        }

        // Navigation
        function navigate(sectionId) {
            document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
            document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
            
            document.getElementById(sectionId).classList.add('active');
            event.target.closest('.nav-item').classList.add('active');
        }

        // Visual Animations
        function animateRequest() {
            const flow = document.getElementById('networkFlow');
            flow.classList.remove('receiving');
            flow.classList.add('sending');
            setTimeout(() => flow.classList.remove('sending'), 1500);
        }

        function animateResponse() {
            const flow = document.getElementById('networkFlow');
            flow.classList.remove('sending');
            flow.classList.add('receiving');
            setTimeout(() => flow.classList.remove('receiving'), 1500);
        }

        // Quiz System
        function checkAnswer(element, isCorrect, quizId) {
            const options = element.parentElement.querySelectorAll('.quiz-option');
            options.forEach(opt => {
                opt.onclick = null;
                opt.style.cursor = 'default';
            });
            
            if (isCorrect) {
                element.classList.add('correct');
                element.querySelector('.quiz-indicator').innerHTML = '‚úì';
                updateXP(20);
                logToConsole('quiz', '‚úÖ Correct! +20 XP');
            } else {
                element.classList.add('wrong');
                element.querySelector('.quiz-indicator').innerHTML = '‚úó';
                // Highlight correct answer
                options.forEach(opt => {
                    if (opt.onclick.toString().includes('true')) {
                        opt.classList.add('correct');
                    }
                });
                logToConsole('quiz', '‚ùå Incorrect. Study the concept and try again!');
            }
        }

        // Console Logger
        function logToConsole(targetId, message, type = 'info') {
            const console = document.getElementById(targetId + 'Console') || document.getElementById('basicConsole');
            const line = document.createElement('div');
            line.className = `console-line console-${type}`;
            line.textContent = `> ${message}`;
            console.appendChild(line);
            console.scrollTop = console.scrollHeight;
        }

        function clearConsole(targetId) {
            const console = document.getElementById(targetId + 'Console');
            if (console) console.innerHTML = '> Console ready...';
        }

        // Code Execution Sandbox
        function runBasicFetch() {
            clearConsole('basic');
            const code = document.getElementById('basicEditor').value;
            
            // Check for common mistakes
            if (!code.includes('await fetch')) {
                logToConsole('basic', '‚ùå Hint: You need to await the fetch call!', 'error');
                return;
            }
            
            try {
                // Safe evaluation
                const fn = new Function('console', `
                    const logs = [];
                    const mockConsole = {
                        log: (...args) => {
                            logs.push(args.join(' '));
                            document.getElementById('basicConsole').innerHTML += '> ' + args.join(' ') + '\\n';
                        },
                        error: (...args) => {
                            logs.push('ERROR: ' + args.join(' '));
                            document.getElementById('basicConsole').innerHTML += '> ERROR: ' + args.join(' ') + '\\n';
                        }
                    };
                    ${code.replace(/console/g, 'mockConsole')};
                    return logs;
                `);
                
                fn();
                
                // If they fixed it properly, fetch should work
                if (code.includes('await fetch') && code.includes('await response.json')) {
                    setTimeout(() => {
                        logToConsole('basic', '‚úÖ Syntax looks good! In a real browser, this would fetch data.', 'success');
                        updateXP(30);
                    }, 500);
                }
            } catch (err) {
                logToConsole('basic', 'Error: ' + err.message, 'error');
            }
        }

        function runPostLab() {
            clearConsole('post');
            const code = document.getElementById('postEditor').value;
            
            const checks = [
                { test: /method:\s*['"]POST['"]/, msg: 'POST method specified ‚úì' },
                { test: /headers:\s*\{[^}]*['"]Content-Type['"]\s*:\s*['"]application\/json['"]/, msg: 'Content-Type header set ‚úì' },
                { test: /JSON\.stringify/, msg: 'Body stringified ‚úì' }
            ];
            
            let passed = 0;
            checks.forEach(check => {
                if (check.test.test(code)) {
                    passed++;
                    logToConsole('post', check.msg, 'success');
                }
            });
            
            if (passed === 3) {
                logToConsole('post', 'üéâ Perfect! You understand POST requests.', 'success');
                updateXP(40);
            } else {
                logToConsole('post', `‚ö†Ô∏è ${3-passed} items missing. Check the hint if needed.`, 'error');
            }
        }

        function runErrorLab() {
            clearConsole('error');
            const code = document.getElementById('errorEditor').value;
            
            if (code.includes('response.ok') && code.includes('throw')) {
                logToConsole('error', '‚úì Checking response.ok detected', 'success');
                updateXP(30);
            } else {
                logToConsole('error', 'Hint: Check response.ok before parsing', 'error');
            }
        }

        function showHint(type) {
            document.getElementById(type + 'Hint').classList.remove('hidden');
        }

        function runTests() {
            clearConsole('final');
            logToConsole('final', 'Running test suite...', 'info');
            
            setTimeout(() => {
                logToConsole('final', 'Test 1: GET request... pending', 'info');
                setTimeout(() => logToConsole('final', 'Test 1: ‚úì Passed', 'success'), 500);
                
                logToConsole('final', 'Test 2: Error handling... pending', 'info');
                setTimeout(() => logToConsole('final', 'Test 2: ‚úì Passed', 'success'), 800);
                
                logToConsole('final', 'Test 3: Retry logic... pending', 'info');
                setTimeout(() => logToConsole('final', 'Test 3: ‚ö†Ô∏è Needs implementation', 'error'), 1100);
            }, 500);
        }

        function checkSolution() {
            document.getElementById('successMessage').classList.remove('hidden');
            updateXP(50);
            window.scrollTo(0, document.body.scrollHeight);
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            logToConsole('basic', 'Welcome to Fetch Mastery!');
        });
    </script>
</body>
</html>