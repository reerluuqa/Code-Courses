<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>‚ö° JavaScript Promises Mastery</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
:root{
  --bg:#0b0e17;--bg2:#121829;--bg3:#1a2035;--bg4:#232b45;
  --text:#e2e8f0;--text2:#94a3b8;--text3:#64748b;
  --blue:#3b82f6;--blue2:#60a5fa;--blue-glow:rgba(59,130,246,.25);
  --green:#22c55e;--green2:#4ade80;--green-bg:rgba(34,197,94,.12);
  --red:#ef4444;--red2:#f87171;--red-bg:rgba(239,68,68,.12);
  --yellow:#eab308;--yellow2:#facc15;--yellow-bg:rgba(234,179,8,.12);
  --purple:#a855f7;--purple2:#c084fc;--purple-bg:rgba(168,85,247,.12);
  --orange:#f97316;--cyan:#06b6d4;
  --radius:12px;--radius-sm:8px;
}
body{font-family:'Segoe UI',system-ui,-apple-system,sans-serif;background:var(--bg);color:var(--text);line-height:1.7;min-height:100vh}
h1,h2,h3,h4{line-height:1.3;font-weight:700}
a{color:var(--blue2)}

/* === HEADER === */
.app-header{background:linear-gradient(135deg,var(--bg2),var(--bg3));border-bottom:1px solid rgba(255,255,255,.06);padding:20px 30px;display:flex;align-items:center;justify-content:space-between;flex-wrap:wrap;gap:15px;position:sticky;top:0;z-index:100;backdrop-filter:blur(20px)}
.app-header h1{font-size:1.6rem;background:linear-gradient(135deg,var(--blue2),var(--purple2));-webkit-background-clip:text;-webkit-text-fill-color:transparent;display:flex;align-items:center;gap:10px}
.app-header h1 span{font-size:1.8rem;-webkit-text-fill-color:initial}
.progress-wrap{display:flex;align-items:center;gap:12px;font-size:.85rem;color:var(--text2)}
.progress-bar{width:200px;height:8px;background:var(--bg4);border-radius:10px;overflow:hidden}
.progress-fill{height:100%;background:linear-gradient(90deg,var(--blue),var(--purple));border-radius:10px;transition:width .5s ease;width:0%}
.score-badge{background:var(--bg4);padding:6px 14px;border-radius:20px;font-weight:600;font-size:.85rem;color:var(--yellow2)}

/* === NAV === */
.tab-nav{display:flex;background:var(--bg2);border-bottom:1px solid rgba(255,255,255,.06);overflow-x:auto;scrollbar-width:none}
.tab-nav::-webkit-scrollbar{display:none}
.tab-btn{padding:14px 24px;background:none;border:none;color:var(--text3);font-size:.9rem;font-weight:600;cursor:pointer;white-space:nowrap;border-bottom:3px solid transparent;transition:all .3s;position:relative}
.tab-btn:hover{color:var(--text2);background:rgba(255,255,255,.03)}
.tab-btn.active{color:var(--blue2);border-bottom-color:var(--blue)}
.tab-btn .num{display:inline-flex;width:22px;height:22px;align-items:center;justify-content:center;border-radius:50%;background:var(--bg4);font-size:.75rem;margin-right:6px}
.tab-btn.active .num{background:var(--blue);color:white}
.tab-btn.completed .num{background:var(--green);color:white}

/* === MAIN === */
main{max-width:960px;margin:0 auto;padding:30px 20px 80px}
.tab-content{display:none;animation:fadeIn .4s ease}
.tab-content.active{display:block}
@keyframes fadeIn{from{opacity:0;transform:translateY(12px)}to{opacity:1;transform:translateY(0)}}

/* === CARDS === */
.card{background:var(--bg2);border:1px solid rgba(255,255,255,.06);border-radius:var(--radius);padding:28px;margin-bottom:24px}
.card h2{font-size:1.4rem;margin-bottom:16px;display:flex;align-items:center;gap:10px}
.card h3{font-size:1.1rem;margin:20px 0 10px;color:var(--blue2)}
.card p{color:var(--text2);margin-bottom:12px}

/* === CONCEPT BOXES === */
.concept-box{border-radius:var(--radius-sm);padding:20px;margin:16px 0}
.concept-box.info{background:rgba(59,130,246,.08);border-left:4px solid var(--blue)}
.concept-box.success{background:var(--green-bg);border-left:4px solid var(--green)}
.concept-box.warning{background:var(--yellow-bg);border-left:4px solid var(--yellow)}
.concept-box.danger{background:var(--red-bg);border-left:4px solid var(--red)}
.concept-box.purple{background:var(--purple-bg);border-left:4px solid var(--purple)}
.concept-box h4{margin-bottom:8px;display:flex;align-items:center;gap:8px}
.concept-box p{color:var(--text2);margin-bottom:6px;font-size:.92rem}

/* === CODE BLOCKS === */
.code-wrapper{position:relative;margin:16px 0;border-radius:var(--radius-sm);overflow:hidden;border:1px solid rgba(255,255,255,.08)}
.code-header{display:flex;justify-content:space-between;align-items:center;background:rgba(0,0,0,.3);padding:8px 16px;font-size:.8rem;color:var(--text3)}
.code-label{display:flex;align-items:center;gap:6px}
.code-dots{display:flex;gap:6px}
.code-dots span{width:10px;height:10px;border-radius:50%}
.code-dots span:nth-child(1){background:#ef4444}
.code-dots span:nth-child(2){background:#eab308}
.code-dots span:nth-child(3){background:#22c55e}
pre{margin:0;padding:18px;background:rgba(0,0,0,.25);overflow-x:auto;font-size:.88rem;line-height:1.65;font-family:'Fira Code','Cascadia Code','Consolas',monospace;tab-size:2}
pre code{color:#e2e8f0}
.kw{color:#c084fc}.fn{color:#60a5fa}.str{color:#4ade80}.cm{color:#64748b;font-style:italic}.num{color:#facc15}.op{color:#f87171}.key{color:#f97316}.bool{color:#f87171}

.run-btn{padding:6px 16px;background:var(--blue);color:white;border:none;border-radius:6px;cursor:pointer;font-size:.8rem;font-weight:600;transition:all .2s;display:flex;align-items:center;gap:5px}
.run-btn:hover{background:var(--blue2);transform:scale(1.05)}
.run-btn:active{transform:scale(.95)}
.output-area{background:rgba(0,0,0,.4);border-top:1px solid rgba(255,255,255,.06);padding:14px 18px;min-height:42px;font-family:'Fira Code',monospace;font-size:.85rem}
.output-area:empty::before{content:'‚ñ∂ Click Run to see output';color:var(--text3);font-style:italic}
.output-area .log{color:var(--green2);padding:2px 0}
.output-area .log::before{content:'‚Ä∫ ';color:var(--text3)}
.output-area .err{color:var(--red2);padding:2px 0}
.output-area .err::before{content:'‚úó ';color:var(--red)}
.output-area .info-log{color:var(--blue2);padding:2px 0}
.output-area .info-log::before{content:'‚Ñπ ';color:var(--blue)}
.output-area .warn-log{color:var(--yellow2);padding:2px 0}
.output-area .warn-log::before{content:'‚ö† '}
.output-area .separator{border-top:1px dashed rgba(255,255,255,.1);margin:6px 0}

/* === INTERACTIVE VISUALIZATIONS === */
.viz-container{background:var(--bg3);border-radius:var(--radius-sm);padding:24px;margin:20px 0;border:1px solid rgba(255,255,255,.06);overflow:hidden}

/* Promise States */
.states-viz{display:flex;align-items:center;justify-content:center;gap:10px;flex-wrap:wrap;padding:20px 0}
.state-node{display:flex;flex-direction:column;align-items:center;gap:8px}
.state-circle{width:90px;height:90px;border-radius:50%;display:flex;align-items:center;justify-content:center;font-size:2rem;transition:all .5s ease;position:relative}
.state-circle.pending{background:var(--yellow-bg);border:3px solid var(--yellow);color:var(--yellow)}
.state-circle.fulfilled{background:var(--green-bg);border:3px solid var(--green);color:var(--green)}
.state-circle.rejected{background:var(--red-bg);border:3px solid var(--red);color:var(--red)}
.state-circle.active{animation:pulse 1.5s infinite;box-shadow:0 0 25px currentColor}
@keyframes pulse{0%,100%{transform:scale(1);opacity:1}50%{transform:scale(1.08);opacity:.85}}
.state-label{font-weight:700;font-size:.85rem;text-transform:uppercase;letter-spacing:1px}
.state-arrow{font-size:1.5rem;color:var(--text3);flex-shrink:0}
.state-controls{display:flex;gap:10px;justify-content:center;margin-top:16px;flex-wrap:wrap}
.state-controls button{padding:10px 20px;border:none;border-radius:8px;font-weight:600;cursor:pointer;font-size:.9rem;transition:all .2s}
.btn-resolve{background:var(--green);color:white}
.btn-resolve:hover{background:var(--green2);transform:translateY(-2px)}
.btn-reject{background:var(--red);color:white}
.btn-reject:hover{background:var(--red2);transform:translateY(-2px)}
.btn-reset{background:var(--bg4);color:var(--text2)}
.btn-reset:hover{background:var(--text3);color:white}

/* Chain Visualization */
.chain-viz{display:flex;align-items:center;gap:0;overflow-x:auto;padding:20px 10px;justify-content:center;flex-wrap:wrap}
.chain-step{display:flex;flex-direction:column;align-items:center;gap:6px;transition:all .4s}
.chain-box{width:120px;padding:14px 10px;background:var(--bg4);border:2px solid rgba(255,255,255,.1);border-radius:var(--radius-sm);text-align:center;font-size:.82rem;font-weight:600;transition:all .4s;position:relative}
.chain-box.active{border-color:var(--blue);background:rgba(59,130,246,.15);box-shadow:0 0 20px var(--blue-glow)}
.chain-box.done{border-color:var(--green);background:var(--green-bg)}
.chain-box.error{border-color:var(--red);background:var(--red-bg)}
.chain-value{font-size:.75rem;color:var(--text3);font-family:monospace;min-height:18px;transition:all .3s}
.chain-value.show{color:var(--green2)}
.chain-arrow{font-size:1.2rem;color:var(--text3);margin:0 4px;flex-shrink:0}

/* Multi-Promise Viz */
.multi-viz{display:flex;flex-direction:column;gap:12px;padding:10px 0}
.promise-lane{display:flex;align-items:center;gap:12px}
.lane-label{width:90px;font-size:.82rem;font-weight:600;color:var(--text2);flex-shrink:0}
.lane-track{flex:1;height:32px;background:var(--bg4);border-radius:6px;overflow:hidden;position:relative}
.lane-fill{height:100%;border-radius:6px;transition:width .1s linear;display:flex;align-items:center;justify-content:flex-end;padding-right:10px;font-size:.75rem;font-weight:700;color:white}
.lane-fill.p1{background:linear-gradient(90deg,var(--blue),var(--cyan))}
.lane-fill.p2{background:linear-gradient(90deg,var(--purple),var(--purple2))}
.lane-fill.p3{background:linear-gradient(90deg,var(--orange),var(--yellow))}
.lane-fill.error-fill{background:linear-gradient(90deg,var(--red),var(--red2))}
.lane-status{width:28px;font-size:1.1rem;text-align:center;flex-shrink:0}
.multi-result{margin-top:12px;padding:12px 16px;background:var(--bg4);border-radius:8px;font-family:monospace;font-size:.85rem;min-height:40px}

/* === QUIZ === */
.quiz-section{margin-top:30px}
.quiz-section h3{color:var(--purple2);font-size:1.15rem;margin-bottom:16px;display:flex;align-items:center;gap:8px}
.quiz-q{background:var(--bg3);border:1px solid rgba(255,255,255,.06);border-radius:var(--radius-sm);padding:20px;margin-bottom:16px;transition:all .3s}
.quiz-q.answered-correct{border-color:var(--green);background:var(--green-bg)}
.quiz-q.answered-wrong{border-color:var(--red)}
.quiz-q p{font-weight:600;margin-bottom:12px;color:var(--text)}
.quiz-q .q-code{background:rgba(0,0,0,.3);padding:12px 16px;border-radius:6px;margin-bottom:14px;font-family:monospace;font-size:.85rem;overflow-x:auto;white-space:pre}
.quiz-opts{display:flex;flex-direction:column;gap:8px}
.quiz-opt{display:flex;align-items:center;gap:10px;padding:10px 14px;background:var(--bg4);border:2px solid transparent;border-radius:8px;cursor:pointer;transition:all .2s;font-size:.9rem}
.quiz-opt:hover:not(.disabled){background:rgba(59,130,246,.1);border-color:var(--blue)}
.quiz-opt.selected{border-color:var(--blue);background:rgba(59,130,246,.12)}
.quiz-opt.correct{border-color:var(--green)!important;background:var(--green-bg)!important}
.quiz-opt.wrong{border-color:var(--red)!important;background:var(--red-bg)!important}
.quiz-opt.disabled{cursor:default;opacity:.7}
.quiz-opt input{display:none}
.quiz-opt .radio{width:20px;height:20px;border:2px solid var(--text3);border-radius:50%;display:flex;align-items:center;justify-content:center;flex-shrink:0;transition:all .2s}
.quiz-opt.selected .radio{border-color:var(--blue);background:var(--blue)}
.quiz-opt.correct .radio{border-color:var(--green);background:var(--green)}
.quiz-opt.wrong .radio{border-color:var(--red);background:var(--red)}
.quiz-opt .radio::after{content:'';width:8px;height:8px;background:white;border-radius:50%;opacity:0;transition:opacity .2s}
.quiz-opt.selected .radio::after,.quiz-opt.correct .radio::after,.quiz-opt.wrong .radio::after{opacity:1}
.quiz-explain{margin-top:12px;padding:12px;border-radius:6px;font-size:.88rem;display:none}
.quiz-explain.show{display:block}
.quiz-explain.correct{background:var(--green-bg);color:var(--green2)}
.quiz-explain.wrong{background:var(--red-bg);color:var(--red2)}
.quiz-check-btn{margin-top:12px;padding:10px 24px;background:var(--purple);color:white;border:none;border-radius:8px;font-weight:600;cursor:pointer;transition:all .2s;font-size:.9rem}
.quiz-check-btn:hover{background:var(--purple2);transform:translateY(-2px)}
.quiz-check-btn:disabled{opacity:.5;cursor:default;transform:none}

/* === EXERCISES === */
.exercise{background:var(--bg3);border:1px solid rgba(255,255,255,.08);border-radius:var(--radius);padding:24px;margin-bottom:24px}
.exercise h4{color:var(--cyan);margin-bottom:8px;display:flex;align-items:center;gap:8px}
.exercise p{color:var(--text2);margin-bottom:14px;font-size:.92rem}
.exercise textarea{width:100%;min-height:140px;background:rgba(0,0,0,.3);border:1px solid rgba(255,255,255,.1);border-radius:8px;padding:14px;color:var(--text);font-family:'Fira Code','Consolas',monospace;font-size:.88rem;resize:vertical;line-height:1.6;tab-size:2}
.exercise textarea:focus{outline:none;border-color:var(--blue)}
.exercise-btns{display:flex;gap:10px;margin-top:10px;flex-wrap:wrap}
.exercise-btns button{padding:8px 20px;border:none;border-radius:6px;font-weight:600;cursor:pointer;font-size:.85rem;transition:all .2s}
.btn-run-exercise{background:var(--blue);color:white}
.btn-run-exercise:hover{background:var(--blue2)}
.btn-solution{background:var(--bg4);color:var(--text2)}
.btn-solution:hover{background:var(--text3);color:white}
.exercise-output{margin-top:12px;background:rgba(0,0,0,.3);border-radius:8px;padding:14px;font-family:monospace;font-size:.85rem;min-height:40px}
.exercise-result{margin-top:10px;padding:10px 14px;border-radius:6px;font-weight:600;display:none}
.exercise-result.pass{display:block;background:var(--green-bg);color:var(--green2)}
.exercise-result.fail{display:block;background:var(--red-bg);color:var(--red2)}

/* === MISTAKE CARD === */
.mistake{background:var(--bg3);border-left:4px solid var(--red);border-radius:0 var(--radius-sm) var(--radius-sm) 0;padding:18px 20px;margin:16px 0}
.mistake h4{color:var(--red2);margin-bottom:8px;font-size:.95rem}
.mistake .fix{margin-top:12px;border-left-color:var(--green);padding-left:14px;border-left:3px solid var(--green)}
.mistake .fix h4{color:var(--green2)}

/* === ANALOGY === */
.analogy{background:linear-gradient(135deg,rgba(168,85,247,.08),rgba(59,130,246,.08));border:1px solid rgba(168,85,247,.2);border-radius:var(--radius);padding:24px;margin:20px 0}
.analogy h4{color:var(--purple2);margin-bottom:10px;font-size:1rem}
.analogy p{color:var(--text2);font-size:.92rem}
.analogy .emoji{font-size:1.4rem}

/* === COMPARISON TABLE === */
.compare-table{width:100%;border-collapse:separate;border-spacing:0;margin:16px 0;font-size:.88rem}
.compare-table th{background:var(--bg4);padding:12px 14px;text-align:left;font-size:.82rem;text-transform:uppercase;letter-spacing:.5px;color:var(--text2)}
.compare-table th:first-child{border-radius:8px 0 0 0}
.compare-table th:last-child{border-radius:0 8px 0 0}
.compare-table td{padding:12px 14px;border-top:1px solid rgba(255,255,255,.06);color:var(--text2)}
.compare-table tr:nth-child(even) td{background:rgba(255,255,255,.02)}
.compare-table code{background:rgba(0,0,0,.3);padding:2px 6px;border-radius:4px;font-size:.82rem;color:var(--blue2)}

/* === TABS CONTENT HEADER === */
.section-hero{text-align:center;padding:30px 20px;margin-bottom:24px}
.section-hero h2{font-size:1.8rem;margin-bottom:8px;background:linear-gradient(135deg,var(--blue2),var(--purple2));-webkit-background-clip:text;-webkit-text-fill-color:transparent}
.section-hero p{color:var(--text3);font-size:1rem}

/* === UTILITIES === */
.flex{display:flex}.gap-10{gap:10px}.gap-20{gap:20px}.mt-20{margin-top:20px}
.tag{display:inline-block;padding:3px 10px;border-radius:20px;font-size:.75rem;font-weight:600}
.tag-green{background:var(--green-bg);color:var(--green2)}
.tag-red{background:var(--red-bg);color:var(--red2)}
.tag-yellow{background:var(--yellow-bg);color:var(--yellow2)}
.tag-blue{background:rgba(59,130,246,.15);color:var(--blue2)}
.inline-code{background:rgba(0,0,0,.3);padding:2px 7px;border-radius:4px;font-family:monospace;font-size:.88em;color:var(--blue2)}
.divider{border:none;border-top:1px solid rgba(255,255,255,.06);margin:24px 0}
.highlight{color:var(--yellow2);font-weight:600}

/* === SCROLLBAR === */
::-webkit-scrollbar{width:6px;height:6px}
::-webkit-scrollbar-track{background:transparent}
::-webkit-scrollbar-thumb{background:var(--bg4);border-radius:3px}
::-webkit-scrollbar-thumb:hover{background:var(--text3)}

/* === RESPONSIVE === */
@media(max-width:640px){
  .app-header{padding:14px 16px}
  .app-header h1{font-size:1.2rem}
  .progress-bar{width:120px}
  .tab-btn{padding:10px 16px;font-size:.82rem}
  main{padding:16px 12px 60px}
  .card{padding:18px 14px}
  .states-viz{gap:8px}
  .state-circle{width:70px;height:70px;font-size:1.5rem}
  .chain-box{width:100px;font-size:.75rem;padding:10px 6px}
  pre{font-size:.78rem;padding:12px}
  .compare-table{font-size:.78rem}
  .compare-table th,.compare-table td{padding:8px}
}
</style>
</head>
<body>

<!-- ============ HEADER ============ -->
<header class="app-header">
  <h1><span>‚ö°</span> Promises Mastery</h1>
  <div class="progress-wrap">
    <span>Progress</span>
    <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
    <span class="score-badge" id="scoreBadge">0 / 20 pts</span>
  </div>
</header>

<!-- ============ NAVIGATION ============ -->
<nav class="tab-nav" id="tabNav">
  <button class="tab-btn active" data-tab="basics"><span class="num">1</span>Promise Basics</button>
  <button class="tab-btn" data-tab="thencatch"><span class="num">2</span>Then / Catch / Finally</button>
  <button class="tab-btn" data-tab="chaining"><span class="num">3</span>Promise Chaining</button>
  <button class="tab-btn" data-tab="methods"><span class="num">4</span>Promise.all / race / allSettled</button>
  <button class="tab-btn" data-tab="challenges"><span class="num">5</span>Challenges</button>
</nav>

<!-- ============ MAIN CONTENT ============ -->
<main>

<!-- ===================== TAB 1: BASICS ===================== -->
<div class="tab-content active" id="tab-basics">
  <div class="section-hero">
    <h2>üéØ Promise Basics</h2>
    <p>Understand what Promises are, their states, and how to create them</p>
  </div>

  <!-- ANALOGY -->
  <div class="analogy">
    <h4><span class="emoji">üçï</span> Think of it like ordering pizza</h4>
    <p>When you order pizza, you get a <strong>promise</strong> that food is coming. While it's being prepared, the promise is <strong class="highlight">pending</strong>. When it arrives, the promise is <strong style="color:var(--green2)">fulfilled</strong>. If they cancel your order, the promise is <strong style="color:var(--red2)">rejected</strong>. You don't stand at the counter waiting ‚Äî you go sit down (non-blocking!) and they'll call your name when it's ready.</p>
  </div>

  <!-- STATES VISUALIZATION -->
  <div class="card">
    <h2>üîÑ The Three Promise States</h2>
    <p>A Promise is always in one of these three states. Once it moves from <em>pending</em>, it <strong>can never change again</strong>.</p>
    
    <div class="viz-container">
      <div class="states-viz" id="statesViz">
        <div class="state-node">
          <div class="state-circle pending active" id="stPending">‚è≥</div>
          <span class="state-label" style="color:var(--yellow)">Pending</span>
        </div>
        <div class="state-arrow" id="arrow1">‚Üí</div>
        <div class="state-node">
          <div class="state-circle fulfilled" id="stFulfilled" style="opacity:.35">‚úÖ</div>
          <span class="state-label" style="color:var(--green)">Fulfilled</span>
        </div>
        <div class="state-node" style="margin-left:20px">
          <div class="state-circle rejected" id="stRejected" style="opacity:.35">‚ùå</div>
          <span class="state-label" style="color:var(--red)">Rejected</span>
        </div>
      </div>
      <div class="state-controls">
        <button class="btn-resolve" onclick="vizResolve()">‚úÖ Resolve</button>
        <button class="btn-reject" onclick="vizReject()">‚ùå Reject</button>
        <button class="btn-reset" onclick="vizReset()">‚Ü∫ Reset</button>
      </div>
    </div>

    <div class="concept-box info">
      <h4>üí° Key Insight</h4>
      <p>A promise is <strong>settled</strong> once it's either fulfilled or rejected. A settled promise is <strong>immutable</strong> ‚Äî calling resolve() or reject() again does nothing.</p>
    </div>
  </div>

  <!-- CREATING PROMISES -->
  <div class="card">
    <h2>üèóÔ∏è Creating a Promise</h2>
    <p>Use <span class="inline-code">new Promise()</span> with an <strong>executor function</strong> that receives <span class="inline-code">resolve</span> and <span class="inline-code">reject</span> callbacks.</p>
    
    <div class="code-wrapper">
      <div class="code-header">
        <div class="code-dots"><span></span><span></span><span></span></div>
        <span class="code-label">basic-promise.js</span>
        <button class="run-btn" onclick="runExample('ex1')">‚ñ∂ Run</button>
      </div>
      <pre><code id="code-ex1"><span class="cm">// Creating a promise that resolves after 1 second</span>
<span class="kw">const</span> myPromise = <span class="kw">new</span> <span class="fn">Promise</span>(<span class="op">(</span><span class="key">resolve</span>, <span class="key">reject</span><span class="op">)</span> => {
  console.log(<span class="str">"Promise created! (executor runs immediately)"</span>);
  
  <span class="fn">setTimeout</span>(() => {
    <span class="kw">const</span> success = <span class="bool">true</span>;
    
    <span class="kw">if</span> (success) {
      <span class="fn">resolve</span>(<span class="str">"üçï Pizza delivered!"</span>);
    } <span class="kw">else</span> {
      <span class="fn">reject</span>(<span class="str">"üòû Order cancelled"</span>);
    }
  }, <span class="num">1000</span>);
});

<span class="cm">// Consuming the promise</span>
myPromise
  .<span class="fn">then</span>(result => console.log(result))
  .<span class="fn">catch</span>(error => console.log(error));

console.log(<span class="str">"This runs BEFORE the promise resolves!"</span>);</code></pre>
      <div class="output-area" id="output-ex1"></div>
    </div>

    <div class="concept-box warning">
      <h4>‚ö†Ô∏è Important</h4>
      <p>The executor function runs <strong>immediately and synchronously</strong> when you call <code>new Promise()</code>. Only the resolve/reject callbacks are deferred!</p>
    </div>
  </div>

  <!-- RESOLVE SHORTCUTS -->
  <div class="card">
    <h2>‚ö° Quick Promise Creation</h2>
    <p>You don't always need <span class="inline-code">new Promise()</span>. Use these shortcuts for already-known values:</p>
    
    <div class="code-wrapper">
      <div class="code-header">
        <div class="code-dots"><span></span><span></span><span></span></div>
        <span class="code-label">shortcuts.js</span>
        <button class="run-btn" onclick="runExample('ex1b')">‚ñ∂ Run</button>
      </div>
      <pre><code id="code-ex1b"><span class="cm">// Already have the value? Use Promise.resolve()</span>
<span class="kw">const</span> p1 = Promise.<span class="fn">resolve</span>(<span class="num">42</span>);
p1.<span class="fn">then</span>(v => console.log(<span class="str">"Resolved:"</span>, v));

<span class="cm">// Already have an error? Use Promise.reject()</span>
<span class="kw">const</span> p2 = Promise.<span class="fn">reject</span>(<span class="str">"Something broke"</span>);
p2.<span class="fn">catch</span>(e => console.log(<span class="str">"Rejected:"</span>, e));

<span class="cm">// Wrapping a sync value to return a promise</span>
<span class="kw">function</span> <span class="fn">getUser</span>(id) {
  <span class="kw">if</span> (id <= <span class="num">0</span>) <span class="kw">return</span> Promise.<span class="fn">reject</span>(<span class="str">"Invalid ID"</span>);
  <span class="kw">return</span> Promise.<span class="fn">resolve</span>({ id, name: <span class="str">"Alice"</span> });
}

<span class="fn">getUser</span>(<span class="num">1</span>).<span class="fn">then</span>(u => console.log(<span class="str">"User:"</span>, u.name));
<span class="fn">getUser</span>(-<span class="num">1</span>).<span class="fn">catch</span>(e => console.log(<span class="str">"Error:"</span>, e));</code></pre>
      <div class="output-area" id="output-ex1b"></div>
    </div>
  </div>

  <!-- MISTAKES -->
  <div class="card">
    <h2>üö® Common Mistakes</h2>

    <div class="mistake">
      <h4>‚ùå Mistake #1: Forgetting to resolve or reject</h4>
      <p style="color:var(--text2);font-size:.9rem;margin-top:6px">The promise hangs forever in "pending" state ‚Äî a <strong>memory leak</strong>!</p>
      <div class="code-wrapper">
        <div class="code-header"><div class="code-dots"><span></span><span></span><span></span></div><span class="code-label">‚ùå broken</span></div>
        <pre><code><span class="kw">const</span> broken = <span class="kw">new</span> <span class="fn">Promise</span>((resolve, reject) => {
  <span class="kw">const</span> data = <span class="fn">fetchData</span>(); <span class="cm">// got the data but...</span>
  <span class="cm">// üò± Forgot to call resolve(data)!</span>
});</code></pre>
      </div>
      <div class="fix">
        <h4>‚úÖ Fix: Always call resolve() or reject()</h4>
        <div class="code-wrapper">
          <div class="code-header"><div class="code-dots"><span></span><span></span><span></span></div><span class="code-label">‚úÖ fixed</span></div>
          <pre><code><span class="kw">const</span> fixed = <span class="kw">new</span> <span class="fn">Promise</span>((resolve, reject) => {
  <span class="kw">const</span> data = <span class="fn">fetchData</span>();
  <span class="fn">resolve</span>(data); <span class="cm">// ‚úÖ Now the promise settles!</span>
});</code></pre>
        </div>
      </div>
    </div>

    <div class="mistake">
      <h4>‚ùå Mistake #2: Using return instead of resolve</h4>
      <p style="color:var(--text2);font-size:.9rem;margin-top:6px"><code>return</code> inside the executor does <strong>nothing</strong> for the promise.</p>
      <div class="code-wrapper">
        <div class="code-header"><div class="code-dots"><span></span><span></span><span></span></div><span class="code-label">‚ùå broken</span></div>
        <pre><code><span class="kw">const</span> p = <span class="kw">new</span> <span class="fn">Promise</span>(() => {
  <span class="kw">return</span> <span class="num">42</span>; <span class="cm">// ‚ùå This does NOT resolve the promise!</span>
});
<span class="cm">// p is stuck pending forever</span></code></pre>
      </div>
      <div class="fix">
        <h4>‚úÖ Fix: Use resolve(), not return</h4>
        <div class="code-wrapper">
          <div class="code-header"><div class="code-dots"><span></span><span></span><span></span></div><span class="code-label">‚úÖ fixed</span></div>
          <pre><code><span class="kw">const</span> p = <span class="kw">new</span> <span class="fn">Promise</span>((resolve) => {
  <span class="fn">resolve</span>(<span class="num">42</span>); <span class="cm">// ‚úÖ Correct!</span>
});</code></pre>
        </div>
      </div>
    </div>

    <div class="mistake">
      <h4>‚ùå Mistake #3: Calling resolve AND reject</h4>
      <p style="color:var(--text2);font-size:.9rem;margin-top:6px">It won't throw an error, but the second call is silently ignored. This confuses developers.</p>
      <div class="code-wrapper">
        <div class="code-header"><div class="code-dots"><span></span><span></span><span></span></div><span class="code-label">confusing.js</span><button class="run-btn" onclick="runExample('ex1c')">‚ñ∂ Run</button></div>
        <pre><code id="code-ex1c"><span class="kw">const</span> p = <span class="kw">new</span> <span class="fn">Promise</span>((resolve, reject) => {
  <span class="fn">resolve</span>(<span class="str">"First!"</span>);   <span class="cm">// ‚úÖ This wins</span>
  <span class="fn">reject</span>(<span class="str">"Second?"</span>);  <span class="cm">// ‚ùå Silently ignored</span>
  <span class="fn">resolve</span>(<span class="str">"Third?"</span>);  <span class="cm">// ‚ùå Also ignored</span>
});

p.<span class="fn">then</span>(v => console.log(<span class="str">"Result:"</span>, v))
 .<span class="fn">catch</span>(e => console.log(<span class="str">"Error:"</span>, e));</code></pre>
        <div class="output-area" id="output-ex1c"></div>
      </div>
    </div>
  </div>

  <!-- QUIZ -->
  <div class="quiz-section">
    <h3>üß† Quiz: Promise Basics</h3>
    
    <div class="quiz-q" id="q1">
      <p>1. What are the three states of a Promise?</p>
      <div class="quiz-opts">
        <label class="quiz-opt" data-q="q1" data-val="a"><span class="radio"></span>start, middle, end</label>
        <label class="quiz-opt" data-q="q1" data-val="b"><span class="radio"></span>pending, fulfilled, rejected</label>
        <label class="quiz-opt" data-q="q1" data-val="c"><span class="radio"></span>waiting, done, error</label>
        <label class="quiz-opt" data-q="q1" data-val="d"><span class="radio"></span>loading, success, failure</label>
      </div>
      <div class="quiz-explain correct" id="q1-correct">‚úÖ Correct! The three states are <strong>pending</strong> (initial), <strong>fulfilled</strong> (resolved with a value), and <strong>rejected</strong> (rejected with a reason).</div>
      <div class="quiz-explain wrong" id="q1-wrong">‚ùå The three states are <strong>pending</strong>, <strong>fulfilled</strong>, and <strong>rejected</strong>. These are the official spec names.</div>
      <button class="quiz-check-btn" onclick="checkQuiz('q1','b',2)" disabled>Check Answer</button>
    </div>

    <div class="quiz-q" id="q2">
      <p>2. When does the executor function run?</p>
      <div class="quiz-q q-code">new Promise((resolve, reject) => {
  console.log("A");
});
console.log("B");</div>
      <div class="quiz-opts">
        <label class="quiz-opt" data-q="q2" data-val="a"><span class="radio"></span>Output: B, A (executor is async)</label>
        <label class="quiz-opt" data-q="q2" data-val="b"><span class="radio"></span>Output: A, B (executor runs immediately)</label>
        <label class="quiz-opt" data-q="q2" data-val="c"><span class="radio"></span>Output: A only</label>
        <label class="quiz-opt" data-q="q2" data-val="d"><span class="radio"></span>It throws an error</label>
      </div>
      <div class="quiz-explain correct" id="q2-correct">‚úÖ Correct! The executor runs <strong>synchronously and immediately</strong>. "A" prints first, then "B".</div>
      <div class="quiz-explain wrong" id="q2-wrong">‚ùå The executor runs <strong>immediately and synchronously</strong>. So "A" prints before "B". Only .then() callbacks are async.</div>
      <button class="quiz-check-btn" onclick="checkQuiz('q2','b',2)" disabled>Check Answer</button>
    </div>

    <div class="quiz-q" id="q3">
      <p>3. What happens when you call resolve() twice on the same promise?</p>
      <div class="quiz-opts">
        <label class="quiz-opt" data-q="q3" data-val="a"><span class="radio"></span>It throws a runtime error</label>
        <label class="quiz-opt" data-q="q3" data-val="b"><span class="radio"></span>The second call overwrites the first</label>
        <label class="quiz-opt" data-q="q3" data-val="c"><span class="radio"></span>The second call is silently ignored</label>
        <label class="quiz-opt" data-q="q3" data-val="d"><span class="radio"></span>.then() runs twice</label>
      </div>
      <div class="quiz-explain correct" id="q3-correct">‚úÖ Correct! Once a promise is settled, all subsequent resolve/reject calls are <strong>silently ignored</strong>. The promise is immutable once settled.</div>
      <div class="quiz-explain wrong" id="q3-wrong">‚ùå The second call is <strong>silently ignored</strong>. Once a promise is settled (fulfilled or rejected), it can't change state again.</div>
      <button class="quiz-check-btn" onclick="checkQuiz('q3','c',2)" disabled>Check Answer</button>
    </div>
  </div>
</div>

<!-- ===================== TAB 2: THEN/CATCH/FINALLY ===================== -->
<div class="tab-content" id="tab-thencatch">
  <div class="section-hero">
    <h2>üé£ Then / Catch / Finally</h2>
    <p>Handle promise results and errors like a pro</p>
  </div>

  <!-- .THEN() -->
  <div class="card">
    <h2>‚úÖ .then() ‚Äî Handle Success</h2>
    <p><span class="inline-code">.then()</span> registers a callback to run when the promise <strong>fulfills</strong>. It receives the resolved value as its argument.</p>

    <div class="code-wrapper">
      <div class="code-header"><div class="code-dots"><span></span><span></span><span></span></div><span class="code-label">then-basics.js</span><button class="run-btn" onclick="runExample('ex2a')">‚ñ∂ Run</button></div>
      <pre><code id="code-ex2a"><span class="kw">const</span> promise = <span class="kw">new</span> <span class="fn">Promise</span>((resolve) => {
  <span class="fn">setTimeout</span>(() => <span class="fn">resolve</span>(<span class="num">42</span>), <span class="num">500</span>);
});

<span class="cm">// .then() receives the resolved value</span>
promise.<span class="fn">then</span>(value => {
  console.log(<span class="str">"Got value:"</span>, value);
  console.log(<span class="str">"Type:"</span>, <span class="kw">typeof</span> value);
});

<span class="cm">// .then() can also take TWO arguments</span>
<span class="cm">// (rarely used ‚Äî prefer .catch() instead)</span>
promise.<span class="fn">then</span>(
  value => console.log(<span class="str">"Success:"</span>, value),
  error => console.log(<span class="str">"Error:"</span>, error)
);</code></pre>
      <div class="output-area" id="output-ex2a"></div>
    </div>

    <div class="concept-box info">
      <h4>üí° .then() always returns a NEW Promise</h4>
      <p>This is what makes chaining possible! The value you <code>return</code> from <code>.then()</code> becomes the resolved value of the next promise in the chain.</p>
    </div>
  </div>

  <!-- .CATCH() -->
  <div class="card">
    <h2>üõë .catch() ‚Äî Handle Errors</h2>
    <p><span class="inline-code">.catch()</span> runs when a promise <strong>rejects</strong> or when an <strong>error is thrown</strong> in any preceding <code>.then()</code>.</p>

    <div class="code-wrapper">
      <div class="code-header"><div class="code-dots"><span></span><span></span><span></span></div><span class="code-label">catch-examples.js</span><button class="run-btn" onclick="runExample('ex2b')">‚ñ∂ Run</button></div>
      <pre><code id="code-ex2b"><span class="cm">// Example 1: Catching a rejected promise</span>
<span class="kw">const</span> p1 = Promise.<span class="fn">reject</span>(<span class="str">"Network error"</span>);
p1.<span class="fn">catch</span>(err => console.log(<span class="str">"Caught:"</span>, err));

<span class="cm">// Example 2: Catching errors thrown in .then()</span>
Promise.<span class="fn">resolve</span>(<span class="str">"hello"</span>)
  .<span class="fn">then</span>(val => {
    <span class="kw">throw new</span> <span class="fn">Error</span>(<span class="str">"Oops in .then()!"</span>);
  })
  .<span class="fn">catch</span>(err => console.log(<span class="str">"Also caught:"</span>, err.message));

<span class="cm">// Example 3: catch() recovers the chain!</span>
Promise.<span class="fn">reject</span>(<span class="str">"üí•"</span>)
  .<span class="fn">catch</span>(err => {
    console.log(<span class="str">"Recovering from:"</span>, err);
    <span class="kw">return</span> <span class="str">"All good now!"</span>; <span class="cm">// ‚Üê chain continues!</span>
  })
  .<span class="fn">then</span>(val => console.log(<span class="str">"After recovery:"</span>, val));</code></pre>
      <div class="output-area" id="output-ex2b"></div>
    </div>

    <div class="concept-box success">
      <h4>üîë Key: .catch() is a recovery point</h4>
      <p>If <code>.catch()</code> returns a value (or a fulfilled promise), the chain <strong>continues normally</strong> after it. The error is "handled" and the chain is no longer in a rejected state.</p>
    </div>
  </div>

  <!-- .FINALLY() -->
  <div class="card">
    <h2>üèÅ .finally() ‚Äî Always Runs</h2>
    <p><span class="inline-code">.finally()</span> runs whether the promise <strong>fulfills OR rejects</strong>. Perfect for cleanup. It receives <strong>no arguments</strong>.</p>

    <div class="code-wrapper">
      <div class="code-header"><div class="code-dots"><span></span><span></span><span></span></div><span class="code-label">finally-examples.js</span><button class="run-btn" onclick="runExample('ex2c')">‚ñ∂ Run</button></div>
      <pre><code id="code-ex2c"><span class="cm">// .finally() runs no matter what</span>
<span class="kw">function</span> <span class="fn">loadData</span>(shouldFail) {
  console.log(<span class="str">"‚è≥ Loading..."</span>);
  
  <span class="kw">return new</span> <span class="fn">Promise</span>((resolve, reject) => {
    <span class="fn">setTimeout</span>(() => {
      <span class="kw">if</span> (shouldFail) <span class="fn">reject</span>(<span class="str">"Server error"</span>);
      <span class="kw">else</span> <span class="fn">resolve</span>({ data: [<span class="num">1</span>,<span class="num">2</span>,<span class="num">3</span>] });
    }, <span class="num">300</span>);
  });
}

<span class="cm">// Success case</span>
<span class="fn">loadData</span>(<span class="bool">false</span>)
  .<span class="fn">then</span>(res => console.log(<span class="str">"‚úÖ Data:"</span>, res.data))
  .<span class="fn">catch</span>(err => console.log(<span class="str">"‚ùå Error:"</span>, err))
  .<span class="fn">finally</span>(() => console.log(<span class="str">"üèÅ Cleanup done (success)"</span>));

<span class="cm">// Failure case</span>
<span class="fn">setTimeout</span>(() => {
  <span class="fn">loadData</span>(<span class="bool">true</span>)
    .<span class="fn">then</span>(res => console.log(<span class="str">"‚úÖ Data:"</span>, res))
    .<span class="fn">catch</span>(err => console.log(<span class="str">"‚ùå Error:"</span>, err))
    .<span class="fn">finally</span>(() => console.log(<span class="str">"üèÅ Cleanup done (failure)"</span>));
}, <span class="num">500</span>);</code></pre>
      <div class="output-area" id="output-ex2c"></div>
    </div>

    <div class="concept-box warning">
      <h4>‚ö†Ô∏è .finally() gets no arguments!</h4>
      <p><code>.finally(value =&gt; ...)</code> ‚Äî that <code>value</code> is always <code>undefined</code>. It doesn't know if the promise resolved or rejected. It just runs cleanup code.</p>
    </div>
  </div>

  <!-- ERROR PROPAGATION -->
  <div class="card">
    <h2>üî• Error Propagation</h2>
    <p>Errors "bubble down" the chain until they find a <span class="inline-code">.catch()</span>. This is one of the most powerful features of promises.</p>
    
    <div class="code-wrapper">
      <div class="code-header"><div class="code-dots"><span></span><span></span><span></span></div><span class="code-label">error-propagation.js</span><button class="run-btn" onclick="runExample('ex2d')">‚ñ∂ Run</button></div>
      <pre><code id="code-ex2d">Promise.<span class="fn">resolve</span>(<span class="num">1</span>)
  .<span class="fn">then</span>(v => {
    console.log(<span class="str">"Step 1:"</span>, v);
    <span class="kw">return</span> v + <span class="num">1</span>;
  })
  .<span class="fn">then</span>(v => {
    console.log(<span class="str">"Step 2:"</span>, v);
    <span class="kw">throw new</span> <span class="fn">Error</span>(<span class="str">"üí• Boom at step 2!"</span>);
  })
  .<span class="fn">then</span>(v => {
    console.log(<span class="str">"Step 3:"</span>, v); <span class="cm">// ‚Üê SKIPPED!</span>
  })
  .<span class="fn">then</span>(v => {
    console.log(<span class="str">"Step 4:"</span>, v); <span class="cm">// ‚Üê ALSO SKIPPED!</span>
  })
  .<span class="fn">catch</span>(err => {
    console.log(<span class="str">"Caught!"</span>, err.message);
    console.log(<span class="str">"Steps 3 & 4 were skipped!"</span>);
  });</code></pre>
      <div class="output-area" id="output-ex2d"></div>
    </div>
  </div>

  <!-- MISTAKES -->
  <div class="card">
    <h2>üö® Common Mistakes</h2>

    <div class="mistake">
      <h4>‚ùå Mistake: Forgetting .catch() ‚Äî Unhandled Rejection!</h4>
      <div class="code-wrapper">
        <div class="code-header"><div class="code-dots"><span></span><span></span><span></span></div><span class="code-label">‚ùå dangerous</span></div>
        <pre><code><span class="cm">// ‚ùå No .catch() = unhandled promise rejection!</span>
<span class="cm">// This can crash Node.js and shows warnings in browsers</span>
Promise.<span class="fn">reject</span>(<span class="str">"error"</span>).<span class="fn">then</span>(v => console.log(v));
<span class="cm">// UnhandledPromiseRejectionWarning: error</span></code></pre>
      </div>
      <div class="fix">
        <h4>‚úÖ Fix: Always add .catch() at the end of your chain</h4>
        <div class="code-wrapper">
          <div class="code-header"><div class="code-dots"><span></span><span></span><span></span></div><span class="code-label">‚úÖ safe</span></div>
          <pre><code>Promise.<span class="fn">reject</span>(<span class="str">"error"</span>)
  .<span class="fn">then</span>(v => console.log(v))
  .<span class="fn">catch</span>(e => console.log(<span class="str">"Handled:"</span>, e)); <span class="cm">// ‚úÖ</span></code></pre>
        </div>
      </div>
    </div>

    <div class="mistake">
      <h4>‚ùå Mistake: .catch() in the wrong position</h4>
      <div class="code-wrapper">
        <div class="code-header"><div class="code-dots"><span></span><span></span><span></span></div><span class="code-label">wrong-position.js</span><button class="run-btn" onclick="runExample('ex2e')">‚ñ∂ Run</button></div>
        <pre><code id="code-ex2e"><span class="cm">// The .catch() only catches errors BEFORE it!</span>
Promise.<span class="fn">resolve</span>(<span class="str">"ok"</span>)
  .<span class="fn">catch</span>(e => console.log(<span class="str">"Won't catch later errors!"</span>))
  .<span class="fn">then</span>(v => {
    <span class="kw">throw new</span> <span class="fn">Error</span>(<span class="str">"Error AFTER catch"</span>);
  })
  .<span class="fn">catch</span>(e => console.log(<span class="str">"Second catch got it:"</span>, e.message));
<span class="cm">// You need a catch AFTER the error source</span></code></pre>
        <div class="output-area" id="output-ex2e"></div>
      </div>
    </div>
  </div>

  <!-- QUIZ -->
  <div class="quiz-section">
    <h3>üß† Quiz: Then / Catch / Finally</h3>

    <div class="quiz-q" id="q4">
      <p>4. What does .finally() receive as an argument?</p>
      <div class="quiz-opts">
        <label class="quiz-opt" data-q="q4" data-val="a"><span class="radio"></span>The resolved value</label>
        <label class="quiz-opt" data-q="q4" data-val="b"><span class="radio"></span>The error reason</label>
        <label class="quiz-opt" data-q="q4" data-val="c"><span class="radio"></span>Both value and error</label>
        <label class="quiz-opt" data-q="q4" data-val="d"><span class="radio"></span>Nothing (no arguments)</label>
      </div>
      <div class="quiz-explain correct" id="q4-correct">‚úÖ Correct! <code>.finally()</code> receives <strong>no arguments</strong>. It doesn't know if the promise succeeded or failed ‚Äî it's purely for cleanup.</div>
      <div class="quiz-explain wrong" id="q4-wrong">‚ùå <code>.finally()</code> receives <strong>nothing</strong>. Unlike <code>.then()</code> and <code>.catch()</code>, it gets no arguments at all.</div>
      <button class="quiz-check-btn" onclick="checkQuiz('q4','d',2)" disabled>Check Answer</button>
    </div>

    <div class="quiz-q" id="q5">
      <p>5. What does .catch() return if it doesn't throw?</p>
      <div class="quiz-q q-code">Promise.reject("err")
  .catch(e => "recovered")
  .then(v => console.log(v));</div>
      <div class="quiz-opts">
        <label class="quiz-opt" data-q="q5" data-val="a"><span class="radio"></span>Logs "err"</label>
        <label class="quiz-opt" data-q="q5" data-val="b"><span class="radio"></span>Logs "recovered"</label>
        <label class="quiz-opt" data-q="q5" data-val="c"><span class="radio"></span>Logs undefined</label>
        <label class="quiz-opt" data-q="q5" data-val="d"><span class="radio"></span>Throws an error</label>
      </div>
      <div class="quiz-explain correct" id="q5-correct">‚úÖ Correct! <code>.catch()</code> acts as a recovery point. The returned value <code>"recovered"</code> becomes the resolved value for the next <code>.then()</code>.</div>
      <div class="quiz-explain wrong" id="q5-wrong">‚ùå <code>.catch()</code> returns a <strong>fulfilled</strong> promise with the value <code>"recovered"</code>. The chain continues normally after a successful catch.</div>
      <button class="quiz-check-btn" onclick="checkQuiz('q5','b',2)" disabled>Check Answer</button>
    </div>

    <div class="quiz-q" id="q6">
      <p>6. How many .then() callbacks run in this chain?</p>
      <div class="quiz-q q-code">Promise.reject("fail")
  .then(v => "step 1")
  .then(v => "step 2")
  .then(v => "step 3")
  .catch(e => "caught");</div>
      <div class="quiz-opts">
        <label class="quiz-opt" data-q="q6" data-val="a"><span class="radio"></span>All three .then() callbacks run</label>
        <label class="quiz-opt" data-q="q6" data-val="b"><span class="radio"></span>Only the first .then() runs</label>
        <label class="quiz-opt" data-q="q6" data-val="c"><span class="radio"></span>Zero ‚Äî they're all skipped</label>
        <label class="quiz-opt" data-q="q6" data-val="d"><span class="radio"></span>It depends on the error type</label>
      </div>
      <div class="quiz-explain correct" id="q6-correct">‚úÖ Correct! Since the original promise rejects, <strong>all three .then() callbacks are skipped</strong>. The error propagates down to .catch().</div>
      <div class="quiz-explain wrong" id="q6-wrong">‚ùå Zero .then() callbacks run! The rejection "bubbles" past all .then() handlers until it reaches .catch().</div>
      <button class="quiz-check-btn" onclick="checkQuiz('q6','c',2)" disabled>Check Answer</button>
    </div>
  </div>
</div>

<!-- ===================== TAB 3: CHAINING ===================== -->
<div class="tab-content" id="tab-chaining">
  <div class="section-hero">
    <h2>üîó Promise Chaining</h2>
    <p>Build elegant async workflows by chaining promises together</p>
  </div>

  <!-- WHY CHAIN -->
  <div class="card">
    <h2>ü§î Why Chain Promises?</h2>
    <p>Before promises, async code was nested in "callback hell." Chaining keeps code flat and readable.</p>

    <div class="code-wrapper">
      <div class="code-header"><div class="code-dots"><span></span><span></span><span></span></div><span class="code-label">callback-hell.js ‚Äî DON'T do this</span></div>
      <pre><code><span class="cm">// ‚ùå Callback Hell (Pyramid of Doom)</span>
<span class="fn">getUser</span>(id, <span class="kw">function</span>(user) {
  <span class="fn">getOrders</span>(user.id, <span class="kw">function</span>(orders) {
    <span class="fn">getItems</span>(orders[<span class="num">0</span>].id, <span class="kw">function</span>(items) {
      <span class="fn">getPrice</span>(items[<span class="num">0</span>].id, <span class="kw">function</span>(price) {
        console.log(price);  <span class="cm">// üòµ 4 levels deep!</span>
      });
    });
  });
});</code></pre>
    </div>

    <div class="code-wrapper">
      <div class="code-header"><div class="code-dots"><span></span><span></span><span></span></div><span class="code-label">promise-chain.js ‚Äî ‚úÖ DO this</span></div>
      <pre><code><span class="cm">// ‚úÖ Promise Chain (flat and readable!)</span>
<span class="fn">getUser</span>(id)
  .<span class="fn">then</span>(user => <span class="fn">getOrders</span>(user.id))
  .<span class="fn">then</span>(orders => <span class="fn">getItems</span>(orders[<span class="num">0</span>].id))
  .<span class="fn">then</span>(items => <span class="fn">getPrice</span>(items[<span class="num">0</span>].id))
  .<span class="fn">then</span>(price => console.log(price))
  .<span class="fn">catch</span>(err => console.error(err)); <span class="cm">// One catch for all!</span></code></pre>
    </div>
  </div>

  <!-- CHAIN VISUALIZATION -->
  <div class="card">
    <h2>üé¨ Chain in Action</h2>
    <p>Watch data flow through each step. Click Run to see the chain execute step by step.</p>
    
    <div class="viz-container">
      <div class="chain-viz" id="chainViz">
        <div class="chain-step">
          <div class="chain-box" id="ch1">fetch user</div>
          <div class="chain-value" id="cv1"></div>
        </div>
        <div class="chain-arrow">‚Üí</div>
        <div class="chain-step">
          <div class="chain-box" id="ch2">get orders</div>
          <div class="chain-value" id="cv2"></div>
        </div>
        <div class="chain-arrow">‚Üí</div>
        <div class="chain-step">
          <div class="chain-box" id="ch3">get details</div>
          <div class="chain-value" id="cv3"></div>
        </div>
        <div class="chain-arrow">‚Üí</div>
        <div class="chain-step">
          <div class="chain-box" id="ch4">display</div>
          <div class="chain-value" id="cv4"></div>
        </div>
      </div>
      <div class="state-controls">
        <button class="btn-resolve" onclick="runChainViz()">‚ñ∂ Run Chain</button>
        <button class="btn-reset" onclick="resetChainViz()">‚Ü∫ Reset</button>
      </div>
    </div>
  </div>

  <!-- CHAINING RULES -->
  <div class="card">
    <h2>üìú The Golden Rules of Chaining</h2>

    <div class="concept-box info">
      <h4>Rule 1: Always return a value</h4>
      <p>Whatever you <code>return</code> from <code>.then()</code> becomes the input for the next <code>.then()</code>.</p>
    </div>

    <div class="code-wrapper">
      <div class="code-header"><div class="code-dots"><span></span><span></span><span></span></div><span class="code-label">return-values.js</span><button class="run-btn" onclick="runExample('ex3a')">‚ñ∂ Run</button></div>
      <pre><code id="code-ex3a">Promise.<span class="fn">resolve</span>(<span class="num">1</span>)
  .<span class="fn">then</span>(val => {
    console.log(<span class="str">"Step 1 got:"</span>, val);
    <span class="kw">return</span> val * <span class="num">10</span>;        <span class="cm">// return 10</span>
  })
  .<span class="fn">then</span>(val => {
    console.log(<span class="str">"Step 2 got:"</span>, val);
    <span class="kw">return</span> val + <span class="num">5</span>;         <span class="cm">// return 15</span>
  })
  .<span class="fn">then</span>(val => {
    console.log(<span class="str">"Step 3 got:"</span>, val);
    <span class="kw">return</span> <span class="str">"Final: "</span> + val; <span class="cm">// return "Final: 15"</span>
  })
  .<span class="fn">then</span>(val => {
    console.log(<span class="str">"Step 4 got:"</span>, val);
  });</code></pre>
      <div class="output-area" id="output-ex3a"></div>
    </div>

    <div class="concept-box purple">
      <h4>Rule 2: Returning a Promise is auto-unwrapped</h4>
      <p>If you return a Promise from <code>.then()</code>, the chain waits for it to settle and passes its resolved value.</p>
    </div>

    <div class="code-wrapper">
      <div class="code-header"><div class="code-dots"><span></span><span></span><span></span></div><span class="code-label">return-promises.js</span><button class="run-btn" onclick="runExample('ex3b')">‚ñ∂ Run</button></div>
      <pre><code id="code-ex3b"><span class="kw">function</span> <span class="fn">delay</span>(ms, value) {
  <span class="kw">return new</span> <span class="fn">Promise</span>(resolve =>
    <span class="fn">setTimeout</span>(() => <span class="fn">resolve</span>(value), ms)
  );
}

<span class="fn">delay</span>(<span class="num">300</span>, <span class="str">"üê¢ slow"</span>)
  .<span class="fn">then</span>(val => {
    console.log(<span class="str">"Got:"</span>, val);
    <span class="kw">return</span> <span class="fn">delay</span>(<span class="num">300</span>, <span class="str">"üêá fast"</span>); <span class="cm">// returns a Promise!</span>
  })
  .<span class="fn">then</span>(val => {
    console.log(<span class="str">"Got:"</span>, val); <span class="cm">// auto-unwrapped!</span>
    <span class="kw">return</span> <span class="fn">delay</span>(<span class="num">300</span>, <span class="str">"üèÅ done"</span>);
  })
  .<span class="fn">then</span>(val => console.log(<span class="str">"Got:"</span>, val));</code></pre>
      <div class="output-area" id="output-ex3b"></div>
    </div>
  </div>

  <!-- MISTAKES -->
  <div class="card">
    <h2>üö® Chaining Pitfalls</h2>

    <div class="mistake">
      <h4>‚ùå Pitfall #1: Forgetting to return</h4>
      <div class="code-wrapper">
        <div class="code-header"><div class="code-dots"><span></span><span></span><span></span></div><span class="code-label">no-return.js</span><button class="run-btn" onclick="runExample('ex3c')">‚ñ∂ Run</button></div>
        <pre><code id="code-ex3c"><span class="cm">// ‚ùå BAD: Missing return!</span>
Promise.<span class="fn">resolve</span>(<span class="num">1</span>)
  .<span class="fn">then</span>(val => {
    val * <span class="num">10</span>; <span class="cm">// No return! Value is lost!</span>
  })
  .<span class="fn">then</span>(val => {
    console.log(<span class="str">"‚ùå Got:"</span>, val); <span class="cm">// undefined!</span>
  });

<span class="cm">// ‚úÖ GOOD: With return (or arrow shorthand)</span>
Promise.<span class="fn">resolve</span>(<span class="num">1</span>)
  .<span class="fn">then</span>(val => val * <span class="num">10</span>)  <span class="cm">// Arrow auto-returns!</span>
  .<span class="fn">then</span>(val => {
    console.log(<span class="str">"‚úÖ Got:"</span>, val); <span class="cm">// 10!</span>
  });</code></pre>
        <div class="output-area" id="output-ex3c"></div>
      </div>
    </div>

    <div class="mistake">
      <h4>‚ùå Pitfall #2: Nesting instead of chaining</h4>
      <div class="code-wrapper">
        <div class="code-header"><div class="code-dots"><span></span><span></span><span></span></div><span class="code-label">nesting-bad.js</span></div>
        <pre><code><span class="cm">// ‚ùå BAD: Nesting (recreating callback hell!)</span>
<span class="fn">getUser</span>().<span class="fn">then</span>(user => {
  <span class="fn">getOrders</span>(user.id).<span class="fn">then</span>(orders => {
    <span class="fn">getItems</span>(orders[<span class="num">0</span>]).<span class="fn">then</span>(items => {
      console.log(items); <span class="cm">// üò± Nested again!</span>
    });
  });
});

<span class="cm">// ‚úÖ GOOD: Flat chain</span>
<span class="fn">getUser</span>()
  .<span class="fn">then</span>(user => <span class="fn">getOrders</span>(user.id))
  .<span class="fn">then</span>(orders => <span class="fn">getItems</span>(orders[<span class="num">0</span>]))
  .<span class="fn">then</span>(items => console.log(items))
  .<span class="fn">catch</span>(err => console.error(err));</code></pre>
      </div>
    </div>

    <div class="mistake">
      <h4>‚ùå Pitfall #3: Breaking the chain</h4>
      <div class="code-wrapper">
        <div class="code-header"><div class="code-dots"><span></span><span></span><span></span></div><span class="code-label">broken-chain.js</span><button class="run-btn" onclick="runExample('ex3d')">‚ñ∂ Run</button></div>
        <pre><code id="code-ex3d"><span class="cm">// ‚ùå BAD: These are SEPARATE chains, not one chain!</span>
<span class="kw">const</span> p = Promise.<span class="fn">resolve</span>(<span class="num">1</span>);
p.<span class="fn">then</span>(v => console.log(<span class="str">"Branch A:"</span>, v * <span class="num">10</span>));
p.<span class="fn">then</span>(v => console.log(<span class="str">"Branch B:"</span>, v + <span class="num">5</span>));
<span class="cm">// Both run with the same value (1)!</span>
<span class="cm">// They're parallel branches, not sequential steps</span>

<span class="cm">// ‚úÖ GOOD: One continuous chain</span>
Promise.<span class="fn">resolve</span>(<span class="num">1</span>)
  .<span class="fn">then</span>(v => { console.log(<span class="str">"Chained A:"</span>, v); <span class="kw">return</span> v * <span class="num">10</span>; })
  .<span class="fn">then</span>(v => { console.log(<span class="str">"Chained B:"</span>, v); });</code></pre>
        <div class="output-area" id="output-ex3d"></div>
      </div>
    </div>
  </div>

  <!-- QUIZ -->
  <div class="quiz-section">
    <h3>üß† Quiz: Promise Chaining</h3>

    <div class="quiz-q" id="q7">
      <p>7. What does this log?</p>
      <div class="quiz-q q-code">Promise.resolve(5)
  .then(v => v * 2)
  .then(v => v + 3)
  .then(v => console.log(v));</div>
      <div class="quiz-opts">
        <label class="quiz-opt" data-q="q7" data-val="a"><span class="radio"></span>5</label>
        <label class="quiz-opt" data-q="q7" data-val="b"><span class="radio"></span>10</label>
        <label class="quiz-opt" data-q="q7" data-val="c"><span class="radio"></span>13</label>
        <label class="quiz-opt" data-q="q7" data-val="d"><span class="radio"></span>undefined</label>
      </div>
      <div class="quiz-explain correct" id="q7-correct">‚úÖ Correct! 5 ‚Üí √ó2 = 10 ‚Üí +3 = 13. Each .then() passes its return value to the next.</div>
      <div class="quiz-explain wrong" id="q7-wrong">‚ùå The answer is 13. The chain goes: 5 ‚Üí √ó2 = 10 ‚Üí +3 = 13. Each <code>.then()</code> receives the returned value from the previous one.</div>
      <button class="quiz-check-btn" onclick="checkQuiz('q7','c',2)" disabled>Check Answer</button>
    </div>

    <div class="quiz-q" id="q8">
      <p>8. What happens when you forget to return inside .then()?</p>
      <div class="quiz-opts">
        <label class="quiz-opt" data-q="q8" data-val="a"><span class="radio"></span>The chain breaks with an error</label>
        <label class="quiz-opt" data-q="q8" data-val="b"><span class="radio"></span>The next .then() receives undefined</label>
        <label class="quiz-opt" data-q="q8" data-val="c"><span class="radio"></span>The previous value passes through automatically</label>
        <label class="quiz-opt" data-q="q8" data-val="d"><span class="radio"></span>It skips to .catch()</label>
      </div>
      <div class="quiz-explain correct" id="q8-correct">‚úÖ Correct! If you don't return anything, JavaScript implicitly returns <code>undefined</code>, and that's what the next <code>.then()</code> receives.</div>
      <div class="quiz-explain wrong" id="q8-wrong">‚ùå The next <code>.then()</code> receives <code>undefined</code>. JS functions always implicitly return <code>undefined</code> if there's no explicit return.</div>
      <button class="quiz-check-btn" onclick="checkQuiz('q8','b',2)" disabled>Check Answer</button>
    </div>
  </div>
</div>

<!-- ===================== TAB 4: PROMISE METHODS ===================== -->
<div class="tab-content" id="tab-methods">
  <div class="section-hero">
    <h2>üß∞ Promise Static Methods</h2>
    <p>Handle multiple promises with all, race, allSettled, and any</p>
  </div>

  <!-- PROMISE.ALL -->
  <div class="card">
    <h2>üì¶ Promise.all()</h2>
    <p>Waits for <strong>ALL</strong> promises to fulfill. Rejects immediately if <strong>ANY ONE</strong> rejects.</p>
    
    <div class="concept-box info">
      <h4>üìê Use when: You need ALL results before proceeding</h4>
      <p>Loading a dashboard that needs user data, notifications, AND settings at the same time.</p>
    </div>

    <div class="viz-container">
      <div class="multi-viz" id="allViz">
        <div class="promise-lane">
          <span class="lane-label">Promise 1</span>
          <div class="lane-track"><div class="lane-fill p1" id="allP1" style="width:0%"></div></div>
          <span class="lane-status" id="allS1">‚è≥</span>
        </div>
        <div class="promise-lane">
          <span class="lane-label">Promise 2</span>
          <div class="lane-track"><div class="lane-fill p2" id="allP2" style="width:0%"></div></div>
          <span class="lane-status" id="allS2">‚è≥</span>
        </div>
        <div class="promise-lane">
          <span class="lane-label">Promise 3</span>
          <div class="lane-track"><div class="lane-fill p3" id="allP3" style="width:0%"></div></div>
          <span class="lane-status" id="allS3">‚è≥</span>
        </div>
        <div class="multi-result" id="allResult">Click "Run" to start</div>
      </div>
      <div class="state-controls">
        <button class="btn-resolve" onclick="runAllViz(false)">‚ñ∂ Run (all succeed)</button>
        <button class="btn-reject" onclick="runAllViz(true)">‚ñ∂ Run (one fails)</button>
        <button class="btn-reset" onclick="resetMultiViz('all')">‚Ü∫ Reset</button>
      </div>
    </div>

    <div class="code-wrapper">
      <div class="code-header"><div class="code-dots"><span></span><span></span><span></span></div><span class="code-label">promise-all.js</span><button class="run-btn" onclick="runExample('ex4a')">‚ñ∂ Run</button></div>
      <pre><code id="code-ex4a"><span class="kw">const</span> p1 = <span class="kw">new</span> <span class="fn">Promise</span>(r => <span class="fn">setTimeout</span>(() => r(<span class="str">"üë§ User data"</span>), <span class="num">300</span>));
<span class="kw">const</span> p2 = <span class="kw">new</span> <span class="fn">Promise</span>(r => <span class="fn">setTimeout</span>(() => r(<span class="str">"üì¨ Notifications"</span>), <span class="num">500</span>));
<span class="kw">const</span> p3 = <span class="kw">new</span> <span class="fn">Promise</span>(r => <span class="fn">setTimeout</span>(() => r(<span class="str">"‚öôÔ∏è Settings"</span>), <span class="num">200</span>));

console.log(<span class="str">"Loading dashboard..."</span>);

Promise.<span class="fn">all</span>([p1, p2, p3])
  .<span class="fn">then</span>(([user, notifs, settings]) => {
    console.log(<span class="str">"All loaded!"</span>);
    console.log(user);
    console.log(notifs);
    console.log(settings);
  })
  .<span class="fn">catch</span>(err => console.log(<span class="str">"Failed:"</span>, err));</code></pre>
      <div class="output-area" id="output-ex4a"></div>
    </div>

    <div class="concept-box danger">
      <h4>üö® Gotcha: One bad apple spoils the bunch</h4>
      <p>If <strong>any single promise</strong> rejects, Promise.all rejects immediately ‚Äî you lose all results, even from the promises that succeeded!</p>
    </div>

    <div class="code-wrapper">
      <div class="code-header"><div class="code-dots"><span></span><span></span><span></span></div><span class="code-label">all-fail.js</span><button class="run-btn" onclick="runExample('ex4a2')">‚ñ∂ Run</button></div>
      <pre><code id="code-ex4a2">Promise.<span class="fn">all</span>([
  Promise.<span class="fn">resolve</span>(<span class="str">"‚úÖ Success 1"</span>),
  Promise.<span class="fn">reject</span>(<span class="str">"üí• Failed!"</span>),  <span class="cm">// One fails...</span>
  Promise.<span class="fn">resolve</span>(<span class="str">"‚úÖ Success 3"</span>),
])
  .<span class="fn">then</span>(results => console.log(<span class="str">"Results:"</span>, results))
  .<span class="fn">catch</span>(err => console.log(<span class="str">"ALL rejected because:"</span>, err));</code></pre>
      <div class="output-area" id="output-ex4a2"></div>
    </div>
  </div>

  <!-- PROMISE.RACE -->
  <div class="card">
    <h2>üèÅ Promise.race()</h2>
    <p>Returns the result of the <strong>FIRST</strong> promise to settle (fulfill or reject). The others are ignored.</p>

    <div class="concept-box info">
      <h4>üìê Use when: You want the fastest result, or to implement timeouts</h4>
      <p>Racing a fetch against a timeout promise to prevent hanging requests.</p>
    </div>

    <div class="viz-container">
      <div class="multi-viz" id="raceViz">
        <div class="promise-lane">
          <span class="lane-label">üê¢ Slow</span>
          <div class="lane-track"><div class="lane-fill p1" id="raceP1" style="width:0%"></div></div>
          <span class="lane-status" id="raceS1">‚è≥</span>
        </div>
        <div class="promise-lane">
          <span class="lane-label">üêá Fast</span>
          <div class="lane-track"><div class="lane-fill p2" id="raceP2" style="width:0%"></div></div>
          <span class="lane-status" id="raceS2">‚è≥</span>
        </div>
        <div class="promise-lane">
          <span class="lane-label">üêï Medium</span>
          <div class="lane-track"><div class="lane-fill p3" id="raceP3" style="width:0%"></div></div>
          <span class="lane-status" id="raceS3">‚è≥</span>
        </div>
        <div class="multi-result" id="raceResult">Click "Run" to start the race</div>
      </div>
      <div class="state-controls">
        <button class="btn-resolve" onclick="runRaceViz()">üèÅ Start Race</button>
        <button class="btn-reset" onclick="resetMultiViz('race')">‚Ü∫ Reset</button>
      </div>
    </div>

    <div class="code-wrapper">
      <div class="code-header"><div class="code-dots"><span></span><span></span><span></span></div><span class="code-label">timeout-pattern.js</span><button class="run-btn" onclick="runExample('ex4b')">‚ñ∂ Run</button></div>
      <pre><code id="code-ex4b"><span class="cm">// Classic pattern: Fetch with timeout</span>
<span class="kw">function</span> <span class="fn">fetchWithTimeout</span>(url, ms) {
  <span class="kw">const</span> fetchPromise = <span class="kw">new</span> <span class="fn">Promise</span>(resolve =>
    <span class="fn">setTimeout</span>(() => <span class="fn">resolve</span>(<span class="str">"üì¶ Data from "</span> + url), <span class="num">800</span>)
  );
  
  <span class="kw">const</span> timeout = <span class="kw">new</span> <span class="fn">Promise</span>((_, reject) =>
    <span class="fn">setTimeout</span>(() => <span class="fn">reject</span>(<span class="str">"‚è∞ Timeout after "</span> + ms + <span class="str">"ms"</span>), ms)
  );
  
  <span class="kw">return</span> Promise.<span class="fn">race</span>([fetchPromise, timeout]);
}

<span class="cm">// This should succeed (800ms fetch < 1000ms timeout)</span>
<span class="fn">fetchWithTimeout</span>(<span class="str">"/api/data"</span>, <span class="num">1000</span>)
  .<span class="fn">then</span>(d => console.log(<span class="str">"‚úÖ"</span>, d))
  .<span class="fn">catch</span>(e => console.log(<span class="str">"‚ùå"</span>, e));

<span class="cm">// This should timeout (800ms fetch > 400ms timeout)</span>
<span class="fn">fetchWithTimeout</span>(<span class="str">"/api/slow"</span>, <span class="num">400</span>)
  .<span class="fn">then</span>(d => console.log(<span class="str">"‚úÖ"</span>, d))
  .<span class="fn">catch</span>(e => console.log(<span class="str">"‚ùå"</span>, e));</code></pre>
      <div class="output-area" id="output-ex4b"></div>
    </div>
  </div>

  <!-- PROMISE.ALLSETTLED -->
  <div class="card">
    <h2>üìã Promise.allSettled()</h2>
    <p>Waits for <strong>ALL</strong> promises to settle (fulfill or reject). <strong>Never short-circuits</strong>. Returns an array of outcome objects.</p>

    <div class="concept-box success">
      <h4>üìê Use when: You want results from ALL promises, even if some fail</h4>
      <p>Sending notifications to multiple users ‚Äî you want to know which succeeded and which failed.</p>
    </div>

    <div class="code-wrapper">
      <div class="code-header"><div class="code-dots"><span></span><span></span><span></span></div><span class="code-label">allSettled.js</span><button class="run-btn" onclick="runExample('ex4c')">‚ñ∂ Run</button></div>
      <pre><code id="code-ex4c"><span class="kw">const</span> promises = [
  Promise.<span class="fn">resolve</span>(<span class="str">"‚úÖ Email sent"</span>),
  Promise.<span class="fn">reject</span>(<span class="str">"‚ùå SMS failed"</span>),
  Promise.<span class="fn">resolve</span>(<span class="str">"‚úÖ Push sent"</span>),
];

Promise.<span class="fn">allSettled</span>(promises).<span class="fn">then</span>(results => {
  results.<span class="fn">forEach</span>((r, i) => {
    <span class="kw">if</span> (r.status === <span class="str">"fulfilled"</span>) {
      console.log(<span class="str">`Promise ${i+1}: ${r.value}`</span>);
    } <span class="kw">else</span> {
      console.log(<span class="str">`Promise ${i+1}: FAILED - ${r.reason}`</span>);
    }
  });
  
  <span class="kw">const</span> succeeded = results.<span class="fn">filter</span>(r => r.status === <span class="str">"fulfilled"</span>);
  console.log(<span class="str">`\n${succeeded.length}/${results.length} succeeded`</span>);
});</code></pre>
      <div class="output-area" id="output-ex4c"></div>
    </div>
  </div>

  <!-- PROMISE.ANY -->
  <div class="card">
    <h2>üéØ Promise.any()</h2>
    <p>Returns the <strong>first fulfilled</strong> promise. Ignores rejections unless ALL reject (then throws <span class="inline-code">AggregateError</span>).</p>

    <div class="code-wrapper">
      <div class="code-header"><div class="code-dots"><span></span><span></span><span></span></div><span class="code-label">promise-any.js</span><button class="run-btn" onclick="runExample('ex4d')">‚ñ∂ Run</button></div>
      <pre><code id="code-ex4d"><span class="cm">// Fastest successful mirror wins</span>
<span class="kw">const</span> mirrors = [
  <span class="kw">new</span> <span class="fn">Promise</span>((_, rej) => <span class="fn">setTimeout</span>(() => <span class="fn">rej</span>(<span class="str">"Mirror 1 down"</span>), <span class="num">100</span>)),
  <span class="kw">new</span> <span class="fn">Promise</span>(res => <span class="fn">setTimeout</span>(() => <span class="fn">res</span>(<span class="str">"üì¶ Mirror 2"</span>), <span class="num">300</span>)),
  <span class="kw">new</span> <span class="fn">Promise</span>(res => <span class="fn">setTimeout</span>(() => <span class="fn">res</span>(<span class="str">"üì¶ Mirror 3"</span>), <span class="num">500</span>)),
];

Promise.<span class="fn">any</span>(mirrors)
  .<span class="fn">then</span>(fastest => console.log(<span class="str">"First success:"</span>, fastest))
  .<span class="fn">catch</span>(err => console.log(<span class="str">"All failed!"</span>, err));</code></pre>
      <div class="output-area" id="output-ex4d"></div>
    </div>
  </div>

  <!-- COMPARISON TABLE -->
  <div class="card">
    <h2>üìä Comparison Table</h2>
    <div style="overflow-x:auto">
      <table class="compare-table">
        <thead>
          <tr><th>Method</th><th>Resolves when</th><th>Rejects when</th><th>Returns</th></tr>
        </thead>
        <tbody>
          <tr>
            <td><code>Promise.all</code></td>
            <td>ALL fulfill</td>
            <td>ANY one rejects</td>
            <td>Array of values</td>
          </tr>
          <tr>
            <td><code>Promise.race</code></td>
            <td>First settles (fulfill)</td>
            <td>First settles (reject)</td>
            <td>Single value/error</td>
          </tr>
          <tr>
            <td><code>Promise.allSettled</code></td>
            <td>ALL settle (always)</td>
            <td>Never rejects</td>
            <td>Array of {status, value/reason}</td>
          </tr>
          <tr>
            <td><code>Promise.any</code></td>
            <td>First fulfills</td>
            <td>ALL reject</td>
            <td>First fulfilled value</td>
          </tr>
        </tbody>
      </table>
    </div>
  </div>

  <!-- QUIZ -->
  <div class="quiz-section">
    <h3>üß† Quiz: Promise Methods</h3>

    <div class="quiz-q" id="q9">
      <p>9. What happens if one promise in Promise.all() rejects?</p>
      <div class="quiz-opts">
        <label class="quiz-opt" data-q="q9" data-val="a"><span class="radio"></span>It waits for all and returns partial results</label>
        <label class="quiz-opt" data-q="q9" data-val="b"><span class="radio"></span>The entire Promise.all rejects immediately</label>
        <label class="quiz-opt" data-q="q9" data-val="c"><span class="radio"></span>It ignores the failure and returns the rest</label>
        <label class="quiz-opt" data-q="q9" data-val="d"><span class="radio"></span>It retries the failed promise</label>
      </div>
      <div class="quiz-explain correct" id="q9-correct">‚úÖ Correct! Promise.all is "all or nothing." One rejection = the whole thing rejects. Use <code>Promise.allSettled()</code> if you need all results.</div>
      <div class="quiz-explain wrong" id="q9-wrong">‚ùå Promise.all <strong>rejects immediately</strong> when any promise rejects. It's an all-or-nothing approach.</div>
      <button class="quiz-check-btn" onclick="checkQuiz('q9','b',2)" disabled>Check Answer</button>
    </div>

    <div class="quiz-q" id="q10">
      <p>10. Which method should you use to implement a request timeout?</p>
      <div class="quiz-opts">
        <label class="quiz-opt" data-q="q10" data-val="a"><span class="radio"></span>Promise.all</label>
        <label class="quiz-opt" data-q="q10" data-val="b"><span class="radio"></span>Promise.race</label>
        <label class="quiz-opt" data-q="q10" data-val="c"><span class="radio"></span>Promise.allSettled</label>
        <label class="quiz-opt" data-q="q10" data-val="d"><span class="radio"></span>Promise.any</label>
      </div>
      <div class="quiz-explain correct" id="q10-correct">‚úÖ Correct! <code>Promise.race()</code> between a fetch and a timeout promise. Whichever settles first wins!</div>
      <div class="quiz-explain wrong" id="q10-wrong">‚ùå <code>Promise.race()</code> is perfect for timeouts ‚Äî race the fetch against a setTimeout that rejects. First to settle wins.</div>
      <button class="quiz-check-btn" onclick="checkQuiz('q10','b',2)" disabled>Check Answer</button>
    </div>

    <div class="quiz-q" id="q11">
      <p>11. What does Promise.allSettled return for a rejected promise?</p>
      <div class="quiz-opts">
        <label class="quiz-opt" data-q="q11" data-val="a"><span class="radio"></span>{ status: "rejected", value: error }</label>
        <label class="quiz-opt" data-q="q11" data-val="b"><span class="radio"></span>{ status: "rejected", reason: error }</label>
        <label class="quiz-opt" data-q="q11" data-val="c"><span class="radio"></span>{ error: error }</label>
        <label class="quiz-opt" data-q="q11" data-val="d"><span class="radio"></span>null</label>
      </div>
      <div class="quiz-explain correct" id="q11-correct">‚úÖ Correct! Rejected promises use <code>reason</code> (not <code>value</code>). Fulfilled ones use <code>{ status: "fulfilled", value: ... }</code>.</div>
      <div class="quiz-explain wrong" id="q11-wrong">‚ùå The format is <code>{ status: "rejected", reason: error }</code>. Note: fulfilled uses <code>value</code>, rejected uses <code>reason</code>.</div>
      <button class="quiz-check-btn" onclick="checkQuiz('q11','b',2)" disabled>Check Answer</button>
    </div>
  </div>
</div>

<!-- ===================== TAB 5: CHALLENGES ===================== -->
<div class="tab-content" id="tab-challenges">
  <div class="section-hero">
    <h2>üèÜ Coding Challenges</h2>
    <p>Put your promise skills to the test with hands-on exercises</p>
  </div>

  <!-- EXERCISE 1 -->
  <div class="exercise" id="exercise1">
    <h4>üí™ Challenge 1: Create a delay function</h4>
    <p>Write a function <span class="inline-code">delay(ms)</span> that returns a promise which resolves after <code>ms</code> milliseconds. Then use it to log "Hello" after 500ms.</p>
    <textarea id="ex-code-1" spellcheck="false">// Write your delay function here
function delay(ms) {
  // Your code here...
}

// Then use it:
delay(500).then(() => console.log("Hello after 500ms!"));</textarea>
    <div class="exercise-btns">
      <button class="btn-run-exercise" onclick="runExercise(1)">‚ñ∂ Run</button>
      <button class="btn-solution" onclick="showSolution(1)">üí° Show Solution</button>
    </div>
    <div class="exercise-output" id="ex-output-1"></div>
    <div class="exercise-result" id="ex-result-1"></div>
  </div>

  <!-- EXERCISE 2 -->
  <div class="exercise" id="exercise2">
    <h4>üí™ Challenge 2: Chain transformations</h4>
    <p>Start with <span class="inline-code">Promise.resolve(5)</span> and chain .then() calls to: multiply by 3, add 7, convert to string "Result: X". Log the final value.</p>
    <textarea id="ex-code-2" spellcheck="false">// Start with 5, multiply by 3, add 7, format as string
Promise.resolve(5)
  // Add your chain here...
</textarea>
    <div class="exercise-btns">
      <button class="btn-run-exercise" onclick="runExercise(2)">‚ñ∂ Run</button>
      <button class="btn-solution" onclick="showSolution(2)">üí° Show Solution</button>
    </div>
    <div class="exercise-output" id="ex-output-2"></div>
    <div class="exercise-result" id="ex-result-2"></div>
  </div>

  <!-- EXERCISE 3 -->
  <div class="exercise" id="exercise3">
    <h4>üí™ Challenge 3: Error recovery chain</h4>
    <p>Create a chain that: starts with <span class="inline-code">Promise.reject("error")</span>, catches the error and returns <span class="inline-code">"recovered"</span>, then logs the recovered value. The final output should be <code>"recovered"</code>.</p>
    <textarea id="ex-code-3" spellcheck="false">// Start with a rejection, recover with catch, then log
Promise.reject("error")
  // Add your chain here...
</textarea>
    <div class="exercise-btns">
      <button class="btn-run-exercise" onclick="runExercise(3)">‚ñ∂ Run</button>
      <button class="btn-solution" onclick="showSolution(3)">üí° Show Solution</button>
    </div>
    <div class="exercise-output" id="ex-output-3"></div>
    <div class="exercise-result" id="ex-result-3"></div>
  </div>

  <!-- EXERCISE 4 -->
  <div class="exercise" id="exercise4">
    <h4>üí™ Challenge 4: Load all resources with Promise.all</h4>
    <p>Create three promises that resolve with "CSS loaded", "JS loaded", and "Images loaded" after 200ms, 400ms, and 300ms respectively. Use <span class="inline-code">Promise.all()</span> to wait for all and log them.</p>
    <textarea id="ex-code-4" spellcheck="false">// Create three promises with different delays
// Use Promise.all to wait for all of them
// Log each result
</textarea>
    <div class="exercise-btns">
      <button class="btn-run-exercise" onclick="runExercise(4)">‚ñ∂ Run</button>
      <button class="btn-solution" onclick="showSolution(4)">üí° Show Solution</button>
    </div>
    <div class="exercise-output" id="ex-output-4"></div>
    <div class="exercise-result" id="ex-result-4"></div>
  </div>

  <!-- EXERCISE 5 -->
  <div class="exercise" id="exercise5">
    <h4>üí™ Challenge 5: Implement fetchWithTimeout</h4>
    <p>Create a <span class="inline-code">fetchWithTimeout(url, ms)</span> function using <span class="inline-code">Promise.race()</span>. Simulate the fetch with a promise that resolves in 600ms. Test it with a 1000ms timeout (should succeed) and a 300ms timeout (should fail).</p>
    <textarea id="ex-code-5" spellcheck="false">function fetchWithTimeout(url, ms) {
  // Simulate a fetch that takes 600ms
  const fakeFetch = new Promise(resolve => 
    setTimeout(() => resolve("Data from " + url), 600)
  );
  
  // Create a timeout promise
  // Use Promise.race to race them
  // Your code here...
}

// Test: should succeed (600ms < 1000ms)
fetchWithTimeout("/api/data", 1000)
  .then(d => console.log("‚úÖ", d))
  .catch(e => console.log("‚ùå", e));

// Test: should fail (600ms > 300ms) 
fetchWithTimeout("/api/data", 300)
  .then(d => console.log("‚úÖ", d))
  .catch(e => console.log("‚ùå", e));</textarea>
    <div class="exercise-btns">
      <button class="btn-run-exercise" onclick="runExercise(5)">‚ñ∂ Run</button>
      <button class="btn-solution" onclick="showSolution(5)">üí° Show Solution</button>
    </div>
    <div class="exercise-output" id="ex-output-5"></div>
    <div class="exercise-result" id="ex-result-5"></div>
  </div>

  <!-- EXERCISE 6 -->
  <div class="exercise" id="exercise6">
    <h4>üí™ Challenge 6: Sequential execution</h4>
    <p>Given an array of URLs, fetch them <strong>one after another</strong> (not in parallel) using promise chaining with <span class="inline-code">.reduce()</span>. Log each result as it completes.</p>
    <textarea id="ex-code-6" spellcheck="false">// Simulate fetching a URL
function fakeFetch(url) {
  return new Promise(resolve => 
    setTimeout(() => resolve("Got: " + url), 200)
  );
}

const urls = ["/api/users", "/api/posts", "/api/comments"];

// Execute fakeFetch for each URL sequentially
// using .reduce() and promise chaining
// Log each result
</textarea>
    <div class="exercise-btns">
      <button class="btn-run-exercise" onclick="runExercise(6)">‚ñ∂ Run</button>
      <button class="btn-solution" onclick="showSolution(6)">üí° Show Solution</button>
    </div>
    <div class="exercise-output" id="ex-output-6"></div>
    <div class="exercise-result" id="ex-result-6"></div>
  </div>

  <!-- FINAL QUIZ -->
  <div class="quiz-section">
    <h3>üèÜ Final Boss Quiz</h3>

    <div class="quiz-q" id="q12">
      <p>12. What is the output?</p>
      <div class="quiz-q q-code">console.log("A");
Promise.resolve().then(() => console.log("B"));
console.log("C");</div>
      <div class="quiz-opts">
        <label class="quiz-opt" data-q="q12" data-val="a"><span class="radio"></span>A, B, C</label>
        <label class="quiz-opt" data-q="q12" data-val="b"><span class="radio"></span>A, C, B</label>
        <label class="quiz-opt" data-q="q12" data-val="c"><span class="radio"></span>B, A, C</label>
        <label class="quiz-opt" data-q="q12" data-val="d"><span class="radio"></span>C, B, A</label>
      </div>
      <div class="quiz-explain correct" id="q12-correct">‚úÖ Correct! <code>.then()</code> callbacks are microtasks ‚Äî they run after all synchronous code finishes. So: A (sync), C (sync), then B (microtask).</div>
      <div class="quiz-explain wrong" id="q12-wrong">‚ùå The answer is A, C, B. Promise <code>.then()</code> callbacks are <strong>microtasks</strong> that run after the current synchronous code completes.</div>
      <button class="quiz-check-btn" onclick="checkQuiz('q12','b',2)" disabled>Check Answer</button>
    </div>

    <div class="quiz-q" id="q13">
      <p>13. What method would you use to check which promises succeed and which fail?</p>
      <div class="quiz-opts">
        <label class="quiz-opt" data-q="q13" data-val="a"><span class="radio"></span>Promise.all()</label>
        <label class="quiz-opt" data-q="q13" data-val="b"><span class="radio"></span>Promise.race()</label>
        <label class="quiz-opt" data-q="q13" data-val="c"><span class="radio"></span>Promise.allSettled()</label>
        <label class="quiz-opt" data-q="q13" data-val="d"><span class="radio"></span>Promise.any()</label>
      </div>
      <div class="quiz-explain correct" id="q13-correct">‚úÖ Correct! <code>Promise.allSettled()</code> waits for all promises and gives you each one's status, value, or reason.</div>
      <div class="quiz-explain wrong" id="q13-wrong">‚ùå <code>Promise.allSettled()</code> is the right choice ‚Äî it never short-circuits and reports the outcome of every promise.</div>
      <button class="quiz-check-btn" onclick="checkQuiz('q13','c',2)" disabled>Check Answer</button>
    </div>

    <div class="quiz-q" id="q14">
      <p>14. What is logged and in what order?</p>
      <div class="quiz-q q-code">Promise.resolve(1)
  .then(v => v + 1)
  .then(v => { throw new Error("fail") })
  .then(v => v + 1)
  .catch(e => 10)
  .then(v => console.log(v));</div>
      <div class="quiz-opts">
        <label class="quiz-opt" data-q="q14" data-val="a"><span class="radio"></span>3</label>
        <label class="quiz-opt" data-q="q14" data-val="b"><span class="radio"></span>10</label>
        <label class="quiz-opt" data-q="q14" data-val="c"><span class="radio"></span>Error: fail</label>
        <label class="quiz-opt" data-q="q14" data-val="d"><span class="radio"></span>undefined</label>
      </div>
      <div class="quiz-explain correct" id="q14-correct">‚úÖ Correct! The chain goes: 1 ‚Üí 2 ‚Üí throws ‚Üí skips .then ‚Üí catch returns 10 ‚Üí .then logs 10. The catch recovers the chain!</div>
      <div class="quiz-explain wrong" id="q14-wrong">‚ùå The answer is 10. After the error, the third .then is skipped. The catch returns 10, which becomes the value for the final .then.</div>
      <button class="quiz-check-btn" onclick="checkQuiz('q14','b',2)" disabled>Check Answer</button>
    </div>
  </div>
</div>

</main>

<!-- ============ JAVASCRIPT ============ -->
<script>
// ============ STATE ============
let score = 0;
const maxScore = 28; // 14 quiz questions √ó 2 points each
const answeredQuizzes = new Set();
const completedTabs = new Set();

// ============ TAB SYSTEM ============
const tabBtns = document.querySelectorAll('.tab-btn');
const tabContents = document.querySelectorAll('.tab-content');

tabBtns.forEach(btn => {
  btn.addEventListener('click', () => {
    const tab = btn.dataset.tab;
    tabBtns.forEach(b => b.classList.remove('active'));
    tabContents.forEach(c => c.classList.remove('active'));
    btn.classList.add('active');
    document.getElementById('tab-' + tab).classList.add('active');
    window.scrollTo({ top: 0, behavior: 'smooth' });
  });
});

// ============ QUIZ SYSTEM ============
document.querySelectorAll('.quiz-opt').forEach(opt => {
  opt.addEventListener('click', () => {
    const qId = opt.dataset.q;
    const qEl = document.getElementById(qId);
    if (qEl.classList.contains('answered-correct') || qEl.classList.contains('answered-wrong')) return;
    
    qEl.querySelectorAll('.quiz-opt').forEach(o => o.classList.remove('selected'));
    opt.classList.add('selected');
    qEl.querySelector('.quiz-check-btn').disabled = false;
  });
});

function checkQuiz(qId, correctAnswer, points) {
  const qEl = document.getElementById(qId);
  if (answeredQuizzes.has(qId)) return;
  
  const selected = qEl.querySelector('.quiz-opt.selected');
  if (!selected) return;
  
  const userAnswer = selected.dataset.val;
  answeredQuizzes.add(qId);
  
  // Disable all options
  qEl.querySelectorAll('.quiz-opt').forEach(o => o.classList.add('disabled'));
  qEl.querySelector('.quiz-check-btn').disabled = true;
  
  // Highlight correct answer
  qEl.querySelectorAll('.quiz-opt').forEach(o => {
    if (o.dataset.val === correctAnswer) o.classList.add('correct');
  });
  
  if (userAnswer === correctAnswer) {
    qEl.classList.add('answered-correct');
    document.getElementById(qId + '-correct').classList.add('show');
    score += points;
  } else {
    selected.classList.add('wrong');
    qEl.classList.add('answered-wrong');
    document.getElementById(qId + '-wrong').classList.add('show');
  }
  
  updateProgress();
}

function updateProgress() {
  document.getElementById('scoreBadge').textContent = score + ' / ' + maxScore + ' pts';
  const pct = Math.round((score / maxScore) * 100);
  document.getElementById('progressFill').style.width = pct + '%';
}

// ============ CODE RUNNER ============
function runExample(id) {
  const codeEl = document.getElementById('code-' + id);
  const outputEl = document.getElementById('output-' + id);
  outputEl.innerHTML = '';
  
  // Extract raw code text
  const code = codeEl.textContent;
  
  const addLine = (text, cls) => {
    const div = document.createElement('div');
    div.className = cls;
    div.textContent = text;
    outputEl.appendChild(div);
  };
  
  const origLog = console.log;
  const origError = console.error;
  const origWarn = console.warn;
  
  console.log = (...args) => {
    const msg = args.map(a => {
      if (a === undefined) return 'undefined';
      if (a === null) return 'null';
      if (typeof a === 'object') {
        try { return JSON.stringify(a); } catch(e) { return String(a); }
      }
      return String(a);
    }).join(' ');
    addLine(msg, 'log');
    origLog.apply(console, args);
  };
  
  console.error = (...args) => {
    const msg = args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' ');
    addLine(msg, 'err');
  };
  
  try {
    const fn = new Function(code);
    fn();
  } catch (e) {
    addLine('Error: ' + e.message, 'err');
  }
  
  setTimeout(() => {
    console.log = origLog;
    console.error = origError;
    console.warn = origWarn;
  }, 15000);
}

// ============ PROMISE STATES VISUALIZATION ============
let vizState = 'pending';

function vizResolve() {
  if (vizState !== 'pending') return;
  vizState = 'fulfilled';
  document.getElementById('stPending').classList.remove('active');
  document.getElementById('stPending').style.opacity = '.35';
  document.getElementById('stFulfilled').style.opacity = '1';
  document.getElementById('stFulfilled').classList.add('active');
  document.getElementById('arrow1').textContent = '‚Üí';
  setTimeout(() => document.getElementById('stFulfilled').classList.remove('active'), 2000);
}

function vizReject() {
  if (vizState !== 'pending') return;
  vizState = 'rejected';
  document.getElementById('stPending').classList.remove('active');
  document.getElementById('stPending').style.opacity = '.35';
  document.getElementById('stRejected').style.opacity = '1';
  document.getElementById('stRejected').classList.add('active');
  setTimeout(() => document.getElementById('stRejected').classList.remove('active'), 2000);
}

function vizReset() {
  vizState = 'pending';
  document.getElementById('stPending').classList.add('active');
  document.getElementById('stPending').style.opacity = '1';
  document.getElementById('stFulfilled').style.opacity = '.35';
  document.getElementById('stFulfilled').classList.remove('active');
  document.getElementById('stRejected').style.opacity = '.35';
  document.getElementById('stRejected').classList.remove('active');
}

// ============ CHAIN VISUALIZATION ============
let chainRunning = false;

function runChainViz() {
  if (chainRunning) return;
  chainRunning = true;
  resetChainViz();
  
  const steps = [
    { id: 'ch1', val: 'cv1', text: '{id:1, name:"Alice"}', delay: 600 },
    { id: 'ch2', val: 'cv2', text: '[order#42, order#73]', delay: 500 },
    { id: 'ch3', val: 'cv3', text: '{item:"Widget", $29}', delay: 400 },
    { id: 'ch4', val: 'cv4', text: '‚úÖ Displayed!', delay: 300 },
  ];
  
  let d = 200;
  steps.forEach((step, i) => {
    setTimeout(() => {
      document.getElementById(step.id).classList.add('active');
    }, d);
    
    d += step.delay;
    
    setTimeout(() => {
      document.getElementById(step.id).classList.remove('active');
      document.getElementById(step.id).classList.add('done');
      const valEl = document.getElementById(step.val);
      valEl.textContent = step.text;
      valEl.classList.add('show');
      if (i === steps.length - 1) chainRunning = false;
    }, d);
    
    d += 200;
  });
}

function resetChainViz() {
  for (let i = 1; i <= 4; i++) {
    document.getElementById('ch' + i).className = 'chain-box';
    const v = document.getElementById('cv' + i);
    v.textContent = '';
    v.classList.remove('show');
  }
  chainRunning = false;
}

// ============ PROMISE.ALL VISUALIZATION ============
let multiTimers = [];

function runAllViz(shouldFail) {
  resetMultiViz('all');
  const speeds = [70, 95, 55]; // iterations to 100%
  const failAt = shouldFail ? 60 : -1; // p2 fails at 60%
  const fills = [0, 0, 0];
  
  const result = document.getElementById('allResult');
  result.textContent = '‚è≥ Waiting for all promises...';
  result.style.color = 'var(--yellow2)';
  
  const timer = setInterval(() => {
    let allDone = true;
    for (let i = 0; i < 3; i++) {
      if (fills[i] < 100) {
        fills[i] = Math.min(100, fills[i] + (100 / speeds[i]));
        document.getElementById('allP' + (i+1)).style.width = fills[i] + '%';
        
        if (i === 1 && shouldFail && fills[i] >= failAt) {
          fills[i] = fills[i];
          document.getElementById('allP2').classList.add('error-fill');
          document.getElementById('allS2').textContent = '‚ùå';
          clearInterval(timer);
          result.textContent = '‚ùå Promise.all REJECTED! (Promise 2 failed)';
          result.style.color = 'var(--red2)';
          return;
        }
        
        if (fills[i] >= 100) {
          document.getElementById('allS' + (i+1)).textContent = '‚úÖ';
        } else {
          allDone = false;
        }
      }
    }
    
    if (allDone) {
      clearInterval(timer);
      result.textContent = '‚úÖ Promise.all RESOLVED! All 3 promises fulfilled.';
      result.style.color = 'var(--green2)';
    }
  }, 50);
  
  multiTimers.push(timer);
}

function runRaceViz() {
  resetMultiViz('race');
  const speeds = [140, 50, 90]; // iterations to 100%
  const fills = [0, 0, 0];
  let winner = -1;
  
  const result = document.getElementById('raceResult');
  result.textContent = 'üèÅ Racing...';
  result.style.color = 'var(--yellow2)';
  
  const timer = setInterval(() => {
    for (let i = 0; i < 3; i++) {
      if (fills[i] < 100) {
        fills[i] = Math.min(100, fills[i] + (100 / speeds[i]));
        document.getElementById('raceP' + (i+1)).style.width = fills[i] + '%';
      }
      
      if (fills[i] >= 100 && winner === -1) {
        winner = i;
        document.getElementById('raceS' + (i+1)).textContent = 'üèÜ';
        clearInterval(timer);
        const names = ['üê¢ Slow', 'üêá Fast', 'üêï Medium'];
        result.textContent = 'üèÜ Promise.race RESOLVED! Winner: ' + names[i];
        result.style.color = 'var(--green2)';
      }
    }
  }, 50);
  
  multiTimers.push(timer);
}

function resetMultiViz(prefix) {
  multiTimers.forEach(t => clearInterval(t));
  multiTimers = [];
  
  for (let i = 1; i <= 3; i++) {
    const fill = document.getElementById(prefix + 'P' + i);
    if (fill) {
      fill.style.width = '0%';
      fill.classList.remove('error-fill');
    }
    const status = document.getElementById(prefix + 'S' + i);
    if (status) status.textContent = '‚è≥';
  }
  
  const result = document.getElementById(prefix + 'Result');
  if (result) {
    result.textContent = 'Click "Run" to start';
    result.style.color = 'var(--text3)';
  }
}

// ============ EXERCISES ============
const solutions = {
  1: `function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

delay(500).then(() => console.log("Hello after 500ms!"));`,

  2: `Promise.resolve(5)
  .then(v => v * 3)
  .then(v => v + 7)
  .then(v => "Result: " + v)
  .then(v => console.log(v));`,

  3: `Promise.reject("error")
  .catch(e => {
    console.log("Caught:", e);
    return "recovered";
  })
  .then(v => console.log(v));`,

  4: `const css = new Promise(r => setTimeout(() => r("CSS loaded"), 200));
const js = new Promise(r => setTimeout(() => r("JS loaded"), 400));
const img = new Promise(r => setTimeout(() => r("Images loaded"), 300));

Promise.all([css, js, img]).then(results => {
  results.forEach(r => console.log(r));
  console.log("All resources loaded!");
});`,

  5: `function fetchWithTimeout(url, ms) {
  const fakeFetch = new Promise(resolve => 
    setTimeout(() => resolve("Data from " + url), 600)
  );
  
  const timeout = new Promise((_, reject) => 
    setTimeout(() => reject("Timeout after " + ms + "ms"), ms)
  );
  
  return Promise.race([fakeFetch, timeout]);
}

fetchWithTimeout("/api/data", 1000)
  .then(d => console.log("‚úÖ", d))
  .catch(e => console.log("‚ùå", e));

fetchWithTimeout("/api/data", 300)
  .then(d => console.log("‚úÖ", d))
  .catch(e => console.log("‚ùå", e));`,

  6: `function fakeFetch(url) {
  return new Promise(resolve => 
    setTimeout(() => resolve("Got: " + url), 200)
  );
}

const urls = ["/api/users", "/api/posts", "/api/comments"];

urls.reduce((chain, url) => {
  return chain.then(() => 
    fakeFetch(url).then(result => console.log(result))
  );
}, Promise.resolve())
.then(() => console.log("All done sequentially!"));`
};

function runExercise(num) {
  const code = document.getElementById('ex-code-' + num).value;
  const outputEl = document.getElementById('ex-output-' + num);
  const resultEl = document.getElementById('ex-result-' + num);
  outputEl.innerHTML = '';
  resultEl.className = 'exercise-result';
  resultEl.style.display = 'none';
  
  const addLine = (text, cls) => {
    const div = document.createElement('div');
    div.className = cls || 'log';
    div.textContent = text;
    outputEl.appendChild(div);
  };
  
  const origLog = console.log;
  const origError = console.error;
  const logs = [];
  
  console.log = (...args) => {
    const msg = args.map(a => {
      if (a === undefined) return 'undefined';
      if (a === null) return 'null';
      if (typeof a === 'object') {
        try { return JSON.stringify(a); } catch(e) { return String(a); }
      }
      return String(a);
    }).join(' ');
    logs.push(msg);
    addLine(msg, 'log');
    origLog.apply(console, args);
  };
  console.error = (...args) => {
    const msg = args.map(a => String(a)).join(' ');
    addLine(msg, 'err');
  };
  
  try {
    const fn = new Function(code);
    fn();
  } catch (e) {
    addLine('Error: ' + e.message, 'err');
    resultEl.textContent = '‚ùå Code has an error: ' + e.message;
    resultEl.className = 'exercise-result fail';
    resultEl.style.display = 'block';
  }
  
  // Check results after async code settles
  setTimeout(() => {
    console.log = origLog;
    console.error = origError;
    
    if (logs.length > 0) {
      resultEl.textContent = '‚úÖ Code executed! Check the output above.';
      resultEl.className = 'exercise-result pass';
      resultEl.style.display = 'block';
    }
  }, 3000);
}

function showSolution(num) {
  document.getElementById('ex-code-' + num).value = solutions[num];
}

// ============ INIT ============
updateProgress();
</script>
</body>
</html>