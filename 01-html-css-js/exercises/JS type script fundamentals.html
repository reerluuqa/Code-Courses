<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>TypeScript Mastery Hub</title>
<style>
*,*::before,*::after{box-sizing:border-box;margin:0;padding:0}
:root{
  --bg1:#0f0e17;--bg2:#1a1932;--bg3:#232246;--bg4:#2e2d52;
  --tx1:#fffffe;--tx2:#a7a9be;--tx3:#72738f;
  --blue:#7f5af0;--cyan:#2cb67d;--pink:#ff6e96;
  --orange:#ff8906;--red:#ef4444;--green:#22c55e;
  --yellow:#eab308;--border:#2e2d52;
  --code-bg:#0c0b14;--shadow:0 8px 32px rgba(0,0,0,.4);
  --radius:12px;
}
html{scroll-behavior:smooth}
body{font-family:'Segoe UI',system-ui,-apple-system,sans-serif;background:var(--bg1);color:var(--tx1);line-height:1.7;min-height:100vh}
a{color:var(--cyan);text-decoration:none}

/* LAYOUT */
#app{display:flex;min-height:100vh}
#sidebar{width:280px;background:var(--bg2);border-right:1px solid var(--border);position:fixed;top:0;left:0;height:100vh;overflow-y:auto;z-index:100;transition:transform .3s}
#sidebar::-webkit-scrollbar{width:4px}
#sidebar::-webkit-scrollbar-thumb{background:var(--blue);border-radius:4px}
#main{margin-left:280px;flex:1;min-width:0;padding:2rem 3rem 4rem}
.sidebar-header{padding:1.5rem;border-bottom:1px solid var(--border);text-align:center}
.sidebar-header h1{font-size:1.2rem;background:linear-gradient(135deg,var(--blue),var(--cyan));-webkit-background-clip:text;-webkit-text-fill-color:transparent;font-weight:800}
.sidebar-header .subtitle{font-size:.75rem;color:var(--tx3);margin-top:4px}

/* XP BAR */
.xp-section{padding:1rem 1.5rem;border-bottom:1px solid var(--border)}
.xp-bar-outer{height:8px;background:var(--bg4);border-radius:99px;overflow:hidden;margin-top:8px}
.xp-bar-inner{height:100%;background:linear-gradient(90deg,var(--blue),var(--cyan));border-radius:99px;transition:width .5s;width:0}
.xp-label{display:flex;justify-content:space-between;font-size:.75rem;color:var(--tx3)}
.xp-label .level{color:var(--orange);font-weight:700}
.stats-row{display:flex;gap:.5rem;margin-top:.5rem}
.stat-badge{font-size:.65rem;background:var(--bg4);padding:2px 8px;border-radius:99px;color:var(--tx2)}

/* NAV */
.nav-modules{padding:.75rem 0}
.nav-module{margin-bottom:4px}
.nav-module-title{display:flex;align-items:center;gap:10px;padding:.6rem 1.5rem;font-size:.85rem;font-weight:600;color:var(--tx2);cursor:pointer;transition:all .2s;border:none;background:none;width:100%;text-align:left}
.nav-module-title:hover{color:var(--tx1);background:var(--bg3)}
.nav-module-title.active{color:var(--cyan);background:var(--bg3)}
.nav-module-title .icon{font-size:1.1rem}
.nav-module-title .check{margin-left:auto;color:var(--green);font-size:.8rem;opacity:0;transition:opacity .3s}
.nav-module-title .check.done{opacity:1}
.nav-lessons{overflow:hidden;max-height:0;transition:max-height .3s}
.nav-lessons.open{max-height:600px}
.nav-lesson{display:flex;align-items:center;gap:8px;padding:.45rem 1.5rem .45rem 2.8rem;font-size:.78rem;color:var(--tx3);cursor:pointer;transition:all .2s;border:none;background:none;width:100%;text-align:left}
.nav-lesson:hover{color:var(--tx1);background:rgba(127,90,240,.1)}
.nav-lesson.active{color:var(--blue);font-weight:600}
.nav-lesson .dot{width:6px;height:6px;border-radius:50%;background:var(--tx3);flex-shrink:0;transition:all .2s}
.nav-lesson.active .dot{background:var(--blue);box-shadow:0 0 8px var(--blue)}
.nav-lesson.completed .dot{background:var(--green)}

/* HAMBURGER */
.hamburger{display:none;position:fixed;top:1rem;left:1rem;z-index:200;background:var(--bg3);border:1px solid var(--border);border-radius:8px;padding:8px 12px;font-size:1.2rem;cursor:pointer;color:var(--tx1)}

/* MAIN CONTENT */
.lesson-header{margin-bottom:2rem}
.lesson-header .breadcrumb{font-size:.8rem;color:var(--tx3);margin-bottom:.5rem}
.lesson-header .breadcrumb span{color:var(--blue)}
.lesson-header h2{font-size:2rem;font-weight:800;margin-bottom:.5rem;background:linear-gradient(135deg,var(--tx1),var(--tx2));-webkit-background-clip:text;-webkit-text-fill-color:transparent}
.lesson-header .lesson-desc{color:var(--tx2);font-size:1rem}

/* CONTENT BLOCKS */
.content-section{margin-bottom:2.5rem}
.content-section h3{font-size:1.3rem;font-weight:700;margin-bottom:1rem;color:var(--tx1);display:flex;align-items:center;gap:8px}
.content-section h3 .emoji{font-size:1.3rem}
.content-section p{color:var(--tx2);margin-bottom:1rem;font-size:.95rem}
.content-section ul,.content-section ol{color:var(--tx2);margin:0 0 1rem 1.5rem;font-size:.95rem}
.content-section li{margin-bottom:.4rem}
.content-section li code{background:var(--bg4);padding:2px 6px;border-radius:4px;font-size:.85rem;color:var(--pink);font-family:'Cascadia Code','Fira Code',monospace}

/* CODE BLOCKS */
.code-block{background:var(--code-bg);border:1px solid var(--border);border-radius:var(--radius);margin:1rem 0 1.5rem;overflow:hidden}
.code-header{display:flex;align-items:center;justify-content:space-between;padding:.5rem 1rem;background:var(--bg3);border-bottom:1px solid var(--border);font-size:.75rem;color:var(--tx3)}
.code-header .lang{display:flex;align-items:center;gap:6px}
.code-header .lang::before{content:'';width:8px;height:8px;border-radius:50%;background:var(--blue)}
.code-body{padding:1rem 1.25rem;overflow-x:auto;font-family:'Cascadia Code','Fira Code','JetBrains Mono',monospace;font-size:.85rem;line-height:1.8;white-space:pre;tab-size:2}
.code-body .kw{color:#c678dd}
.code-body .ts{color:#e5c07b}
.code-body .tp{color:#56b6c2}
.code-body .str{color:#98c379}
.code-body .num{color:#d19a66}
.code-body .cmt{color:#5c6370;font-style:italic}
.code-body .fn{color:#61afef}
.code-body .op{color:#c678dd}
.code-body .err{text-decoration:wavy underline var(--red);text-underline-offset:4px}

/* CARDS */
.info-card{background:var(--bg3);border:1px solid var(--border);border-radius:var(--radius);padding:1.25rem 1.5rem;margin:1.5rem 0}
.info-card.tip{border-left:4px solid var(--cyan)}
.info-card.warning{border-left:4px solid var(--orange)}
.info-card.danger{border-left:4px solid var(--red)}
.info-card.success{border-left:4px solid var(--green)}
.info-card .card-title{font-weight:700;font-size:.9rem;margin-bottom:.5rem;display:flex;align-items:center;gap:8px}
.info-card.tip .card-title{color:var(--cyan)}
.info-card.warning .card-title{color:var(--orange)}
.info-card.danger .card-title{color:var(--red)}
.info-card.success .card-title{color:var(--green)}
.info-card p,.info-card ul{font-size:.88rem;color:var(--tx2)}

/* KEY POINTS */
.key-points{display:grid;gap:.75rem;margin:1rem 0}
.key-point{display:flex;align-items:flex-start;gap:10px;background:var(--bg3);border-radius:8px;padding:.75rem 1rem}
.key-point .bullet{width:24px;height:24px;border-radius:50%;background:var(--blue);display:flex;align-items:center;justify-content:center;font-size:.7rem;font-weight:700;flex-shrink:0;margin-top:2px}
.key-point .text{color:var(--tx2);font-size:.88rem}

/* COMPARISON */
.comparison{display:grid;grid-template-columns:1fr 1fr;gap:1rem;margin:1.5rem 0}
.comparison .col{border-radius:var(--radius);padding:1.25rem;border:1px solid var(--border)}
.comparison .col.bad{background:rgba(239,68,68,.05);border-color:rgba(239,68,68,.3)}
.comparison .col.good{background:rgba(34,197,94,.05);border-color:rgba(34,197,94,.3)}
.comparison .col-title{font-weight:700;font-size:.85rem;margin-bottom:.75rem;display:flex;align-items:center;gap:6px}
.comparison .col.bad .col-title{color:var(--red)}
.comparison .col.good .col-title{color:var(--green)}

/* QUIZ */
.quiz-container{background:var(--bg2);border:1px solid var(--border);border-radius:var(--radius);padding:1.75rem;margin:1.5rem 0}
.quiz-container h4{font-size:1rem;margin-bottom:1rem;color:var(--tx1)}
.quiz-q{margin-bottom:1.5rem;padding-bottom:1.5rem;border-bottom:1px solid var(--border)}
.quiz-q:last-of-type{border-bottom:none;margin-bottom:1rem}
.quiz-q .q-text{font-size:.92rem;color:var(--tx1);margin-bottom:.75rem;font-weight:500}
.quiz-q .q-num{color:var(--blue);font-weight:700}
.quiz-options{display:flex;flex-direction:column;gap:.5rem}
.quiz-opt{display:flex;align-items:center;gap:10px;padding:.6rem 1rem;background:var(--bg3);border:2px solid transparent;border-radius:8px;cursor:pointer;transition:all .2s;font-size:.88rem;color:var(--tx2)}
.quiz-opt:hover{border-color:var(--blue);color:var(--tx1)}
.quiz-opt.selected{border-color:var(--blue);background:rgba(127,90,240,.1);color:var(--tx1)}
.quiz-opt.correct{border-color:var(--green)!important;background:rgba(34,197,94,.1)!important;color:var(--green)!important}
.quiz-opt.wrong{border-color:var(--red)!important;background:rgba(239,68,68,.1)!important;color:var(--red)!important}
.quiz-opt .radio{width:18px;height:18px;border-radius:50%;border:2px solid var(--tx3);flex-shrink:0;display:flex;align-items:center;justify-content:center;transition:all .2s}
.quiz-opt.selected .radio{border-color:var(--blue)}
.quiz-opt.selected .radio::after{content:'';width:8px;height:8px;border-radius:50%;background:var(--blue)}
.quiz-opt.correct .radio{border-color:var(--green)}
.quiz-opt.correct .radio::after{content:'‚úì';background:none;color:var(--green);font-size:.7rem;font-weight:700}
.quiz-opt.wrong .radio{border-color:var(--red)}
.quiz-opt.wrong .radio::after{content:'‚úó';background:none;color:var(--red);font-size:.7rem;font-weight:700}
.quiz-explanation{margin-top:.75rem;padding:.75rem 1rem;background:var(--bg4);border-radius:8px;font-size:.82rem;color:var(--tx2);display:none}
.quiz-explanation.show{display:block}
.quiz-explanation.correct{border-left:3px solid var(--green)}
.quiz-explanation.wrong{border-left:3px solid var(--red)}

/* EXERCISE */
.exercise-box{background:var(--bg2);border:2px solid var(--blue);border-radius:var(--radius);padding:1.5rem;margin:1.5rem 0}
.exercise-box h4{color:var(--blue);margin-bottom:.5rem;display:flex;align-items:center;gap:8px}
.exercise-box .instructions{color:var(--tx2);font-size:.9rem;margin-bottom:1rem}
.exercise-input{width:100%;background:var(--code-bg);border:1px solid var(--border);border-radius:8px;padding:.75rem 1rem;color:var(--tx1);font-family:'Cascadia Code','Fira Code',monospace;font-size:.85rem;line-height:1.6;resize:vertical;min-height:80px;outline:none;transition:border-color .2s}
.exercise-input:focus{border-color:var(--blue)}
.exercise-input::placeholder{color:var(--tx3)}
.exercise-feedback{margin-top:.75rem;padding:.6rem 1rem;border-radius:8px;font-size:.85rem;display:none}
.exercise-feedback.show{display:block}
.exercise-feedback.correct{background:rgba(34,197,94,.1);color:var(--green);border:1px solid rgba(34,197,94,.3)}
.exercise-feedback.wrong{background:rgba(239,68,68,.1);color:var(--red);border:1px solid rgba(239,68,68,.3)}

/* BUTTONS */
.btn{padding:.6rem 1.5rem;border-radius:8px;border:none;font-size:.88rem;font-weight:600;cursor:pointer;transition:all .2s;display:inline-flex;align-items:center;gap:6px}
.btn:hover{transform:translateY(-1px)}
.btn-primary{background:var(--blue);color:#fff}
.btn-primary:hover{background:#6b4fd4;box-shadow:0 4px 15px rgba(127,90,240,.3)}
.btn-success{background:var(--cyan);color:#fff}
.btn-success:hover{background:#24a06a}
.btn-outline{background:transparent;border:1px solid var(--border);color:var(--tx2)}
.btn-outline:hover{border-color:var(--blue);color:var(--blue)}
.btn-sm{padding:.4rem 1rem;font-size:.8rem}

/* NAVIGATION BUTTONS */
.lesson-nav{display:flex;justify-content:space-between;align-items:center;margin-top:3rem;padding-top:2rem;border-top:1px solid var(--border)}

/* PITFALL CARDS */
.pitfall-card{background:var(--bg2);border:1px solid var(--border);border-radius:var(--radius);margin:1rem 0;overflow:hidden}
.pitfall-header{display:flex;align-items:center;gap:10px;padding:1rem 1.25rem;cursor:pointer;transition:background .2s}
.pitfall-header:hover{background:var(--bg3)}
.pitfall-header .warning-icon{font-size:1.2rem}
.pitfall-header .title{font-weight:600;font-size:.92rem;flex:1}
.pitfall-header .toggle{color:var(--tx3);transition:transform .3s}
.pitfall-header .toggle.open{transform:rotate(180deg)}
.pitfall-body{padding:0 1.25rem;max-height:0;overflow:hidden;transition:all .3s}
.pitfall-body.open{padding:0 1.25rem 1.25rem;max-height:800px}

/* TYPE VISUALIZER */
.type-visual{display:flex;flex-wrap:wrap;gap:8px;margin:1rem 0}
.type-tag{padding:.3rem .8rem;border-radius:20px;font-size:.8rem;font-family:'Cascadia Code',monospace;font-weight:600}
.type-tag.primitive{background:rgba(86,182,194,.15);color:#56b6c2;border:1px solid rgba(86,182,194,.3)}
.type-tag.special{background:rgba(198,120,221,.15);color:#c678dd;border:1px solid rgba(198,120,221,.3)}
.type-tag.composite{background:rgba(229,192,123,.15);color:#e5c07b;border:1px solid rgba(229,192,123,.3)}
.type-tag.utility{background:rgba(44,182,125,.15);color:#2cb67d;border:1px solid rgba(44,182,125,.3)}

/* PROGRESS COMPLETE */
.completion-banner{text-align:center;padding:3rem 2rem;background:linear-gradient(135deg,rgba(127,90,240,.1),rgba(44,182,125,.1));border:1px solid var(--border);border-radius:var(--radius);margin:2rem 0}
.completion-banner .big-icon{font-size:4rem;margin-bottom:1rem}
.completion-banner h3{font-size:1.5rem;margin-bottom:.5rem}
.completion-banner p{color:var(--tx2)}

/* ANIMATIONS */
@keyframes fadeIn{from{opacity:0;transform:translateY(10px)}to{opacity:1;transform:translateY(0)}}
@keyframes slideIn{from{transform:translateX(-20px);opacity:0}to{transform:translateX(0);opacity:1}}
@keyframes pulse{0%,100%{transform:scale(1)}50%{transform:scale(1.05)}}
@keyframes confetti{0%{transform:translateY(0) rotate(0)}100%{transform:translateY(-20px) rotate(360deg)}}
.fade-in{animation:fadeIn .4s ease}
.slide-in{animation:slideIn .3s ease}
.xp-pop{animation:pulse .3s ease}

/* TABLE */
.ts-table{width:100%;border-collapse:collapse;margin:1rem 0;font-size:.88rem}
.ts-table th{background:var(--bg3);padding:.6rem 1rem;text-align:left;font-weight:600;color:var(--tx1);border:1px solid var(--border)}
.ts-table td{padding:.6rem 1rem;border:1px solid var(--border);color:var(--tx2)}
.ts-table code{background:var(--bg4);padding:1px 5px;border-radius:3px;color:var(--pink);font-size:.82rem}

/* RESPONSIVE */
@media(max-width:900px){
  #sidebar{transform:translateX(-100%)}
  #sidebar.open{transform:translateX(0)}
  #main{margin-left:0;padding:1.5rem 1rem 3rem}
  .hamburger{display:block}
  .comparison{grid-template-columns:1fr}
  .lesson-header h2{font-size:1.5rem}
}
@media(max-width:600px){
  .lesson-header h2{font-size:1.3rem}
  #main{padding:1rem .75rem 3rem}
}
</style>
</head>
<body>

<button class="hamburger" onclick="toggleSidebar()">‚ò∞</button>

<div id="app">
  <nav id="sidebar">
    <div class="sidebar-header">
      <h1>‚ö° TypeScript Mastery</h1>
      <div class="subtitle">Interactive Learning Hub</div>
    </div>
    <div class="xp-section">
      <div class="xp-label">
        <span class="level" id="level-label">Level 1</span>
        <span id="xp-label">0 / 100 XP</span>
      </div>
      <div class="xp-bar-outer"><div class="xp-bar-inner" id="xp-bar"></div></div>
      <div class="stats-row">
        <span class="stat-badge" id="completed-count">‚úÖ 0 completed</span>
        <span class="stat-badge" id="quiz-score">üéØ 0% accuracy</span>
      </div>
    </div>
    <div class="nav-modules" id="nav-modules"></div>
  </nav>
  <main id="main"></main>
</div>

<script>
// ============== SYNTAX HIGHLIGHTER ==============
function hl(code) {
  const tokens = [];
  let ti = 0;
  function tok(html) {
    const ph = '\x00' + ti + '\x00';
    tokens.push(html);
    ti++;
    return ph;
  }
  code = code.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
  code = code.replace(/\/\/.*/g, m => tok(`<span class="cmt">${m}</span>`));
  code = code.replace(/(["'`])(?:(?!\1)[^\\]|\\.)*?\1/g, m => tok(`<span class="str">${m}</span>`));
  code = code.replace(/\b(const|let|var|function|return|if|else|for|while|class|extends|implements|import|export|default|new|typeof|instanceof|switch|case|break|continue|throw|try|catch|finally|async|await|from|of|in|do|yield)\b/g, '<span class="kw">$1</span>');
  code = code.replace(/\b(type|interface|enum|namespace|declare|abstract|readonly|keyof|infer|private|protected|public|static|as|is|asserts|satisfies|override)\b/g, '<span class="ts">$1</span>');
  code = code.replace(/\b(string|number|boolean|void|never|any|unknown|object|null|undefined|true|false|Array|Promise|Record|Partial|Required|Pick|Omit|Exclude|Extract|ReturnType|Readonly|Map|Set|Date)\b/g, '<span class="tp">$1</span>');
  code = code.replace(/\b(\d+\.?\d*)\b/g, '<span class="num">$1</span>');
  code = code.replace(/([a-zA-Z_$][\w$]*)\s*(?=\()/g, '<span class="fn">$1</span>');
  tokens.forEach((h, i) => { code = code.replace('\x00' + i + '\x00', h); });
  return code;
}

function codeBlock(code, label = 'TypeScript', errLines = []) {
  let lines = code.split('\n');
  if (lines[0] === '') lines.shift();
  // find min indent
  const minIndent = lines.filter(l => l.trim()).reduce((min, l) => {
    const indent = l.match(/^\s*/)[0].length;
    return indent < min ? indent : min;
  }, Infinity);
  lines = lines.map(l => l.slice(minIndent === Infinity ? 0 : minIndent));
  code = lines.join('\n').trimEnd();
  const highlighted = hl(code);
  return `<div class="code-block fade-in"><div class="code-header"><span class="lang">${label}</span></div><div class="code-body">${highlighted}</div></div>`;
}

// ============== STATE ==============
const state = {
  currentModule: 0,
  currentLesson: 0,
  xp: 0,
  level: 1,
  completed: new Set(),
  quizAnswers: {},
  totalCorrect: 0,
  totalAnswered: 0
};

function addXP(amount) {
  state.xp += amount;
  const needed = state.level * 100;
  if (state.xp >= needed) {
    state.xp -= needed;
    state.level++;
  }
  updateXP();
}

function updateXP() {
  const needed = state.level * 100;
  document.getElementById('xp-bar').style.width = (state.xp / needed * 100) + '%';
  document.getElementById('xp-label').textContent = state.xp + ' / ' + needed + ' XP';
  document.getElementById('level-label').textContent = 'Level ' + state.level;
  document.getElementById('completed-count').textContent = '‚úÖ ' + state.completed.size + ' completed';
  const acc = state.totalAnswered > 0 ? Math.round(state.totalCorrect / state.totalAnswered * 100) : 0;
  document.getElementById('quiz-score').textContent = 'üéØ ' + acc + '% accuracy';
}

function markComplete(key) {
  if (!state.completed.has(key)) {
    state.completed.add(key);
    addXP(25);
    renderNav();
  }
}

// ============== MODULES DATA ==============
const modules = [
{
  id: 'basic-types', title: 'Basic Types', icon: 'üî§',
  lessons: [
  {
    id: 'primitives', title: 'Primitive Types',
    render: () => `
      <div class="lesson-header">
        <div class="breadcrumb">Module 1 ‚Üí <span>Primitive Types</span></div>
        <h2>üî§ The Three Pillars: string, number, boolean</h2>
        <p class="lesson-desc">TypeScript adds static types to JavaScript. Let's start with the three most fundamental types.</p>
      </div>

      <div class="content-section">
        <h3><span class="emoji">üìñ</span> Type Annotations</h3>
        <p>In TypeScript, you can <strong>explicitly annotate</strong> variables with types using a colon (<code>:</code>) after the variable name. TypeScript can also <strong>infer</strong> the type automatically.</p>

        ${codeBlock(`
// Explicit type annotations
let username: string = "Alice";
let age: number = 28;
let isActive: boolean = true;

// Type inference - TS figures it out!
let city = "Tokyo";       // inferred as string
let score = 99.5;         // inferred as number
let isDone = false;        // inferred as boolean

// This will cause an ERROR:
// username = 42;  // Type 'number' is not assignable to type 'string'
        `)}

        <div class="info-card tip">
          <div class="card-title">üí° Pro Tip</div>
          <p>Prefer <strong>type inference</strong> when the type is obvious. Use explicit annotations when the type isn't clear from the value, or when declaring without initializing.</p>
        </div>

        <h3><span class="emoji">üéØ</span> When to Use Explicit Annotations</h3>
        ${codeBlock(`
// ‚úÖ Good: Use annotation when declaring without value
let email: string;
email = "alice@example.com";

// ‚úÖ Good: Function parameters ALWAYS need annotations
function greet(name: string): string {
  return "Hello, " + name;
}

// ‚úÖ Good: When type isn't obvious
let data: number = JSON.parse("42");

// ‚ùå Unnecessary: Type is obvious from the value
let name: string = "Bob";  // Just use: let name = "Bob"
        `)}
      </div>

      <div class="content-section">
        <h3><span class="emoji">üß©</span> Type Visual Map</h3>
        <div class="type-visual">
          <span class="type-tag primitive">string</span>
          <span class="type-tag primitive">number</span>
          <span class="type-tag primitive">boolean</span>
          <span class="type-tag primitive">bigint</span>
          <span class="type-tag primitive">symbol</span>
          <span class="type-tag special">null</span>
          <span class="type-tag special">undefined</span>
        </div>
        <p>These are the <strong>primitive types</strong> in TypeScript ‚Äî they correspond directly to JavaScript primitives.</p>
      </div>

      ${quizBlock('q-prim', [
        {
          q: 'What will TypeScript infer for: <code>let x = 42;</code>',
          opts: ['string', 'number', 'any', 'integer'],
          correct: 1,
          explanation: 'TypeScript infers `number` from the numeric literal 42. Note: there is no `integer` type in TypeScript ‚Äî all numbers are `number`.'
        },
        {
          q: 'Which line will cause a TypeScript error?',
          opts: [
            'let a: string = "hello"',
            'let b: number = 3.14',
            'let c: boolean = "true"',
            'let d = false'
          ],
          correct: 2,
          explanation: '"true" is a string, not a boolean. TypeScript will error: Type \'string\' is not assignable to type \'boolean\'.'
        }
      ])}

      ${exerciseBlock('ex-prim', 
        'Add type annotations to these variable declarations:',
        'let name = "Alice";\nlet age = 30;\nlet active = true;',
        'let name: string = "Alice";\nlet age: number = 30;\nlet active: boolean = true;',
        'Add : string, : number, and : boolean annotations after the variable names.'
      )}
    `
  },
  {
    id: 'arrays-tuples', title: 'Arrays & Tuples',
    render: () => `
      <div class="lesson-header">
        <div class="breadcrumb">Module 1 ‚Üí <span>Arrays & Tuples</span></div>
        <h2>üì¶ Arrays & Tuples</h2>
        <p class="lesson-desc">Learn how to type collections of values with arrays and fixed-length tuples.</p>
      </div>

      <div class="content-section">
        <h3><span class="emoji">üìã</span> Typed Arrays</h3>
        <p>There are two equivalent syntaxes for typing arrays:</p>

        ${codeBlock(`
// Syntax 1: Type[] (preferred)
let numbers: number[] = [1, 2, 3, 4, 5];
let names: string[] = ["Alice", "Bob"];

// Syntax 2: Array<Type> (generic syntax)
let scores: Array<number> = [95, 87, 92];

// Arrays enforce element types
numbers.push(6);       // ‚úÖ OK
// numbers.push("seven"); // ‚ùå Error!

// Array of objects
let users: { name: string; age: number }[] = [
  { name: "Alice", age: 28 },
  { name: "Bob", age: 32 }
];
        `)}

        <h3><span class="emoji">üìå</span> Tuples ‚Äî Fixed-Length Arrays</h3>
        <p>Tuples let you express an array with a <strong>fixed number of elements</strong> where each element has a <strong>known type</strong>.</p>

        ${codeBlock(`
// Tuple: exactly 2 elements [string, number]
let person: [string, number] = ["Alice", 28];

// Access like arrays
console.log(person[0]); // "Alice" (string)
console.log(person[1]); // 28 (number)

// Tuple with labels (documentation only)
type Coordinate = [x: number, y: number, z: number];
let point: Coordinate = [10, 20, 30];

// Tuple with optional element
type FlexPoint = [number, number, number?];
let point2D: FlexPoint = [1, 2];
let point3D: FlexPoint = [1, 2, 3];

// ‚ùå Common tuple mistakes
// let bad: [string, number] = [28, "Alice"];  // Wrong order!
// let bad2: [string, number] = ["Alice"];      // Missing element!
        `)}

        <div class="info-card warning">
          <div class="card-title">‚ö†Ô∏è Tuple Gotcha</div>
          <p>Tuples in TypeScript still allow <code>push()</code> at runtime ‚Äî TypeScript won't stop you from pushing extra elements! Use <code>readonly</code> tuples for true immutability.</p>
        </div>

        ${codeBlock(`
// Readonly tuple ‚Äî truly immutable
let pair: readonly [string, number] = ["Alice", 28];
// pair.push("extra");  // ‚ùå Error: Property 'push' does not exist
// pair[0] = "Bob";     // ‚ùå Error: Cannot assign to '0'
        `)}
      </div>

      ${quizBlock('q-arrays', [
        {
          q: 'What is the type of <code>let arr = [1, "two", 3]</code>?',
          opts: ['number[]', 'string[]', '(string | number)[]', 'tuple'],
          correct: 2,
          explanation: 'TypeScript infers a union array (string | number)[] when mixing types in an array literal.'
        },
        {
          q: 'Which is a valid tuple declaration?',
          opts: [
            'let t: [string] = ["a", "b"]',
            'let t: [string, number] = ["hi", 5]',
            'let t: [number] = [1, 2, 3]',
            'let t: tuple = [1, "a"]'
          ],
          correct: 1,
          explanation: 'Tuple [string, number] expects exactly one string and one number in that order.'
        }
      ])}
    `
  },
  {
    id: 'enums', title: 'Enums',
    render: () => `
      <div class="lesson-header">
        <div class="breadcrumb">Module 1 ‚Üí <span>Enums</span></div>
        <h2>üè∑Ô∏è Enums</h2>
        <p class="lesson-desc">Named constants that make your code more readable and maintainable.</p>
      </div>

      <div class="content-section">
        <h3><span class="emoji">üî¢</span> Numeric Enums</h3>
        ${codeBlock(`
// Auto-incrementing numeric values (starts at 0)
enum Direction {
  Up,      // 0
  Down,    // 1
  Left,    // 2
  Right    // 3
}

let move: Direction = Direction.Up;
console.log(move);              // 0
console.log(Direction[0]);      // "Up" (reverse mapping)

// Custom starting value
enum StatusCode {
  OK = 200,
  NotFound = 404,
  ServerError = 500
}
        `)}

        <h3><span class="emoji">üî§</span> String Enums (Preferred!)</h3>
        ${codeBlock(`
// String enums are more readable in debugging
enum Color {
  Red = "RED",
  Green = "GREEN",
  Blue = "BLUE"
}

let favorite: Color = Color.Blue;
console.log(favorite); // "BLUE" ‚Äî much more readable!

// Use in functions
function paint(color: Color): string {
  return "Painting with " + color;
}
paint(Color.Red);    // ‚úÖ OK
// paint("RED");     // ‚ùå Error! Must use the enum
        `)}

        <h3><span class="emoji">‚ö°</span> Const Enums (Performance)</h3>
        ${codeBlock(`
// const enums are inlined at compile time
const enum Size {
  Small = "S",
  Medium = "M",
  Large = "L"
}

let shirt = Size.Medium;
// Compiles to: let shirt = "M"  (no enum object at runtime!)
        `)}

        <div class="info-card tip">
          <div class="card-title">üí° Modern Alternative: Union Literal Types</div>
          <p>Many TypeScript developers prefer union types over enums for simpler use cases:</p>
        </div>

        ${codeBlock(`
// Instead of enum:
type Direction = "up" | "down" | "left" | "right";

let move: Direction = "up";    // ‚úÖ Clean and simple!
// move = "diagonal";          // ‚ùå Error

// Works great for function params
function navigate(dir: Direction) { /* ... */ }
        `)}
      </div>

      ${quizBlock('q-enums', [
        {
          q: 'What is the value of <code>Direction.Down</code> in a default numeric enum <code>enum Direction { Up, Down, Left, Right }</code>?',
          opts: ['0', '1', '"Down"', 'undefined'],
          correct: 1,
          explanation: 'Numeric enums auto-increment from 0. Up=0, Down=1, Left=2, Right=3.'
        }
      ])}
    `
  },
  {
    id: 'special-types', title: 'Special Types',
    render: () => `
      <div class="lesson-header">
        <div class="breadcrumb">Module 1 ‚Üí <span>Special Types</span></div>
        <h2>üåÄ Special Types: any, unknown, void, never</h2>
        <p class="lesson-desc">Understanding TypeScript's special types is crucial for writing safe, correct code.</p>
      </div>

      <div class="content-section">
        <h3><span class="emoji">üö´</span> any ‚Äî The Escape Hatch</h3>
        <p><code>any</code> disables ALL type checking. It's basically JavaScript mode.</p>

        ${codeBlock(`
let anything: any = "hello";
anything = 42;          // ‚úÖ No error
anything = true;        // ‚úÖ No error
anything.foo.bar.baz;   // ‚úÖ No error (but will crash at runtime!)
anything();             // ‚úÖ No error (but will crash at runtime!)
        `)}

        <div class="info-card danger">
          <div class="card-title">üö® Avoid <code>any</code>!</div>
          <p>Using <code>any</code> defeats the purpose of TypeScript. Every <code>any</code> in your code is a potential runtime bug. Use <code>unknown</code> instead when you don't know the type.</p>
        </div>

        <h3><span class="emoji">üîí</span> unknown ‚Äî The Safe Alternative</h3>
        <p><code>unknown</code> is the type-safe counterpart of <code>any</code>. You must narrow the type before using it.</p>

        ${codeBlock(`
let value: unknown = "hello";

// ‚ùå Can't use directly
// value.toUpperCase();     // Error!
// let len = value.length;  // Error!

// ‚úÖ Must narrow first
if (typeof value === "string") {
  console.log(value.toUpperCase()); // Now TS knows it's a string!
}

// ‚úÖ Type assertion (use carefully)
let str = value as string;
console.log(str.toUpperCase());
        `)}

        <h3><span class="emoji">üí®</span> void ‚Äî Returns Nothing</h3>
        ${codeBlock(`
// void = function returns nothing
function logMessage(msg: string): void {
  console.log(msg);
  // No return statement (or return undefined)
}

// void is NOT the same as undefined
let x: void = undefined;  // ‚úÖ OK
// let y: void = null;     // ‚ùå Error (with strictNullChecks)
        `)}

        <h3><span class="emoji">‚õî</span> never ‚Äî Impossible Values</h3>
        ${codeBlock(`
// never = function never returns
function throwError(msg: string): never {
  throw new Error(msg);  // Always throws, never returns
}

function infiniteLoop(): never {
  while (true) {}  // Never terminates
}

// never in exhaustive checks
type Shape = "circle" | "square";

function getArea(shape: Shape): number {
  switch (shape) {
    case "circle": return 3.14;
    case "square": return 4;
    default:
      // If we add a new shape but forget to handle it,
      // TypeScript will error here!
      const _exhaustive: never = shape;
      return _exhaustive;
  }
}
        `)}

        <div class="content-section">
          <h3><span class="emoji">üìä</span> Comparison Table</h3>
          <table class="ts-table">
            <thead>
              <tr><th>Type</th><th>Can assign anything?</th><th>Can use freely?</th><th>Use when</th></tr>
            </thead>
            <tbody>
              <tr><td><code>any</code></td><td>‚úÖ Yes</td><td>‚úÖ Yes (unsafe!)</td><td>Last resort / migration</td></tr>
              <tr><td><code>unknown</code></td><td>‚úÖ Yes</td><td>‚ùå Must narrow first</td><td>Unknown input (APIs, etc.)</td></tr>
              <tr><td><code>void</code></td><td>‚ùå Only undefined</td><td>N/A</td><td>Functions with no return</td></tr>
              <tr><td><code>never</code></td><td>‚ùå Nothing</td><td>N/A</td><td>Impossible states / throws</td></tr>
            </tbody>
          </table>
        </div>
      </div>

      ${quizBlock('q-special', [
        {
          q: 'What is the main difference between <code>any</code> and <code>unknown</code>?',
          opts: [
            'They are identical',
            'unknown requires type narrowing before use',
            'any is safer than unknown',
            'unknown only works with strings'
          ],
          correct: 1,
          explanation: 'unknown forces you to check (narrow) the type before you can use the value, making it much safer than any.'
        },
        {
          q: 'When should you use the <code>never</code> type?',
          opts: [
            'When a variable might be null',
            'When a function always throws or never terminates',
            'When you want to skip type checking',
            'When a function returns undefined'
          ],
          correct: 1,
          explanation: 'never represents values that never occur ‚Äî functions that always throw errors or have infinite loops.'
        }
      ])}
    `
  },
  {
    id: 'unions-intersections', title: 'Union & Intersection',
    render: () => `
      <div class="lesson-header">
        <div class="breadcrumb">Module 1 ‚Üí <span>Union & Intersection Types</span></div>
        <h2>üîÄ Union & Intersection Types</h2>
        <p class="lesson-desc">Combine types to create flexible and powerful type definitions.</p>
      </div>

      <div class="content-section">
        <h3><span class="emoji">üîÄ</span> Union Types (A | B)</h3>
        <p>A value that can be <strong>one of several types</strong>. Think "OR".</p>

        ${codeBlock(`
// Value can be string OR number
let id: string | number;
id = "abc-123";  // ‚úÖ
id = 42;         // ‚úÖ
// id = true;    // ‚ùå Error

// Common pattern: nullable types
let name: string | null = null;
name = "Alice";

// Union in function parameters
function formatId(id: string | number): string {
  // Must narrow before using type-specific methods
  if (typeof id === "string") {
    return id.toUpperCase();
  } else {
    return "#" + id.toString();
  }
}

formatId("abc");  // "ABC"
formatId(123);    // "#123"
        `)}

        <h3><span class="emoji">üîó</span> Intersection Types (A & B)</h3>
        <p>A value that must satisfy <strong>ALL types combined</strong>. Think "AND".</p>

        ${codeBlock(`
type HasName = { name: string };
type HasAge = { age: number };
type HasEmail = { email: string };

// Person must have ALL properties
type Person = HasName & HasAge & HasEmail;

const user: Person = {
  name: "Alice",
  age: 28,
  email: "alice@example.com"
  // Must include ALL three!
};
        `)}

        <h3><span class="emoji">üîç</span> Type Narrowing (Essential!)</h3>
        <p>When you have a union type, you need to <strong>narrow</strong> it before using type-specific operations.</p>

        ${codeBlock(`
function process(value: string | number | boolean) {
  // typeof narrowing
  if (typeof value === "string") {
    console.log(value.toUpperCase()); // TS knows it's string here
  } else if (typeof value === "number") {
    console.log(value.toFixed(2));    // TS knows it's number here
  } else {
    console.log(value);               // TS knows it's boolean here
  }
}

// instanceof narrowing (for classes)
function printDate(date: string | Date) {
  if (date instanceof Date) {
    console.log(date.toISOString());
  } else {
    console.log(date);
  }
}

// "in" narrowing (for objects)
type Fish = { swim: () => void };
type Bird = { fly: () => void };

function move(animal: Fish | Bird) {
  if ("swim" in animal) {
    animal.swim();  // TS knows it's Fish
  } else {
    animal.fly();   // TS knows it's Bird
  }
}
        `)}
      </div>

      ${quizBlock('q-unions', [
        {
          q: 'What does <code>string | number</code> mean?',
          opts: [
            'A value that is both string and number',
            'A value that is either string or number',
            'A new type called "string number"',
            'An array of strings and numbers'
          ],
          correct: 1,
          explanation: 'Union types (|) mean the value can be one type OR the other.'
        },
        {
          q: 'What does <code>A & B</code> create?',
          opts: [
            'A type with properties from A or B',
            'A type with properties from both A and B',
            'An array type',
            'A conditional type'
          ],
          correct: 1,
          explanation: 'Intersection types (&) combine all properties from all types ‚Äî the result must satisfy both A and B.'
        }
      ])}

      ${exerciseBlock('ex-unions',
        'Create a function type annotation that accepts either a string or number array:',
        'function first(arr) {\n  return arr[0];\n}',
        'function first(arr: string[] | number[]): string | number {\n  return arr[0];\n}',
        'The parameter should be string[] | number[] and return type string | number'
      )}
    `
  },
  {
    id: 'assertions-literals', title: 'Assertions & Literals',
    render: () => `
      <div class="lesson-header">
        <div class="breadcrumb">Module 1 ‚Üí <span>Type Assertions & Literal Types</span></div>
        <h2>üé≠ Type Assertions & Literal Types</h2>
        <p class="lesson-desc">Take control of types with assertions and create ultra-precise types with literals.</p>
      </div>

      <div class="content-section">
        <h3><span class="emoji">üéØ</span> Type Assertions</h3>
        <p>Tell TypeScript "I know more about this type than you do." Use sparingly!</p>

        ${codeBlock(`
// "as" syntax (preferred)
let value: unknown = "Hello World";
let length: number = (value as string).length;

// Angle bracket syntax (not in JSX/React)
let length2: number = (<string>value).length;

// Common use: DOM elements
const input = document.getElementById("search") as HTMLInputElement;
input.value = "TypeScript";  // ‚úÖ TS knows it's an input now

// Non-null assertion (!) ‚Äî risky!
let element = document.getElementById("app")!;
// The ! tells TS "trust me, this won't be null"
        `)}

        <div class="info-card danger">
          <div class="card-title">üö® Assertion Pitfall</div>
          <p>Type assertions DON'T convert values ‚Äî they only tell the compiler to treat a value as a different type. If you're wrong, you'll get runtime errors!</p>
        </div>

        ${codeBlock(`
// ‚ùå DANGEROUS: This compiles but crashes at runtime!
let num: unknown = 42;
let str = num as string;
// str.toUpperCase(); // üí• Runtime error! num is actually a number
        `)}

        <h3><span class="emoji">‚ú®</span> Literal Types</h3>
        <p>Instead of broad types like <code>string</code>, you can specify <strong>exact values</strong>.</p>

        ${codeBlock(`
// Literal types ‚Äî exact values only
let direction: "up" | "down" | "left" | "right";
direction = "up";      // ‚úÖ
// direction = "diagonal"; // ‚ùå Error!

// Numeric literals
type DiceRoll = 1 | 2 | 3 | 4 | 5 | 6;
let roll: DiceRoll = 3;  // ‚úÖ
// let roll2: DiceRoll = 7; // ‚ùå Error!

// Boolean literal
type LoadingState = true;  // Only true allowed!

// Combining with other types
type Status = "loading" | "success" | "error";
type Result = {
  status: Status;
  data: string | null;
};
        `)}

        <h3><span class="emoji">üîí</span> const Assertions</h3>
        ${codeBlock(`
// Without "as const" ‚Äî types are wide
let config = {
  url: "https://api.com",  // type: string
  port: 3000               // type: number
};

// With "as const" ‚Äî types are narrow (readonly literals)
let config2 = {
  url: "https://api.com",  // type: "https://api.com" (literal)
  port: 3000               // type: 3000 (literal)
} as const;

// config2.port = 4000;  // ‚ùå Error: readonly!

// Great for arrays too
const colors = ["red", "green", "blue"] as const;
// type: readonly ["red", "green", "blue"]
// Not: string[]
        `)}
      </div>

      ${quizBlock('q-assertions', [
        {
          q: 'What does <code>as const</code> do to an object?',
          opts: [
            'Makes it mutable',
            'Converts it to a class',
            'Makes all properties readonly with literal types',
            'Adds runtime type checking'
          ],
          correct: 2,
          explanation: '"as const" makes the entire object deeply readonly with all values narrowed to their literal types.'
        }
      ])}
    `
  },
  {
    id: 'pitfalls-1', title: '‚ö†Ô∏è Pitfalls & Mistakes',
    render: () => `
      <div class="lesson-header">
        <h2>‚ö†Ô∏è Common Pitfalls ‚Äî Basic Types</h2>
        <p class="lesson-desc">Avoid these mistakes that trip up TypeScript beginners!</p>
      </div>

      <div class="content-section">
        ${pitfallCard('Using <code>any</code> to silence errors', `
          <div class="comparison">
            <div class="col bad">
              <div class="col-title">‚ùå Bad</div>
              ${codeBlock(`
// "It works now!" ...until runtime
function getData(): any {
  return fetch("/api");
}
let data: any = getData();
data.forEach(item => item.name);
// No errors... but will crash!
              `, 'TypeScript')}
            </div>
            <div class="col good">
              <div class="col-title">‚úÖ Good</div>
              ${codeBlock(`
interface User { name: string }

async function getData(): Promise<User[]> {
  const res = await fetch("/api");
  return res.json() as Promise<User[]>;
}
// Now TS protects you!
              `, 'TypeScript')}
            </div>
          </div>
        `)}

        ${pitfallCard('Confusing <code>string</code> (type) with <code>String</code> (object wrapper)', `
          <div class="comparison">
            <div class="col bad">
              <div class="col-title">‚ùå Bad ‚Äî Object wrapper types</div>
              ${codeBlock(`
// NEVER use uppercase wrapper types!
let name: String = "Alice";
let age: Number = 42;
let ok: Boolean = true;
              `, 'TypeScript')}
            </div>
            <div class="col good">
              <div class="col-title">‚úÖ Good ‚Äî Primitive types</div>
              ${codeBlock(`
// Always use lowercase primitive types
let name: string = "Alice";
let age: number = 42;
let ok: boolean = true;
              `, 'TypeScript')}
            </div>
          </div>
          <p style="color:var(--tx2);font-size:.88rem;margin-top:.5rem"><code>String</code>, <code>Number</code>, <code>Boolean</code> are JavaScript wrapper objects ‚Äî NOT the same as the primitive types. Almost never what you want.</p>
        `)}

        ${pitfallCard('Assuming type assertions are type conversions', `
          ${codeBlock(`
// ‚ùå This does NOT convert the value!
let value = 42;
let str = value as unknown as string;
console.log(str.toUpperCase()); // üí• RUNTIME ERROR!
// value is still 42, not "42"

// ‚úÖ Actually convert the value:
let str2 = String(value);      // "42"
let str3 = value.toString();   // "42"
          `, 'TypeScript')}
        `)}

        ${pitfallCard('Forgetting that tuples allow push()', `
          ${codeBlock(`
// ‚ùå Tuple allows push ‚Äî design flaw in TS
let pair: [string, number] = ["Alice", 28];
pair.push("extra"); // No error! üò±
console.log(pair);  // ["Alice", 28, "extra"]

// ‚úÖ Use readonly to prevent this
let safePair: readonly [string, number] = ["Alice", 28];
// safePair.push("extra"); // ‚ùå Error! üéâ
          `, 'TypeScript')}
        `)}
      </div>
    `
  }
  ]
},
// ============== MODULE 2: INTERFACES & TYPES ==============
{
  id: 'interfaces', title: 'Interfaces & Types', icon: 'üèóÔ∏è',
  lessons: [
  {
    id: 'interface-basics', title: 'Interface Basics',
    render: () => `
      <div class="lesson-header">
        <div class="breadcrumb">Module 2 ‚Üí <span>Interface Basics</span></div>
        <h2>üèóÔ∏è Interface Basics</h2>
        <p class="lesson-desc">Interfaces define the shape of objects ‚Äî they're the backbone of TypeScript.</p>
      </div>

      <div class="content-section">
        <h3><span class="emoji">üìê</span> Defining Interfaces</h3>
        ${codeBlock(`
// Define the shape of an object
interface User {
  name: string;
  age: number;
  email: string;
}

// Use the interface
const alice: User = {
  name: "Alice",
  age: 28,
  email: "alice@example.com"
};

// ‚ùå Missing properties = Error
// const bob: User = { name: "Bob" };
// Error: Missing 'age' and 'email'

// ‚ùå Extra properties = Error (in direct assignment)
// const charlie: User = {
//   name: "Charlie", age: 30, email: "c@c.com",
//   phone: "555-1234"  // Error: Object literal may only specify known properties
// };
        `)}

        <h3><span class="emoji">‚ùì</span> Optional & Readonly Properties</h3>
        ${codeBlock(`
interface Product {
  readonly id: number;      // Cannot be changed after creation
  name: string;
  price: number;
  description?: string;     // Optional (may be undefined)
  tags?: string[];          // Optional
}

const laptop: Product = {
  id: 1,
  name: "MacBook Pro",
  price: 2499
  // description and tags are optional ‚Äî no error!
};

// laptop.id = 2;  // ‚ùå Error: Cannot assign to 'id' because it is read-only
laptop.name = "MacBook Air";  // ‚úÖ OK ‚Äî not readonly
        `)}

        <h3><span class="emoji">üîß</span> Function Types in Interfaces</h3>
        ${codeBlock(`
interface Calculator {
  add(a: number, b: number): number;
  subtract(a: number, b: number): number;
  // Method shorthand ‚Üë or property syntax ‚Üì
  multiply: (a: number, b: number) => number;
}

const calc: Calculator = {
  add: (a, b) => a + b,
  subtract: (a, b) => a - b,
  multiply: (a, b) => a * b
};

console.log(calc.add(5, 3));  // 8
        `)}
      </div>

      ${quizBlock('q-iface', [
        {
          q: 'What does <code>?</code> after a property name mean?',
          opts: ['The property is nullable', 'The property is optional', 'The property is readonly', 'The property is private'],
          correct: 1,
          explanation: 'The ? makes a property optional ‚Äî it may or may not exist on the object.'
        },
        {
          q: 'Can you modify a <code>readonly</code> property after object creation?',
          opts: ['Yes, anytime', 'No, TypeScript will error', 'Only inside methods', 'Only with type assertions'],
          correct: 1,
          explanation: 'readonly properties cannot be reassigned after the object is created. TypeScript will give a compile error.'
        }
      ])}

      ${exerciseBlock('ex-iface',
        'Create an interface for a BlogPost with: title (string), content (string), author (string), publishedAt (Date), optional likes (number):',
        'interface BlogPost {\n  // your code here\n}',
        'interface BlogPost {\n  title: string;\n  content: string;\n  author: string;\n  publishedAt: Date;\n  likes?: number;\n}',
        'Remember: use ? for optional properties'
      )}
    `
  },
  {
    id: 'extending', title: 'Extending Interfaces',
    render: () => `
      <div class="lesson-header">
        <div class="breadcrumb">Module 2 ‚Üí <span>Extending Interfaces</span></div>
        <h2>üß¨ Extending Interfaces</h2>
        <p class="lesson-desc">Build complex types by extending simpler ones ‚Äî like inheritance for types!</p>
      </div>

      <div class="content-section">
        <h3><span class="emoji">üìö</span> Single Extension</h3>
        ${codeBlock(`
interface Animal {
  name: string;
  sound: string;
}

// Dog extends Animal ‚Äî gets all Animal properties + its own
interface Dog extends Animal {
  breed: string;
  goodBoy: boolean;
}

const rex: Dog = {
  name: "Rex",
  sound: "Woof",
  breed: "German Shepherd",
  goodBoy: true
};
        `)}

        <h3><span class="emoji">üîó</span> Multiple Extension</h3>
        ${codeBlock(`
interface HasId {
  id: number;
}

interface HasTimestamps {
  createdAt: Date;
  updatedAt: Date;
}

interface HasName {
  name: string;
}

// Extend multiple interfaces at once!
interface User extends HasId, HasTimestamps, HasName {
  email: string;
  role: "admin" | "user";
}

const admin: User = {
  id: 1,
  name: "Alice",
  email: "alice@example.com",
  role: "admin",
  createdAt: new Date(),
  updatedAt: new Date()
};
        `)}

        <h3><span class="emoji">üè¢</span> Real-World Pattern: API Models</h3>
        ${codeBlock(`
// Base interface for all API responses
interface ApiResponse {
  status: number;
  timestamp: string;
}

// Extend for specific responses
interface UserResponse extends ApiResponse {
  data: {
    id: number;
    name: string;
    email: string;
  };
}

interface ErrorResponse extends ApiResponse {
  error: {
    code: string;
    message: string;
  };
}

// Use in functions
async function fetchUser(id: number): Promise<UserResponse | ErrorResponse> {
  const res = await fetch("/api/users/" + id);
  return res.json();
}
        `)}
      </div>

      ${quizBlock('q-extending', [
        {
          q: 'Can an interface extend multiple interfaces?',
          opts: ['No, only one', 'Yes, using commas', 'Yes, using the & operator', 'Only types can do that'],
          correct: 1,
          explanation: 'Interfaces can extend multiple other interfaces using commas: interface A extends B, C, D { }'
        }
      ])}
    `
  },
  {
    id: 'type-aliases', title: 'Type Aliases',
    render: () => `
      <div class="lesson-header">
        <div class="breadcrumb">Module 2 ‚Üí <span>Type Aliases</span></div>
        <h2>üè∑Ô∏è Type Aliases</h2>
        <p class="lesson-desc">Create reusable type definitions with the <code>type</code> keyword.</p>
      </div>

      <div class="content-section">
        <h3><span class="emoji">üìù</span> Basic Type Aliases</h3>
        ${codeBlock(`
// Simple alias for primitives
type ID = string | number;
type Status = "active" | "inactive" | "suspended";

// Object type alias
type User = {
  id: ID;
  name: string;
  status: Status;
};

// Function type alias
type Callback = (error: Error | null, data: string) => void;

// Using them
const user: User = { id: "abc", name: "Alice", status: "active" };
const handler: Callback = (err, data) => {
  if (err) console.error(err);
  else console.log(data);
};
        `)}

        <h3><span class="emoji">üîÄ</span> Combining with Intersection</h3>
        ${codeBlock(`
type HasId = { id: number };
type HasName = { name: string };
type HasEmail = { email: string };

// Intersection (like extending)
type User = HasId & HasName & HasEmail;

// Adding more properties
type AdminUser = User & {
  role: "admin";
  permissions: string[];
};

const admin: AdminUser = {
  id: 1,
  name: "Alice",
  email: "alice@admin.com",
  role: "admin",
  permissions: ["read", "write", "delete"]
};
        `)}

        <h3><span class="emoji">üÜö</span> Interface vs Type ‚Äî The Showdown!</h3>
        <table class="ts-table">
          <thead>
            <tr><th>Feature</th><th><code>interface</code></th><th><code>type</code></th></tr>
          </thead>
          <tbody>
            <tr><td>Object shapes</td><td>‚úÖ</td><td>‚úÖ</td></tr>
            <tr><td>Extend / Inherit</td><td>‚úÖ <code>extends</code></td><td>‚úÖ <code>&</code></td></tr>
            <tr><td>Union types</td><td>‚ùå</td><td>‚úÖ <code>A | B</code></td></tr>
            <tr><td>Primitive aliases</td><td>‚ùå</td><td>‚úÖ <code>type ID = string</code></td></tr>
            <tr><td>Declaration merging</td><td>‚úÖ (auto-merges)</td><td>‚ùå</td></tr>
            <tr><td>Tuple types</td><td>‚ùå</td><td>‚úÖ</td></tr>
            <tr><td>Mapped types</td><td>‚ùå</td><td>‚úÖ</td></tr>
            <tr><td><code>implements</code> in classes</td><td>‚úÖ</td><td>‚úÖ (object types)</td></tr>
          </tbody>
        </table>

        <div class="info-card tip">
          <div class="card-title">üí° Rule of Thumb</div>
          <p>Use <strong>interface</strong> for object shapes and class contracts. Use <strong>type</strong> for unions, intersections, primitives, tuples, and complex type transformations. When in doubt, <strong>interface</strong> is a safe default for objects.</p>
        </div>

        ${codeBlock(`
// Declaration merging (only interfaces!)
interface Window {
  myCustomProp: string;
}
// Now Window has myCustomProp in addition to all its normal props!

// This is why libraries use interfaces ‚Äî consumers can extend them
        `)}
      </div>

      ${quizBlock('q-types', [
        {
          q: 'Which can ONLY be done with <code>type</code>, not <code>interface</code>?',
          opts: ['Define object shape', 'Create union type', 'Extend another type', 'Use with classes'],
          correct: 1,
          explanation: 'Union types (type A = X | Y) can only be created with type aliases, not interfaces.'
        },
        {
          q: 'What is declaration merging?',
          opts: [
            'Combining two files',
            'When two interfaces with the same name auto-combine their properties',
            'Using the & operator',
            'Importing and re-exporting'
          ],
          correct: 1,
          explanation: 'If you declare the same interface name twice, TypeScript merges them into one. This is unique to interfaces.'
        }
      ])}
    `
  },
  {
    id: 'advanced-patterns', title: 'Advanced Patterns',
    render: () => `
      <div class="lesson-header">
        <div class="breadcrumb">Module 2 ‚Üí <span>Advanced Patterns</span></div>
        <h2>üß† Advanced Interface Patterns</h2>
        <p class="lesson-desc">Index signatures, discriminated unions, and other powerful patterns.</p>
      </div>

      <div class="content-section">
        <h3><span class="emoji">üìá</span> Index Signatures</h3>
        <p>When you don't know all property names ahead of time:</p>
        ${codeBlock(`
// String index signature
interface Dictionary {
  [key: string]: string;
}

const colors: Dictionary = {
  red: "#ff0000",
  green: "#00ff00",
  blue: "#0000ff"
  // Any string key with string value is OK
};

// Mixed: known + dynamic properties
interface Config {
  name: string;               // Must exist
  version: number;            // Must exist
  [key: string]: string | number;  // Additional properties
}

const config: Config = {
  name: "my-app",
  version: 1,
  port: 3000,       // ‚úÖ extra property OK
  host: "localhost"  // ‚úÖ extra property OK
};
        `)}

        <h3><span class="emoji">üè∑Ô∏è</span> Discriminated Unions (Tagged Unions)</h3>
        <p>A powerful pattern for handling different shapes of data:</p>
        ${codeBlock(`
// Each type has a "tag" property that identifies it
interface Circle {
  kind: "circle";
  radius: number;
}

interface Rectangle {
  kind: "rectangle";
  width: number;
  height: number;
}

interface Triangle {
  kind: "triangle";
  base: number;
  height: number;
}

type Shape = Circle | Rectangle | Triangle;

function getArea(shape: Shape): number {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2;
    case "rectangle":
      return shape.width * shape.height;
    case "triangle":
      return 0.5 * shape.base * shape.height;
  }
}

// TypeScript narrows the type based on the 'kind' check!
getArea({ kind: "circle", radius: 5 });      // 78.54
getArea({ kind: "rectangle", width: 4, height: 6 }); // 24
        `)}

        <div class="info-card success">
          <div class="card-title">üåü Interview Favorite!</div>
          <p>Discriminated unions are a very common interview topic. They're used heavily in Redux actions, React state machines, API responses, and event handlers. Master this pattern!</p>
        </div>
      </div>

      ${quizBlock('q-advanced', [
        {
          q: 'What is the purpose of an index signature?',
          opts: [
            'To index arrays',
            'To allow objects with unknown property names',
            'To create numbered properties',
            'To sort object keys'
          ],
          correct: 1,
          explanation: 'Index signatures let you define the type for properties whose names you don\'t know ahead of time: [key: string]: ValueType'
        }
      ])}
    `
  },
  {
    id: 'pitfalls-2', title: '‚ö†Ô∏è Pitfalls & Mistakes',
    render: () => `
      <div class="lesson-header">
        <h2>‚ö†Ô∏è Common Pitfalls ‚Äî Interfaces & Types</h2>
        <p class="lesson-desc">Watch out for these tricky issues!</p>
      </div>

      <div class="content-section">
        ${pitfallCard('Thinking <code>readonly</code> is deep (it\'s shallow!)', `
          ${codeBlock(`
interface User {
  readonly name: string;
  readonly address: {
    city: string;
    country: string;
  };
}

const user: User = {
  name: "Alice",
  address: { city: "Tokyo", country: "Japan" }
};

// user.name = "Bob";        // ‚ùå Error ‚Äî readonly
user.address.city = "Osaka"; // ‚úÖ No error! üò±
// readonly only prevents reassigning the address REFERENCE
// It doesn't prevent mutating the nested object!

// Fix: Make nested objects readonly too
interface SafeUser {
  readonly name: string;
  readonly address: Readonly<{
    city: string;
    country: string;
  }>;
}
          `, 'TypeScript')}
        `)}

        ${pitfallCard('Unexpected declaration merging', `
          ${codeBlock(`
// Two interfaces with the same name MERGE automatically
interface Config {
  apiUrl: string;
}

interface Config {
  timeout: number;
}

// Config now has BOTH properties!
const config: Config = {
  apiUrl: "https://api.com",
  timeout: 5000
  // Both are required!
};

// ‚ö†Ô∏è This can cause confusion in large codebases
// Types do NOT merge (which is sometimes better):
// type Config = { apiUrl: string }
// type Config = { timeout: number } // ‚ùå Error: Duplicate identifier
          `, 'TypeScript')}
        `)}

        ${pitfallCard('Optional properties vs undefined', `
          ${codeBlock(`
interface User {
  name: string;
  age?: number;  // age is optional
}

// These are different!
const user1: User = { name: "Alice" };           // age doesn't exist
const user2: User = { name: "Bob", age: undefined }; // age exists but is undefined

// With exactOptionalPropertyTypes (tsconfig):
// user2 would be an error! age must be number if provided

// Safe access pattern:
function getAge(user: User): string {
  if (user.age !== undefined) {
    return user.age + " years old";
  }
  return "Age unknown";
}
          `, 'TypeScript')}
        `)}
      </div>
    `
  }
  ]
},
// ============== MODULE 3: GENERICS ==============
{
  id: 'generics', title: 'Generics', icon: 'üß¨',
  lessons: [
  {
    id: 'why-generics', title: 'Why Generics?',
    render: () => `
      <div class="lesson-header">
        <div class="breadcrumb">Module 3 ‚Üí <span>Why Generics?</span></div>
        <h2>üß¨ Why Generics? The Problem They Solve</h2>
        <p class="lesson-desc">Generics let you write flexible, reusable code without sacrificing type safety.</p>
      </div>

      <div class="content-section">
        <h3><span class="emoji">üò∞</span> The Problem</h3>
        <p>Imagine you need a function that returns the first element of any array:</p>

        ${codeBlock(`
// Attempt 1: Only works for numbers
function firstNumber(arr: number[]): number {
  return arr[0];
}

// Attempt 2: Only works for strings
function firstString(arr: string[]): string {
  return arr[0];
}

// Attempt 3: Works for anything but LOSES type information!
function firstAny(arr: any[]): any {
  return arr[0];
}

let item = firstAny([1, 2, 3]);
// item is 'any' ‚Äî TS doesn't know it's a number! üò¢
// item.toUpperCase() // No error, but will crash!
        `)}

        <h3><span class="emoji">üéâ</span> The Solution: Generics!</h3>
        ${codeBlock(`
// Generic function ‚Äî works for ANY type and PRESERVES it!
function first<T>(arr: T[]): T {
  return arr[0];
}

// TypeScript infers the type automatically!
let num = first([1, 2, 3]);        // num: number ‚úÖ
let str = first(["a", "b", "c"]);  // str: string ‚úÖ
let user = first([{ name: "Alice" }]); // user: { name: string } ‚úÖ

// Or specify explicitly:
let val = first<string>(["hello"]); // val: string
        `)}

        <div class="info-card tip">
          <div class="card-title">üí° Think of T as a Variable for Types</div>
          <p>Just like <code>x</code> is a variable that holds a value, <code>T</code> is a variable that holds a <strong>type</strong>. When you call the function, T gets "filled in" with the actual type.</p>
        </div>

        <h3><span class="emoji">üìä</span> Generics: Before vs After</h3>
        <div class="comparison">
          <div class="col bad">
            <div class="col-title">‚ùå Without Generics</div>
            ${codeBlock(`
function wrap(value: any): any {
  return { value };
}
let r = wrap("hello");
// r.value is 'any' üò¢
// r.value.toUpperCase() ‚Äî no autocomplete!
            `)}
          </div>
          <div class="col good">
            <div class="col-title">‚úÖ With Generics</div>
            ${codeBlock(`
function wrap<T>(value: T): { value: T } {
  return { value };
}
let r = wrap("hello");
// r.value is 'string' üéâ
// r.value.toUpperCase() ‚Äî full autocomplete!
            `)}
          </div>
        </div>
      </div>

      ${quizBlock('q-whygen', [
        {
          q: 'What does <code>T</code> represent in <code>function identity&lt;T&gt;(val: T): T</code>?',
          opts: [
            'The letter T',
            'A type parameter that gets filled in when called',
            'The type "T"',
            'A string template'
          ],
          correct: 1,
          explanation: 'T is a type parameter (type variable). When you call identity("hello"), T becomes string. When you call identity(42), T becomes number.'
        }
      ])}
    `
  },
  {
    id: 'generic-functions', title: 'Generic Functions',
    render: () => `
      <div class="lesson-header">
        <div class="breadcrumb">Module 3 ‚Üí <span>Generic Functions</span></div>
        <h2>‚öôÔ∏è Generic Functions</h2>
        <p class="lesson-desc">Master the syntax and patterns for generic functions.</p>
      </div>

      <div class="content-section">
        <h3><span class="emoji">üìù</span> Syntax & Multiple Type Parameters</h3>
        ${codeBlock(`
// Single type parameter
function identity<T>(value: T): T {
  return value;
}

// Multiple type parameters
function pair<A, B>(first: A, second: B): [A, B] {
  return [first, second];
}

let p = pair("hello", 42);  // p: [string, number]

// Generic arrow functions
const toArray = <T>(value: T): T[] => [value];
const map = <T, U>(arr: T[], fn: (item: T) => U): U[] => arr.map(fn);

// Real-world example: API response wrapper
function apiResponse<T>(data: T, status: number): {
  data: T;
  status: number;
  timestamp: string;
} {
  return {
    data,
    status,
    timestamp: new Date().toISOString()
  };
}

let userRes = apiResponse({ name: "Alice", age: 28 }, 200);
// userRes.data.name ‚Äî fully typed! ‚úÖ
        `)}

        <h3><span class="emoji">üîç</span> Type Inference in Action</h3>
        ${codeBlock(`
function merge<T, U>(obj1: T, obj2: U): T & U {
  return { ...obj1, ...obj2 };
}

// TS infers T and U automatically!
const result = merge(
  { name: "Alice" },
  { age: 28, email: "alice@example.com" }
);

// result has all properties, fully typed:
console.log(result.name);   // ‚úÖ string
console.log(result.age);    // ‚úÖ number
console.log(result.email);  // ‚úÖ string

// Practical: safe filter function
function filterByProp<T>(
  arr: T[],
  key: keyof T,
  value: T[keyof T]
): T[] {
  return arr.filter(item => item[key] === value);
}

const users = [
  { name: "Alice", role: "admin" },
  { name: "Bob", role: "user" }
];
const admins = filterByProp(users, "role", "admin");
// admins is fully typed!
        `)}
      </div>

      ${quizBlock('q-genfn', [
        {
          q: 'What does <code>function swap&lt;A, B&gt;(pair: [A, B]): [B, A]</code> do?',
          opts: [
            'Creates a new type called A and B',
            'Takes a tuple and returns it with swapped types',
            'Converts A to B',
            'This is invalid syntax'
          ],
          correct: 1,
          explanation: 'This function takes a tuple [A, B] and returns [B, A] ‚Äî the elements are swapped, and the types track perfectly.'
        }
      ])}

      ${exerciseBlock('ex-genfn',
        'Write a generic function called "last" that returns the last element of any array:',
        'function last(arr) {\n  return arr[arr.length - 1];\n}',
        'function last<T>(arr: T[]): T {\n  return arr[arr.length - 1];\n}',
        'Add a type parameter T, type the parameter as T[], and return type as T'
      )}
    `
  },
  {
    id: 'generic-interfaces', title: 'Generic Interfaces & Classes',
    render: () => `
      <div class="lesson-header">
        <div class="breadcrumb">Module 3 ‚Üí <span>Generic Interfaces & Classes</span></div>
        <h2>üèóÔ∏è Generic Interfaces & Classes</h2>
        <p class="lesson-desc">Apply generics to interfaces and classes for maximum reusability.</p>
      </div>

      <div class="content-section">
        <h3><span class="emoji">üìê</span> Generic Interfaces</h3>
        ${codeBlock(`
// Generic interface
interface ApiResponse<T> {
  data: T;
  status: number;
  message: string;
}

// Use with different types!
interface User { name: string; email: string }
interface Product { id: number; title: string; price: number }

let userResponse: ApiResponse<User> = {
  data: { name: "Alice", email: "alice@example.com" },
  status: 200,
  message: "Success"
};

let productResponse: ApiResponse<Product> = {
  data: { id: 1, title: "Laptop", price: 999 },
  status: 200,
  message: "Success"
};

// Generic interface with multiple params
interface KeyValuePair<K, V> {
  key: K;
  value: V;
}

let setting: KeyValuePair<string, number> = {
  key: "volume",
  value: 75
};
        `)}

        <h3><span class="emoji">üèõÔ∏è</span> Generic Classes</h3>
        ${codeBlock(`
// Generic Stack data structure
class Stack<T> {
  private items: T[] = [];

  push(item: T): void {
    this.items.push(item);
  }

  pop(): T | undefined {
    return this.items.pop();
  }

  peek(): T | undefined {
    return this.items[this.items.length - 1];
  }

  get size(): number {
    return this.items.length;
  }
}

// Type-safe stacks!
const numberStack = new Stack<number>();
numberStack.push(1);
numberStack.push(2);
// numberStack.push("three"); // ‚ùå Error!
let top = numberStack.pop();  // top: number | undefined

const stringStack = new Stack<string>();
stringStack.push("hello");
// Fully type-safe, fully reusable!

// Generic Repository pattern
class Repository<T extends { id: number }> {
  private items: T[] = [];

  add(item: T): void {
    this.items.push(item);
  }

  findById(id: number): T | undefined {
    return this.items.find(item => item.id === id);
  }

  getAll(): T[] {
    return [...this.items];
  }
}

interface User { id: number; name: string }
const userRepo = new Repository<User>();
userRepo.add({ id: 1, name: "Alice" });
let user = userRepo.findById(1); // User | undefined
        `)}
      </div>

      ${quizBlock('q-genif', [
        {
          q: 'In <code>interface Box&lt;T&gt; { value: T }</code>, when is T determined?',
          opts: [
            'At compile time when you use Box<string>',
            'At runtime',
            'When the interface is declared',
            'Never ‚Äî it stays as T'
          ],
          correct: 0,
          explanation: 'T is determined when you use the interface with a specific type: Box<string>, Box<number>, etc. This happens at compile time.'
        }
      ])}
    `
  },
  {
    id: 'constraints', title: 'Constraints',
    render: () => `
      <div class="lesson-header">
        <div class="breadcrumb">Module 3 ‚Üí <span>Generic Constraints</span></div>
        <h2>üîí Generic Constraints</h2>
        <p class="lesson-desc">Limit what types can be used with your generics using <code>extends</code>.</p>
      </div>

      <div class="content-section">
        <h3><span class="emoji">üöß</span> The Problem Without Constraints</h3>
        ${codeBlock(`
// ‚ùå Problem: T could be anything ‚Äî even things without .length
function logLength<T>(value: T): void {
  // console.log(value.length); // ‚ùå Error!
  // Property 'length' does not exist on type 'T'
}

// T could be a number, which has no .length!
        `)}

        <h3><span class="emoji">‚úÖ</span> Solution: Constraints with extends</h3>
        ${codeBlock(`
// Constrain T to types that have a .length property
interface HasLength {
  length: number;
}

function logLength<T extends HasLength>(value: T): void {
  console.log(value.length); // ‚úÖ Now TS knows T has .length!
}

logLength("hello");          // ‚úÖ string has .length
logLength([1, 2, 3]);        // ‚úÖ array has .length
logLength({ length: 10 });   // ‚úÖ object with .length
// logLength(42);             // ‚ùå Error: number has no .length

// Constrain to objects with specific shape
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const user = { name: "Alice", age: 28, email: "alice@example.com" };
let name = getProperty(user, "name");   // string ‚úÖ
let age = getProperty(user, "age");     // number ‚úÖ
// getProperty(user, "phone");           // ‚ùå Error! "phone" is not in keyof User
        `)}

        <h3><span class="emoji">üîë</span> keyof ‚Äî The Key Operator</h3>
        ${codeBlock(`
interface User {
  name: string;
  age: number;
  email: string;
}

// keyof User = "name" | "age" | "email"
type UserKeys = keyof User;

function pluck<T, K extends keyof T>(items: T[], key: K): T[K][] {
  return items.map(item => item[key]);
}

const users = [
  { name: "Alice", age: 28 },
  { name: "Bob", age: 32 }
];

let names = pluck(users, "name"); // string[] ‚úÖ
let ages = pluck(users, "age");   // number[] ‚úÖ
// pluck(users, "foo");            // ‚ùå Error!
        `)}

        <h3><span class="emoji">üîß</span> Default Type Parameters</h3>
        ${codeBlock(`
// Default type parameter (like default function arguments)
interface ApiResponse<T = unknown> {
  data: T;
  status: number;
}

// Can use without specifying T
let response: ApiResponse = {
  data: "anything",  // data is 'unknown'
  status: 200
};

// Or specify T
let userResponse: ApiResponse<{ name: string }> = {
  data: { name: "Alice" },
  status: 200
};

// Default with constraint
type Container<T extends object = Record<string, unknown>> = {
  value: T;
  metadata: string;
};
        `)}
      </div>

      ${quizBlock('q-constraints', [
        {
          q: 'What does <code>T extends HasLength</code> mean?',
          opts: [
            'T inherits from HasLength',
            'T must be compatible with HasLength (have its properties)',
            'T is always equal to HasLength',
            'T is a subclass of HasLength'
          ],
          correct: 1,
          explanation: 'In a generic constraint, extends means "must satisfy" or "must be assignable to." T must have at least the properties defined in HasLength.'
        },
        {
          q: 'What does <code>keyof T</code> return?',
          opts: [
            'All values of T',
            'A union of all property names of T',
            'The first key of T',
            'The type of T'
          ],
          correct: 1,
          explanation: 'keyof T returns a union type of all known property names (keys) of T. For { name: string, age: number }, it returns "name" | "age".'
        }
      ])}

      ${exerciseBlock('ex-constraints',
        'Add a constraint so this function only accepts objects with an "id" property:',
        'function findById<T>(items: T[], id: number): T | undefined {\n  return items.find(item => item.id === id);\n}',
        'function findById<T extends { id: number }>(items: T[], id: number): T | undefined {\n  return items.find(item => item.id === id);\n}',
        'Add extends { id: number } after T to constrain the type'
      )}
    `
  },
  {
    id: 'utility-types', title: 'Utility Types',
    render: () => `
      <div class="lesson-header">
        <div class="breadcrumb">Module 3 ‚Üí <span>Utility Types</span></div>
        <h2>üõ†Ô∏è Built-in Utility Types</h2>
        <p class="lesson-desc">TypeScript provides powerful built-in generic types. Master these to become a TS pro!</p>
      </div>

      <div class="content-section">
        <h3><span class="emoji">üì¶</span> The Essential Utility Types</h3>

        ${codeBlock(`
interface User {
  id: number;
  name: string;
  email: string;
  age: number;
}

// ‚îÄ‚îÄ Partial<T> ‚Äî All properties become optional ‚îÄ‚îÄ
type PartialUser = Partial<User>;
// { id?: number; name?: string; email?: string; age?: number }

function updateUser(id: number, updates: Partial<User>): void {
  // Can pass any subset of User properties!
}
updateUser(1, { name: "New Name" });      // ‚úÖ
updateUser(1, { age: 29, email: "new" }); // ‚úÖ

// ‚îÄ‚îÄ Required<T> ‚Äî All properties become required ‚îÄ‚îÄ
type RequiredUser = Required<User>;
// Opposite of Partial

// ‚îÄ‚îÄ Readonly<T> ‚Äî All properties become readonly ‚îÄ‚îÄ
type FrozenUser = Readonly<User>;
const user: FrozenUser = { id: 1, name: "Alice", email: "a@b.com", age: 28 };
// user.name = "Bob"; // ‚ùå Error!
        `)}

        ${codeBlock(`
interface User {
  id: number;
  name: string;
  email: string;
  age: number;
}

// ‚îÄ‚îÄ Pick<T, K> ‚Äî Select specific properties ‚îÄ‚îÄ
type UserPreview = Pick<User, "name" | "email">;
// { name: string; email: string }

// ‚îÄ‚îÄ Omit<T, K> ‚Äî Remove specific properties ‚îÄ‚îÄ
type CreateUser = Omit<User, "id">;
// { name: string; email: string; age: number }
// Great for forms where id is auto-generated!

// ‚îÄ‚îÄ Record<K, V> ‚Äî Create object type from keys and value type ‚îÄ‚îÄ
type StatusMap = Record<string, boolean>;
const features: StatusMap = {
  darkMode: true,
  notifications: false,
  beta: true
};

type Roles = "admin" | "user" | "guest";
type RolePermissions = Record<Roles, string[]>;
const perms: RolePermissions = {
  admin: ["read", "write", "delete"],
  user: ["read", "write"],
  guest: ["read"]
};
        `)}

        ${codeBlock(`
// ‚îÄ‚îÄ Exclude<T, U> ‚Äî Remove types from a union ‚îÄ‚îÄ
type AllStatus = "active" | "inactive" | "suspended" | "deleted";
type ActiveStatus = Exclude<AllStatus, "deleted" | "suspended">;
// "active" | "inactive"

// ‚îÄ‚îÄ Extract<T, U> ‚Äî Keep only matching types ‚îÄ‚îÄ
type OnlyStrings = Extract<string | number | boolean, string>;
// string

// ‚îÄ‚îÄ ReturnType<T> ‚Äî Get return type of a function ‚îÄ‚îÄ
function createUser(name: string, age: number) {
  return { id: Math.random(), name, age, createdAt: new Date() };
}
type NewUser = ReturnType<typeof createUser>;
// { id: number; name: string; age: number; createdAt: Date }

// ‚îÄ‚îÄ Parameters<T> ‚Äî Get parameter types as a tuple ‚îÄ‚îÄ
type CreateUserParams = Parameters<typeof createUser>;
// [name: string, age: number]

// ‚îÄ‚îÄ NonNullable<T> ‚Äî Remove null and undefined ‚îÄ‚îÄ
type MaybeString = string | null | undefined;
type DefinitelyString = NonNullable<MaybeString>;
// string
        `)}

        <div class="info-card success">
          <div class="card-title">üåü Real-World Power Combo</div>
          <p>Combining utility types is where the real magic happens:</p>
        </div>

        ${codeBlock(`
// API pattern: Create, Update, Response types from one base
interface User {
  id: number;
  name: string;
  email: string;
  role: "admin" | "user";
  createdAt: Date;
}

type CreateUserDTO = Omit<User, "id" | "createdAt">;
type UpdateUserDTO = Partial<Omit<User, "id" | "createdAt">>;
type UserSummary = Pick<User, "id" | "name" | "role">;

// One interface, three useful variations! üéâ
        `)}
      </div>

      ${quizBlock('q-utility', [
        {
          q: 'What does <code>Partial&lt;User&gt;</code> do?',
          opts: [
            'Removes all properties',
            'Makes all properties optional',
            'Makes all properties required',
            'Makes all properties readonly'
          ],
          correct: 1,
          explanation: 'Partial<T> makes every property of T optional (adds ? to each property).'
        },
        {
          q: 'What is <code>Omit&lt;User, "id" | "createdAt"&gt;</code>?',
          opts: [
            'User with only id and createdAt',
            'User without id and createdAt',
            'An empty type',
            'Same as User'
          ],
          correct: 1,
          explanation: 'Omit<T, K> creates a type with all properties of T except those specified in K.'
        }
      ])}
    `
  },
  {
    id: 'pitfalls-3', title: '‚ö†Ô∏è Pitfalls & Mistakes',
    render: () => `
      <div class="lesson-header">
        <h2>‚ö†Ô∏è Common Pitfalls ‚Äî Generics</h2>
        <p class="lesson-desc">Generic mistakes that even experienced developers make!</p>
      </div>

      <div class="content-section">
        ${pitfallCard('Over-genericizing ‚Äî Making things generic when they don\'t need to be', `
          <div class="comparison">
            <div class="col bad">
              <div class="col-title">‚ùå Over-engineered</div>
              ${codeBlock(`
// Unnecessary generic ‚Äî T is always string
function greet<T extends string>(
  name: T
): string {
  return "Hello, " + name;
}
              `)}
            </div>
            <div class="col good">
              <div class="col-title">‚úÖ Simple & Clear</div>
              ${codeBlock(`
// Just use the type directly!
function greet(
  name: string
): string {
  return "Hello, " + name;
}
              `)}
            </div>
          </div>
          <p style="color:var(--tx2);font-size:.88rem;margin-top:.75rem"><strong>Rule:</strong> Only use generics when you need to <em>relate</em> input types to output types, or when the type is truly variable.</p>
        `)}

        ${pitfallCard('Forgetting that generics erase to their constraint', `
          ${codeBlock(`
// ‚ùå Common mistake: expecting T to be narrower than the constraint
function process<T extends { name: string }>(obj: T): T {
  // return { name: obj.name }; // ‚ùå Error!
  // { name: string } is not assignable to T
  // T might have MORE properties than just { name }
  
  return obj; // ‚úÖ Must return the original T
}

// T could be { name: string, age: number, email: string }
// Returning just { name } would lose the extra properties!
          `, 'TypeScript')}
        `)}

        ${pitfallCard('Using generics with React components (arrow function ambiguity)', `
          ${codeBlock(`
// ‚ùå In .tsx files, this looks like JSX!
// const identity = <T>(value: T): T => value;

// ‚úÖ Fix 1: Add trailing comma
const identity = <T,>(value: T): T => value;

// ‚úÖ Fix 2: Add extends constraint
const identity2 = <T extends unknown>(value: T): T => value;

// ‚úÖ Fix 3: Use function keyword
function identity3<T>(value: T): T { return value; }
          `, 'TypeScript')}
        `)}
      </div>
    `
  }
  ]
},
// ============== MODULE 4: TS CONFIGURATION ==============
{
  id: 'config', title: 'TS Configuration', icon: '‚öôÔ∏è',
  lessons: [
  {
    id: 'tsconfig-basics', title: 'tsconfig.json Basics',
    render: () => `
      <div class="lesson-header">
        <div class="breadcrumb">Module 4 ‚Üí <span>tsconfig.json Basics</span></div>
        <h2>‚öôÔ∏è tsconfig.json ‚Äî Your TypeScript Control Panel</h2>
        <p class="lesson-desc">The tsconfig.json file configures how TypeScript compiles your code.</p>
      </div>

      <div class="content-section">
        <h3><span class="emoji">üìÑ</span> Creating a tsconfig.json</h3>
        ${codeBlock(`
// Run this to generate a default tsconfig.json
// npx tsc --init
        `, 'Terminal')}

        <h3><span class="emoji">üèóÔ∏è</span> Basic Structure</h3>
        ${codeBlock(`
{
  "compilerOptions": {
    "target": "ES2020",          // JS version to compile to
    "module": "commonjs",         // Module system
    "strict": true,               // Enable all strict checks
    "outDir": "./dist",           // Output directory
    "rootDir": "./src",           // Source directory
    "esModuleInterop": true,      // Better import compatibility
    "skipLibCheck": true,         // Skip type checking .d.ts files
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src/**/*"],        // Files to compile
  "exclude": ["node_modules", "dist"]  // Files to ignore
}
        `, 'JSON')}

        <h3><span class="emoji">üéØ</span> Key Concepts</h3>
        <div class="key-points">
          <div class="key-point">
            <div class="bullet">1</div>
            <div class="text"><strong>compilerOptions</strong> ‚Äî How TypeScript compiles your code (target, module system, strictness, etc.)</div>
          </div>
          <div class="key-point">
            <div class="bullet">2</div>
            <div class="text"><strong>include</strong> ‚Äî Glob patterns specifying which files to compile</div>
          </div>
          <div class="key-point">
            <div class="bullet">3</div>
            <div class="text"><strong>exclude</strong> ‚Äî Glob patterns for files to skip</div>
          </div>
          <div class="key-point">
            <div class="bullet">4</div>
            <div class="text"><strong>extends</strong> ‚Äî Inherit from another tsconfig (great for monorepos)</div>
          </div>
        </div>

        ${codeBlock(`
// Extending a base config (monorepo pattern)
// tsconfig.base.json
{
  "compilerOptions": {
    "strict": true,
    "target": "ES2020",
    "moduleResolution": "node"
  }
}

// packages/api/tsconfig.json
{
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src"
  },
  "include": ["src"]
}
        `, 'JSON')}
      </div>

      ${quizBlock('q-tsconfig', [
        {
          q: 'What does <code>"target": "ES2020"</code> mean?',
          opts: [
            'Only compile files from 2020',
            'Compile TypeScript to ES2020-compatible JavaScript',
            'Use ES2020 type definitions',
            'Only run on browsers from 2020+'
          ],
          correct: 1,
          explanation: 'The target option tells TypeScript what version of JavaScript to output. ES2020 means the compiled JS can use features available in ES2020.'
        }
      ])}
    `
  },
  {
    id: 'compiler-options', title: 'Key Compiler Options',
    render: () => `
      <div class="lesson-header">
        <div class="breadcrumb">Module 4 ‚Üí <span>Key Compiler Options</span></div>
        <h2>üîß Essential Compiler Options</h2>
        <p class="lesson-desc">Understand the most important options that affect your TypeScript experience.</p>
      </div>

      <div class="content-section">
        <h3><span class="emoji">üéØ</span> target ‚Äî JavaScript Version</h3>
        ${codeBlock(`
// TypeScript Input
const greet = (name: string): string => \`Hello, \${name}\`;

// Output with target: "ES5"
var greet = function(name) { return "Hello, " + name; };

// Output with target: "ES2020"
const greet = (name) => \`Hello, \${name}\`;

// Common targets:
// "ES5"    ‚Äî Max compatibility (IE11)
// "ES2015" ‚Äî Classes, arrow functions, let/const
// "ES2020" ‚Äî Optional chaining, nullish coalescing
// "ES2022" ‚Äî Top-level await, class fields
// "ESNext" ‚Äî Latest features
        `, 'TypeScript / JavaScript')}

        <h3><span class="emoji">üì¶</span> module ‚Äî Module System</h3>
        ${codeBlock(`
// "commonjs" ‚Äî Node.js (require/module.exports)
// "es2015"/"es2020"/"esnext" ‚Äî ES Modules (import/export)
// "node16"/"nodenext" ‚Äî Node.js ESM support

// Your choice depends on your runtime:
{
  // Node.js backend:
  "module": "commonjs",
  
  // Modern frontend (Vite, Next.js, etc.):
  "module": "esnext",
  
  // Node.js with ESM:
  "module": "node16"
}
        `, 'JSON')}

        <h3><span class="emoji">üîç</span> moduleResolution ‚Äî How Imports Are Resolved</h3>
        ${codeBlock(`
{
  // Classic ‚Äî Legacy, don't use for new projects
  "moduleResolution": "classic",
  
  // Node ‚Äî Standard Node.js resolution (node_modules)
  "moduleResolution": "node",
  
  // Node16/NodeNext ‚Äî Modern Node.js with ESM
  "moduleResolution": "node16",
  
  // Bundler ‚Äî For webpack, Vite, esbuild, etc.
  "moduleResolution": "bundler"
}
        `, 'JSON')}

        <h3><span class="emoji">üìÇ</span> Path & Output Options</h3>
        ${codeBlock(`
{
  "compilerOptions": {
    "rootDir": "./src",           // Where your source files are
    "outDir": "./dist",           // Where compiled JS goes
    "declaration": true,          // Generate .d.ts files
    "declarationDir": "./types",  // Where .d.ts files go
    "sourceMap": true,            // Generate .map files for debugging
    
    // Path aliases (like @ for src/)
    "baseUrl": ".",
    "paths": {
      "@/*": ["src/*"],
      "@components/*": ["src/components/*"],
      "@utils/*": ["src/utils/*"]
    }
  }
}
        `, 'JSON')}

        ${codeBlock(`
// With path aliases configured, you can write:
import { Button } from "@components/Button";
import { formatDate } from "@utils/date";

// Instead of:
import { Button } from "../../../components/Button";
import { formatDate } from "../../utils/date";
        `)}
      </div>

      ${quizBlock('q-compiler', [
        {
          q: 'What does <code>"declaration": true</code> generate?',
          opts: [
            'Declaration files (.d.ts) with type information',
            'README.md files',
            'Package.json files',
            'Test files'
          ],
          correct: 0,
          explanation: 'declaration: true generates .d.ts files that contain only type information. These are used by other TypeScript projects that consume your library.'
        }
      ])}
    `
  },
  {
    id: 'strict-mode', title: 'Strict Mode',
    render: () => `
      <div class="lesson-header">
        <div class="breadcrumb">Module 4 ‚Üí <span>Strict Mode</span></div>
        <h2>üõ°Ô∏è Strict Mode ‚Äî Maximum Safety</h2>
        <p class="lesson-desc">Strict mode is a collection of compiler flags that catch more bugs. <strong>Always enable it!</strong></p>
      </div>

      <div class="content-section">
        <h3><span class="emoji">üîí</span> What <code>"strict": true</code> Enables</h3>
        <p>Setting <code>"strict": true</code> is a shorthand that enables ALL of these flags:</p>

        <table class="ts-table">
          <thead>
            <tr><th>Flag</th><th>What it does</th><th>Catches</th></tr>
          </thead>
          <tbody>
            <tr><td><code>strictNullChecks</code></td><td>null and undefined are separate types</td><td>Null reference errors</td></tr>
            <tr><td><code>noImplicitAny</code></td><td>Error on implicit any</td><td>Untyped variables</td></tr>
            <tr><td><code>strictFunctionTypes</code></td><td>Stricter function type checking</td><td>Unsafe function assignments</td></tr>
            <tr><td><code>strictBindCallApply</code></td><td>Check bind/call/apply args</td><td>Wrong arguments to bind()</td></tr>
            <tr><td><code>strictPropertyInitialization</code></td><td>Class properties must be initialized</td><td>Uninitialized properties</td></tr>
            <tr><td><code>noImplicitThis</code></td><td>Error when 'this' is implicitly any</td><td>Lost 'this' context</td></tr>
            <tr><td><code>alwaysStrict</code></td><td>Emit "use strict" in every file</td><td>Sloppy mode bugs</td></tr>
          </tbody>
        </table>

        <h3><span class="emoji">üî¥</span> strictNullChecks ‚Äî The Most Important Flag</h3>
        ${codeBlock(`
// Without strictNullChecks (DANGEROUS):
let name: string = null;      // ‚úÖ No error... but wrong!
name.toUpperCase();            // üí• Runtime crash!

// With strictNullChecks (SAFE):
// let name: string = null;   // ‚ùå Error: null is not assignable to string

let name: string | null = null;  // ‚úÖ Must be explicit
if (name !== null) {
  name.toUpperCase();             // ‚úÖ Safe ‚Äî TS knows it's string here
}

// Optional chaining works great with strict null checks
let length = name?.toUpperCase();  // string | undefined
        `)}

        <h3><span class="emoji">üî¥</span> noImplicitAny ‚Äî No Sneaky Any</h3>
        ${codeBlock(`
// Without noImplicitAny:
function add(a, b) {     // a and b are implicitly 'any'
  return a + b;           // Could be anything!
}

// With noImplicitAny:
// function add(a, b) {  // ‚ùå Error: Parameter 'a' implicitly has an 'any' type
//   return a + b;
// }

function add(a: number, b: number): number {  // ‚úÖ Must annotate!
  return a + b;
}
        `)}

        <div class="info-card danger">
          <div class="card-title">üö® ALWAYS USE STRICT MODE!</div>
          <p>There is <strong>no good reason</strong> to disable strict mode in a new project. Companies like Google, Microsoft, and Airbnb all use strict mode. If you're in an interview and don't mention strict mode, it's a red flag!</p>
        </div>

        <h3><span class="emoji">üìã</span> Recommended Production Config</h3>
        ${codeBlock(`
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "lib": ["ES2020"],
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "outDir": "./dist",
    "rootDir": "./src",
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noImplicitReturns": true
  },
  "include": ["src"],
  "exclude": ["node_modules", "dist", "**/*.test.ts"]
}
        `, 'JSON')}
      </div>

      ${quizBlock('q-strict', [
        {
          q: 'What happens with <code>strictNullChecks: true</code> when you write <code>let x: string = null</code>?',
          opts: [
            'It compiles fine',
            'TypeScript throws an error',
            'It becomes undefined instead',
            'It only warns'
          ],
          correct: 1,
          explanation: 'With strictNullChecks enabled, null is not assignable to string. You must use string | null if you want to allow null.'
        },
        {
          q: 'Should you enable strict mode for a new project?',
          opts: [
            'No, it\'s too restrictive',
            'Only for large projects',
            'Yes, ALWAYS for new projects',
            'Only if the team is experienced'
          ],
          correct: 2,
          explanation: 'Always enable strict mode for new projects. It catches entire categories of bugs and is the industry standard. The TypeScript team recommends it.'
        }
      ])}
    `
  },
  {
    id: 'pitfalls-4', title: '‚ö†Ô∏è Pitfalls & Mistakes',
    render: () => `
      <div class="lesson-header">
        <h2>‚ö†Ô∏è Common Pitfalls ‚Äî Configuration</h2>
        <p class="lesson-desc">Configuration mistakes that lead to confusion and bugs!</p>
      </div>

      <div class="content-section">
        ${pitfallCard('Not enabling strict mode', `
          <div class="comparison">
            <div class="col bad">
              <div class="col-title">‚ùå Lenient (bugs hide here)</div>
              ${codeBlock(`
{
  "compilerOptions": {
    "target": "ES2020"
    // No strict mode! üò±
  }
}
// null errors, implicit any, and more
// will slip through undetected
              `, 'JSON')}
            </div>
            <div class="col good">
              <div class="col-title">‚úÖ Strict (bugs caught early)</div>
              ${codeBlock(`
{
  "compilerOptions": {
    "target": "ES2020",
    "strict": true  // üõ°Ô∏è Safety ON!
  }
}
// TypeScript catches null errors,
// missing types, and more at compile time
              `, 'JSON')}
            </div>
          </div>
        `)}

        ${pitfallCard('Wrong target for your environment', `
          ${codeBlock(`
// ‚ùå Using ES2022 features but targeting ES5
{
  "compilerOptions": {
    "target": "ES5"   // Old target
  }
}
// Your code uses optional chaining (a?.b)
// But ES5 doesn't support it!
// TypeScript WILL downcompile it, but some features
// can't be polyfilled (WeakRef, etc.)

// ‚úÖ Match your target to your deployment environment:
// Browser (modern): "ES2020" or "ES2022"
// Node 16+:         "ES2020"
// Node 18+:         "ES2022"
// Legacy browsers:  "ES5" or "ES2015"
          `, 'JSON')}
        `)}

        ${pitfallCard('Path aliases without bundler configuration', `
          ${codeBlock(`
// ‚ùå Setting paths in tsconfig but forgetting the bundler
{
  "compilerOptions": {
    "paths": {
      "@/*": ["src/*"]  // TS understands this...
    }
  }
}

// BUT TypeScript doesn't rewrite imports!
// The compiled JS will still have @/ imports
// which Node.js/browser won't understand!

// ‚úÖ Also configure your bundler:
// - Webpack: resolve.alias
// - Vite: resolve.alias
// - Jest: moduleNameMapper
// - Node.js: --experimental-specifier-resolution
// Or use: tsconfig-paths package for Node.js
          `, 'JSON')}
        `)}

        ${pitfallCard('Forgetting <code>"esModuleInterop": true</code>', `
          ${codeBlock(`
// Without esModuleInterop:
// ‚ùå This common pattern doesn't work:
// import express from "express";
// Must use ugly namespace import:
// import * as express from "express";

// ‚úÖ With esModuleInterop: true
// import express from "express"; // Works! üéâ
// import React from "react";     // Works! üéâ

// ALWAYS enable this. It's rare to not want it.
{
  "compilerOptions": {
    "esModuleInterop": true
  }
}
          `, 'JSON')}
        `)}
      </div>

      <div class="completion-banner fade-in">
        <div class="big-icon">üéì</div>
        <h3>Congratulations! You've covered all modules!</h3>
        <p>Keep practicing by going through the quizzes and exercises. Each module's pitfalls section is great for interview prep!</p>
      </div>
    `
  }
  ]
}
];

// ============== HELPER FUNCTIONS ==============
function quizBlock(id, questions) {
  let html = `<div class="quiz-container"><h4>üìù Knowledge Check</h4>`;
  questions.forEach((q, qi) => {
    const qid = id + '-' + qi;
    html += `<div class="quiz-q" id="${qid}">
      <div class="q-text"><span class="q-num">Q${qi + 1}.</span> ${q.q}</div>
      <div class="quiz-options">`;
    q.opts.forEach((opt, oi) => {
      html += `<div class="quiz-opt" data-qid="${qid}" data-oi="${oi}" data-correct="${q.correct}" onclick="selectQuizOption(this, '${qid}', ${oi}, ${q.correct})">
        <span class="radio"></span>
        <span>${opt}</span>
      </div>`;
    });
    html += `</div>
      <div class="quiz-explanation" id="${qid}-exp">${q.explanation}</div>
    </div>`;
  });
  html += `</div>`;
  return html;
}

function exerciseBlock(id, instructions, starter, answer, hint) {
  return `<div class="exercise-box" id="${id}">
    <h4>üí™ Exercise</h4>
    <p class="instructions">${instructions}</p>
    <textarea class="exercise-input" id="${id}-input" placeholder="Type your answer here..." rows="4">${starter}</textarea>
    <div style="margin-top:.75rem;display:flex;gap:.5rem;flex-wrap:wrap">
      <button class="btn btn-primary btn-sm" onclick="checkExercise('${id}', ${JSON.stringify(answer).replace(/'/g, "\\'")})"">Check Answer</button>
      <button class="btn btn-outline btn-sm" onclick="showHint('${id}', '${hint.replace(/'/g, "\\'")}')">üí° Hint</button>
      <button class="btn btn-outline btn-sm" onclick="showAnswer('${id}', ${JSON.stringify(answer).replace(/'/g, "\\'")})">üëÄ Show Answer</button>
    </div>
    <div class="exercise-feedback" id="${id}-feedback"></div>
  </div>`;
}

function pitfallCard(title, content) {
  const id = 'pit-' + Math.random().toString(36).substr(2, 6);
  return `<div class="pitfall-card">
    <div class="pitfall-header" onclick="togglePitfall('${id}')">
      <span class="warning-icon">‚ö†Ô∏è</span>
      <span class="title">${title}</span>
      <span class="toggle" id="${id}-toggle">‚ñº</span>
    </div>
    <div class="pitfall-body" id="${id}-body">${content}</div>
  </div>`;
}

// ============== RENDER FUNCTIONS ==============
function renderNav() {
  const nav = document.getElementById('nav-modules');
  let html = '';
  modules.forEach((mod, mi) => {
    const isActive = state.currentModule === mi;
    const allDone = mod.lessons.every((_, li) => state.completed.has(mi + '-' + li));
    html += `<div class="nav-module">
      <button class="nav-module-title ${isActive ? 'active' : ''}" onclick="toggleModule(${mi})">
        <span class="icon">${mod.icon}</span>
        <span>${mod.title}</span>
        <span class="check ${allDone ? 'done' : ''}">‚úì</span>
      </button>
      <div class="nav-lessons ${isActive ? 'open' : ''}" id="nav-lessons-${mi}">`;
    mod.lessons.forEach((lesson, li) => {
      const isLessonActive = isActive && state.currentLesson === li;
      const isCompleted = state.completed.has(mi + '-' + li);
      html += `<button class="nav-lesson ${isLessonActive ? 'active' : ''} ${isCompleted ? 'completed' : ''}" onclick="goTo(${mi}, ${li})">
        <span class="dot"></span>
        <span>${lesson.title}</span>
      </button>`;
    });
    html += `</div></div>`;
  });
  nav.innerHTML = html;
}

function renderLesson() {
  const mod = modules[state.currentModule];
  const lesson = mod.lessons[state.currentLesson];
  const main = document.getElementById('main');

  let html = lesson.render();

  // Navigation buttons
  const isFirst = state.currentModule === 0 && state.currentLesson === 0;
  const isLast = state.currentModule === modules.length - 1 && state.currentLesson === mod.lessons.length - 1;

  html += `<div class="lesson-nav">
    ${!isFirst ? '<button class="btn btn-outline" onclick="prevLesson()">‚Üê Previous</button>' : '<div></div>'}
    <button class="btn btn-success" onclick="completeAndNext()">
      ${isLast ? 'üéâ Complete Course!' : 'Complete & Next ‚Üí'}
    </button>
  </div>`;

  main.innerHTML = html;
  main.scrollTo(0, 0);
  window.scrollTo(0, 0);
}

function goTo(mi, li) {
  state.currentModule = mi;
  state.currentLesson = li;
  renderNav();
  renderLesson();
  closeSidebar();
}

function toggleModule(mi) {
  if (state.currentModule === mi) return;
  state.currentModule = mi;
  state.currentLesson = 0;
  renderNav();
  renderLesson();
}

function prevLesson() {
  if (state.currentLesson > 0) {
    state.currentLesson--;
  } else if (state.currentModule > 0) {
    state.currentModule--;
    state.currentLesson = modules[state.currentModule].lessons.length - 1;
  }
  renderNav();
  renderLesson();
}

function nextLesson() {
  const mod = modules[state.currentModule];
  if (state.currentLesson < mod.lessons.length - 1) {
    state.currentLesson++;
  } else if (state.currentModule < modules.length - 1) {
    state.currentModule++;
    state.currentLesson = 0;
  }
  renderNav();
  renderLesson();
}

function completeAndNext() {
  const key = state.currentModule + '-' + state.currentLesson;
  markComplete(key);
  const mod = modules[state.currentModule];
  const isLast = state.currentModule === modules.length - 1 && state.currentLesson === mod.lessons.length - 1;
  if (!isLast) nextLesson();
  else {
    renderNav();
    renderLesson();
  }
}

// ============== QUIZ LOGIC ==============
function selectQuizOption(el, qid, oi, correct) {
  if (state.quizAnswers[qid] !== undefined) return; // Already answered
  state.quizAnswers[qid] = oi;
  state.totalAnswered++;

  const options = document.querySelectorAll(`[data-qid="${qid}"]`);
  options.forEach((opt, idx) => {
    if (idx === correct) opt.classList.add('correct');
    else if (idx === oi && oi !== correct) opt.classList.add('wrong');
  });

  const exp = document.getElementById(qid + '-exp');
  if (oi === correct) {
    exp.classList.add('correct', 'show');
    exp.innerHTML = '‚úÖ Correct! ' + exp.innerHTML;
    state.totalCorrect++;
    addXP(15);
  } else {
    exp.classList.add('wrong', 'show');
    exp.innerHTML = '‚ùå Incorrect. ' + exp.innerHTML;
  }
  updateXP();
}

// ============== EXERCISE LOGIC ==============
function checkExercise(id, answer) {
  const input = document.getElementById(id + '-input').value.trim();
  const fb = document.getElementById(id + '-feedback');
  const normalized = s => s.replace(/\s+/g, ' ').replace(/;\s*/g, ';').trim().toLowerCase();

  if (normalized(input) === normalized(answer)) {
    fb.className = 'exercise-feedback show correct';
    fb.textContent = 'üéâ Correct! Great job!';
    addXP(20);
  } else {
    fb.className = 'exercise-feedback show wrong';
    fb.textContent = '‚ùå Not quite. Check the hint or show the answer to compare.';
  }
}

function showHint(id, hint) {
  const fb = document.getElementById(id + '-feedback');
  fb.className = 'exercise-feedback show';
  fb.style.background = 'rgba(127,90,240,.1)';
  fb.style.color = 'var(--blue)';
  fb.style.border = '1px solid rgba(127,90,240,.3)';
  fb.textContent = 'üí° ' + hint;
}

function showAnswer(id, answer) {
  const input = document.getElementById(id + '-input');
  input.value = answer;
  const fb = document.getElementById(id + '-feedback');
  fb.className = 'exercise-feedback show';
  fb.style.background = 'rgba(44,182,125,.1)';
  fb.style.color = 'var(--cyan)';
  fb.style.border = '1px solid rgba(44,182,125,.3)';
  fb.textContent = 'üëÜ Answer revealed! Study it carefully and try to understand each part.';
}

// ============== PITFALL TOGGLE ==============
function togglePitfall(id) {
  const body = document.getElementById(id + '-body');
  const toggle = document.getElementById(id + '-toggle');
  body.classList.toggle('open');
  toggle.classList.toggle('open');
}

// ============== SIDEBAR TOGGLE ==============
function toggleSidebar() {
  document.getElementById('sidebar').classList.toggle('open');
}
function closeSidebar() {
  document.getElementById('sidebar').classList.remove('open');
}

// ============== INIT ==============
renderNav();
renderLesson();
updateXP();

// Close sidebar on outside click (mobile)
document.getElementById('main').addEventListener('click', closeSidebar);
</script>
</body>
</html>