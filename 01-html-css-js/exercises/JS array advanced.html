<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>üöÄ Array Advanced Methods Mastery</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
:root{
  --bg:#0a0e17;--bg2:#131a2b;--bg3:#1a2340;--sidebar:#0d1220;
  --text:#e0e6f0;--dim:#7a8599;--accent:#4facfe;--accent2:#00f2fe;
  --purple:#a855f7;--green:#10b981;--red:#ef4444;--orange:#f59e0b;
  --yellow:#fbbf24;--border:#1e2a45;--code:#0b101d;
  --font-code:'Courier New',monospace;--sw:250px;
}
body{font-family:'Segoe UI',system-ui,sans-serif;background:var(--bg);color:var(--text);display:flex;min-height:100vh;overflow-x:hidden}
::-webkit-scrollbar{width:8px}::-webkit-scrollbar-track{background:var(--bg)}
::-webkit-scrollbar-thumb{background:var(--border);border-radius:4px}
::-webkit-scrollbar-thumb:hover{background:var(--accent)}

#sidebar{width:var(--sw);background:var(--sidebar);border-right:1px solid var(--border);
  position:fixed;top:0;left:0;height:100vh;overflow-y:auto;z-index:100;transition:transform .3s}
.logo{text-align:center;padding:15px 20px 20px;border-bottom:1px solid var(--border);margin-bottom:8px}
.logo h2{background:linear-gradient(135deg,var(--accent),var(--accent2));
  -webkit-background-clip:text;background-clip:text;-webkit-text-fill-color:transparent;font-size:1.1em}
.logo small{color:var(--dim);font-size:.75em}
.nav-item{padding:11px 20px;cursor:pointer;transition:all .2s;border-left:3px solid transparent;
  font-size:.9em;display:flex;align-items:center;gap:10px;user-select:none}
.nav-item:hover{background:rgba(79,172,254,.1);border-left-color:var(--accent)}
.nav-item.active{background:rgba(79,172,254,.15);border-left-color:var(--accent);color:var(--accent);font-weight:600}
.nav-item .badge{margin-left:auto;background:var(--green);color:#000;font-size:.65em;
  padding:2px 7px;border-radius:10px;font-weight:700;display:none}
.nav-item.completed .badge{display:inline}

#main{margin-left:var(--sw);flex:1;padding:30px 40px 60px;max-width:920px}
.section{display:none;animation:fadeIn .4s ease}.section.active{display:block}
@keyframes fadeIn{from{opacity:0;transform:translateY(12px)}to{opacity:1;transform:translateY(0)}}

h1{font-size:2em;margin-bottom:8px;background:linear-gradient(135deg,var(--accent),var(--purple));
  -webkit-background-clip:text;background-clip:text;-webkit-text-fill-color:transparent}
h2{font-size:1.4em;margin:28px 0 12px;color:var(--accent);padding-bottom:6px;border-bottom:1px solid var(--border)}
h3{font-size:1.15em;margin:18px 0 10px;color:var(--accent2)}
p{line-height:1.75;margin-bottom:14px}
.subtitle{color:var(--dim);font-size:1.05em;margin-bottom:22px}
ul{margin:10px 0 16px 20px;line-height:2}
code{background:rgba(79,172,254,.12);padding:2px 6px;border-radius:4px;font-family:var(--font-code);font-size:.88em;color:var(--accent2)}
strong{color:var(--accent)}

.code-block{background:var(--code);border:1px solid var(--border);border-radius:8px;
  padding:16px;margin:10px 0 18px;overflow-x:auto;font-family:var(--font-code);font-size:.88em;line-height:1.65;white-space:pre}
.cm{color:#6a737d}.kw{color:#ff7b72}.st{color:#a5d6ff}.nu{color:#79c0ff}
.mt{color:#d2a8ff}.bi{color:#ffa657}.fn{color:#e6edf3}

.playground{background:var(--bg2);border:1px solid var(--border);border-radius:10px;margin:14px 0 22px;overflow:hidden}
.pg-head{background:var(--bg3);padding:9px 14px;display:flex;align-items:center;justify-content:space-between;border-bottom:1px solid var(--border)}
.pg-head span{font-size:.82em;color:var(--dim)}
.run-btn{background:linear-gradient(135deg,var(--green),#059669);color:#fff;border:none;
  padding:6px 16px;border-radius:6px;cursor:pointer;font-weight:700;font-size:.82em;transition:all .15s}
.run-btn:hover{transform:scale(1.05);box-shadow:0 0 15px rgba(16,185,129,.4)}
.playground textarea{width:100%;background:var(--code);color:var(--text);border:none;
  padding:14px;font-family:var(--font-code);font-size:.88em;line-height:1.6;resize:vertical;min-height:70px;outline:none}
.output{padding:10px 14px;font-family:var(--font-code);font-size:.82em;line-height:1.5;
  border-top:1px solid var(--border);white-space:pre-wrap;min-height:24px;background:rgba(0,0,0,.2)}
.output.success{color:var(--green)}.output.error{color:var(--red)}

.visualizer{background:var(--bg2);border:1px solid var(--border);border-radius:12px;padding:22px;margin:18px 0}
.vis-array{display:flex;gap:8px;justify-content:center;margin:14px 0;flex-wrap:wrap}
.vis-item{width:58px;height:58px;display:flex;align-items:center;justify-content:center;
  border-radius:10px;font-weight:700;font-size:1.1em;transition:all .4s;border:2px solid transparent}
.vis-item.active{transform:scale(1.18);border-color:var(--accent);box-shadow:0 0 20px rgba(79,172,254,.4)}
.vis-item.done{opacity:.35;transform:scale(.88)}
.vis-controls{display:flex;gap:10px;justify-content:center;margin:14px 0}
.vis-controls button{background:var(--bg3);color:var(--text);border:1px solid var(--border);
  padding:8px 16px;border-radius:6px;cursor:pointer;font-size:.88em;transition:all .2s}
.vis-controls button:hover{background:var(--accent);color:#000;border-color:var(--accent)}
.vis-acc{text-align:center;margin:16px 0;padding:14px;background:rgba(168,85,247,.1);
  border:2px solid var(--purple);border-radius:10px}
.vis-acc .label{font-size:.82em;color:var(--purple);margin-bottom:4px}
.vis-acc .value{font-size:2em;font-weight:700;color:var(--purple);font-family:var(--font-code)}
.vis-step{text-align:center;font-family:var(--font-code);font-size:1.05em;margin:10px 0;
  padding:10px;background:rgba(79,172,254,.1);border-radius:8px;color:var(--accent);min-height:42px;
  display:flex;align-items:center;justify-content:center}

.quiz-card{background:var(--bg2);border:1px solid var(--border);border-radius:12px;padding:22px;margin:18px 0}
.quiz-card h3{margin-top:0}
.quiz-code{background:var(--code);padding:12px;border-radius:6px;font-family:var(--font-code);
  font-size:.88em;margin:10px 0;line-height:1.55;white-space:pre}
.quiz-options{display:grid;gap:9px;margin:14px 0}
.quiz-option{background:var(--bg3);border:2px solid var(--border);color:var(--text);
  padding:11px 14px;border-radius:8px;cursor:pointer;text-align:left;font-size:.92em;
  font-family:var(--font-code);transition:all .2s}
.quiz-option:hover:not(.chosen){border-color:var(--accent);background:rgba(79,172,254,.1)}
.quiz-option.correct{border-color:var(--green)!important;background:rgba(16,185,129,.15)!important;cursor:default}
.quiz-option.wrong{border-color:var(--red)!important;background:rgba(239,68,68,.15)!important;cursor:default}
.quiz-option.chosen{cursor:default}
.quiz-explain{display:none;margin-top:14px;padding:14px;border-radius:8px;line-height:1.6;font-size:.92em}
.quiz-explain.show{display:block}
.quiz-explain.ok{background:rgba(16,185,129,.1);border-left:3px solid var(--green);color:var(--green)}
.quiz-explain.no{background:rgba(239,68,68,.1);border-left:3px solid var(--red);color:var(--red)}

.pitfall{background:rgba(239,68,68,.05);border:1px solid rgba(239,68,68,.3);
  border-left:4px solid var(--red);border-radius:8px;padding:18px;margin:18px 0}
.pitfall h4{color:var(--red);margin-bottom:8px}
.tip-box{background:rgba(16,185,129,.05);border:1px solid rgba(16,185,129,.3);
  border-left:4px solid var(--green);border-radius:8px;padding:18px;margin:18px 0}
.tip-box h4{color:var(--green);margin-bottom:8px}
.info-box{background:rgba(79,172,254,.05);border:1px solid rgba(79,172,254,.3);
  border-left:4px solid var(--accent);border-radius:8px;padding:18px;margin:18px 0}
.info-box h4{color:var(--accent);margin-bottom:8px}

.exercise{background:var(--bg2);border:1px solid var(--border);border-radius:12px;padding:22px;margin:18px 0}
.exercise h3{color:var(--orange);margin-top:0}
.diff{display:inline-block;padding:2px 10px;border-radius:20px;font-size:.72em;font-weight:700;margin-left:8px;vertical-align:middle}
.diff.easy{background:rgba(16,185,129,.2);color:var(--green)}
.diff.med{background:rgba(245,158,11,.2);color:var(--orange)}
.diff.hard{background:rgba(239,68,68,.2);color:var(--red)}
.check-btn{background:linear-gradient(135deg,var(--orange),#d97706);color:#fff;border:none;
  padding:8px 20px;border-radius:6px;cursor:pointer;font-weight:700;font-size:.88em;margin-top:10px;transition:transform .1s}
.check-btn:hover{transform:scale(1.05)}
.ex-result{margin-top:10px;padding:10px;border-radius:6px;font-family:var(--font-code);font-size:.85em;white-space:pre-wrap}
.ex-result.pass{background:rgba(16,185,129,.1);color:var(--green);border:1px solid rgba(16,185,129,.3)}
.ex-result.fail{background:rgba(239,68,68,.1);color:var(--red);border:1px solid rgba(239,68,68,.3)}

#score-display{position:fixed;top:12px;right:18px;background:var(--bg2);border:1px solid var(--border);
  padding:7px 15px;border-radius:20px;font-size:.88em;z-index:200;display:flex;align-items:center;gap:8px}
#score-display .xp{color:var(--yellow);font-weight:700}
#progress-bar{position:fixed;top:0;left:var(--sw);right:0;height:3px;background:var(--border);z-index:150}
#progress-fill{height:100%;background:linear-gradient(90deg,var(--accent),var(--purple));transition:width .5s;width:0%}
#menu-toggle{display:none;position:fixed;top:10px;left:10px;z-index:200;background:var(--bg2);
  border:1px solid var(--border);color:var(--text);padding:8px 12px;border-radius:6px;cursor:pointer;font-size:1.2em}

.syntax-box{background:linear-gradient(135deg,rgba(79,172,254,.1),rgba(168,85,247,.1));
  border:1px solid rgba(79,172,254,.3);border-radius:10px;padding:14px 18px;margin:14px 0;
  font-family:var(--font-code);font-size:.95em;line-height:1.8}
.chain-step{display:flex;align-items:flex-start;margin:6px 0;padding:10px;background:var(--bg3);
  border-radius:8px;gap:10px;font-size:.9em;line-height:1.5}
.chain-arrow{color:var(--accent);font-size:1.3em;text-align:center;margin:2px 0 2px 20px}
.perf-bar-chart{display:flex;flex-direction:column;gap:10px;margin:14px 0}
.perf-row{display:flex;align-items:center;gap:10px}
.perf-label{width:160px;font-size:.82em;text-align:right;color:var(--dim)}
.perf-bar{height:28px;border-radius:6px;display:flex;align-items:center;padding:0 10px;
  font-size:.78em;font-weight:700;color:#000;transition:width 1s}

.flat-demo{padding:15px;background:var(--code);border-radius:8px;margin:10px 0;
  font-family:var(--font-code);min-height:55px;line-height:2}

@media(max-width:768px){
  #sidebar{transform:translateX(-100%)}#sidebar.open{transform:translateX(0)}
  #main{margin-left:0;padding:18px 16px 50px}#menu-toggle{display:block}
  #progress-bar{left:0}#score-display{font-size:.78em;padding:5px 10px}
}
</style>
</head>
<body>

<button id="menu-toggle" onclick="document.getElementById('sidebar').classList.toggle('open')">‚ò∞</button>
<div id="progress-bar"><div id="progress-fill"></div></div>
<div id="score-display">‚≠ê <span class="xp" id="xp-count">0</span> XP</div>

<nav id="sidebar">
  <div class="logo"><h2>üöÄ Array Mastery</h2><small>Advanced Methods</small></div>
  <div class="nav-item active" onclick="go('home')">üè† Home<span class="badge">‚úì</span></div>
  <div class="nav-item" onclick="go('reduce1')">üîß Reduce Basics<span class="badge">‚úì</span></div>
  <div class="nav-item" onclick="go('reduce2')">‚ö° Reduce Patterns<span class="badge">‚úì</span></div>
  <div class="nav-item" onclick="go('flat')">üìê Flat & FlatMap<span class="badge">‚úì</span></div>
  <div class="nav-item" onclick="go('chain')">üîó Method Chaining<span class="badge">‚úì</span></div>
  <div class="nav-item" onclick="go('perf')">üèéÔ∏è Performance<span class="badge">‚úì</span></div>
  <div class="nav-item" onclick="go('pitfalls')">‚ö†Ô∏è Pitfalls<span class="badge">‚úì</span></div>
  <div class="nav-item" onclick="go('exercises')">üí™ Exercises<span class="badge">‚úì</span></div>
  <div class="nav-item" onclick="go('quiz')">üèÜ Final Quiz<span class="badge">‚úì</span></div>
</nav>

<main id="main">

<!-- ============ HOME ============ -->
<section id="sec-home" class="section active">
  <h1>üöÄ Array Advanced Methods</h1>
  <p class="subtitle">Master reduce, flat, flatMap, method chaining & performance to ace your interviews.</p>

  <div class="info-box">
    <h4>üìã What You'll Learn</h4>
    <ul>
      <li><strong>reduce()</strong> ‚Äî The most powerful array method (and its many patterns)</li>
      <li><strong>flat() & flatMap()</strong> ‚Äî Unwrap nested arrays like a pro</li>
      <li><strong>Method chaining</strong> ‚Äî Build elegant data pipelines</li>
      <li><strong>Performance</strong> ‚Äî Know when to optimize and when not to</li>
      <li><strong>Pitfalls</strong> ‚Äî The mistakes that trip up even experienced devs</li>
    </ul>
  </div>

  <div class="tip-box">
    <h4>üéÆ How to Use This App</h4>
    <p>Navigate sections using the sidebar. Every section has <strong>interactive code playgrounds</strong> ‚Äî edit & run code right in your browser! Complete exercises and quizzes to earn ‚≠ê XP. Aim for the maximum score!</p>
  </div>

  <h2>Quick Refresher: Array Method Categories</h2>
  <div class="code-block"><span class="cm">// Searching</span>
find, findIndex, indexOf, includes, some, every

<span class="cm">// Transforming (return new array)</span>
map, filter, slice, concat, flat, flatMap

<span class="cm">// Reducing (return single value)</span>
reduce, reduceRight

<span class="cm">// Mutating (change original)</span>
push, pop, shift, unshift, splice, sort, reverse

<span class="cm">// Iterating</span>
forEach, entries, keys, values</div>

  <p>Ready? Let's start with the most powerful one ‚Äî <strong>reduce()</strong>! Click <em>Reduce Basics</em> in the sidebar. üëâ</p>
</section>

<!-- ============ REDUCE BASICS ============ -->
<section id="sec-reduce1" class="section">
  <h1>üîß Reduce: The Swiss Army Knife</h1>
  <p class="subtitle">reduce() can do everything ‚Äî sum, group, transform, flatten... anything.</p>

  <h2>Syntax</h2>
  <div class="syntax-box">
array.<span class="mt">reduce</span>(<span class="bi">callback</span>, <span class="bi">initialValue</span>)

<span class="cm">// callback receives:</span>
(<span class="bi">accumulator</span>, <span class="bi">currentValue</span>, <span class="bi">index</span>, <span class="bi">array</span>) => <span class="bi">newAccumulator</span>
  </div>

  <p>Think of reduce as a <strong>snowball rolling downhill</strong> üèîÔ∏è‚ùÑÔ∏è. It starts with an initial value (the snowball) and picks up each element as it goes, getting bigger and bigger until you have your final result.</p>

  <h2>üé¨ Visual: Watch Reduce in Action</h2>
  <div class="visualizer" id="reduce-viz">
    <div style="text-align:center;margin-bottom:8px;color:var(--dim);font-size:.9em">
      <code>[10, 20, 30, 40, 50].reduce((acc, curr) => acc + curr, 0)</code>
    </div>
    <div class="vis-array" id="viz-array"></div>
    <div class="vis-step" id="viz-step">Click "Next" or "Play" to start</div>
    <div class="vis-acc"><div class="label">Accumulator</div><div class="value" id="viz-acc-val">0</div></div>
    <div class="vis-controls">
      <button onclick="vizReset()">‚Ü∫ Reset</button>
      <button onclick="vizPrev()">‚óÑ Prev</button>
      <button onclick="vizNext()">Next ‚ñ∫</button>
      <button onclick="vizPlay()" id="viz-play-btn">‚ñ∂ Play</button>
    </div>
  </div>

  <h2>Basic Examples</h2>

  <h3>1. Sum of Numbers</h3>
  <div class="code-block"><span class="kw">const</span> nums = [<span class="nu">1</span>, <span class="nu">2</span>, <span class="nu">3</span>, <span class="nu">4</span>, <span class="nu">5</span>];

<span class="kw">const</span> sum = nums.<span class="mt">reduce</span>((<span class="bi">acc</span>, <span class="bi">curr</span>) => acc + curr, <span class="nu">0</span>);
<span class="bi">console</span>.<span class="mt">log</span>(sum); <span class="cm">// 15</span></div>

  <h3>2. Find Maximum</h3>
  <div class="code-block"><span class="kw">const</span> max = [<span class="nu">3</span>, <span class="nu">7</span>, <span class="nu">2</span>, <span class="nu">9</span>, <span class="nu">4</span>].<span class="mt">reduce</span>((<span class="bi">a</span>, <span class="bi">b</span>) => a > b ? a : b);
<span class="bi">console</span>.<span class="mt">log</span>(max); <span class="cm">// 9</span>

<span class="cm">// Note: No initial value! reduce uses first element as starting accumulator</span></div>

  <h3>3. Count Occurrences (Frequency Map)</h3>
  <div class="code-block"><span class="kw">const</span> fruits = [<span class="st">'apple'</span>, <span class="st">'banana'</span>, <span class="st">'apple'</span>, <span class="st">'cherry'</span>, <span class="st">'banana'</span>, <span class="st">'apple'</span>];

<span class="kw">const</span> count = fruits.<span class="mt">reduce</span>((<span class="bi">acc</span>, <span class="bi">fruit</span>) => {
  acc[fruit] = (acc[fruit] || <span class="nu">0</span>) + <span class="nu">1</span>;
  <span class="kw">return</span> acc;
}, {});

<span class="cm">// { apple: 3, banana: 2, cherry: 1 }</span></div>

  <h3>‚ñ∂ Try It Yourself</h3>
  <div class="playground">
    <div class="pg-head"><span>üíª Playground ‚Äî Reduce Basics</span><button class="run-btn" onclick="runPG('pg1')">Run ‚ñ∂</button></div>
    <textarea id="pg1">const prices = [29.99, 9.99, 4.99, 19.99];

// Calculate total price
const total = prices.reduce((acc, price) => acc + price, 0);
console.log('Total:', total.toFixed(2));

// Find the cheapest item
const cheapest = prices.reduce((min, p) => p < min ? p : min);
console.log('Cheapest:', cheapest);

// Count items over $10
const expensive = prices.reduce((count, p) => p > 10 ? count + 1 : count, 0);
console.log('Items over $10:', expensive);</textarea>
    <div id="pg1-out" class="output"></div>
  </div>

  <h2>The Initial Value Matters!</h2>
  <p>The initial value determines the <strong>type</strong> of your result:</p>
  <div class="code-block"><span class="cm">// Number ‚Üí use 0</span>
[<span class="nu">1</span>,<span class="nu">2</span>,<span class="nu">3</span>].<span class="mt">reduce</span>((a, c) => a + c, <span class="nu">0</span>)       <span class="cm">// 6</span>

<span class="cm">// String ‚Üí use ''</span>
[<span class="nu">1</span>,<span class="nu">2</span>,<span class="nu">3</span>].<span class="mt">reduce</span>((a, c) => a + c, <span class="st">''</span>)      <span class="cm">// "123"</span>

<span class="cm">// Array ‚Üí use []</span>
[<span class="nu">1</span>,<span class="nu">2</span>,<span class="nu">3</span>].<span class="mt">reduce</span>((a, c) => [...a, c*<span class="nu">2</span>], []) <span class="cm">// [2, 4, 6]</span>

<span class="cm">// Object ‚Üí use {}</span>
[<span class="nu">1</span>,<span class="nu">2</span>,<span class="nu">3</span>].<span class="mt">reduce</span>((a, c) => ({...a, [c]: c*c}), {}) <span class="cm">// {1:1, 2:4, 3:9}</span>

<span class="cm">// Boolean ‚Üí use true/false</span>
[<span class="nu">2</span>,<span class="nu">4</span>,<span class="nu">6</span>].<span class="mt">reduce</span>((a, c) => a && c%<span class="nu">2</span>===<span class="nu">0</span>, <span class="kw">true</span>) <span class="cm">// true</span></div>

  <div class="pitfall">
    <h4>‚ö†Ô∏è Pitfall: Forgetting the Initial Value</h4>
    <div class="code-block"><span class="cm">// ‚ùå DANGER ‚Äî empty array without initial value throws!</span>
[].<span class="mt">reduce</span>((a, c) => a + c);
<span class="cm">// TypeError: Reduce of empty array with no initial value</span>

<span class="cm">// ‚úÖ SAFE ‚Äî always provide initial value</span>
[].<span class="mt">reduce</span>((a, c) => a + c, <span class="nu">0</span>);  <span class="cm">// 0</span></div>
    <p>üí° <strong>Rule of thumb:</strong> Always provide an initial value unless you're 100% sure the array is non-empty AND you want element type as accumulator.</p>
  </div>
</section>

<!-- ============ REDUCE PATTERNS ============ -->
<section id="sec-reduce2" class="section">
  <h1>‚ö° Reduce Power Patterns</h1>
  <p class="subtitle">Real-world patterns that will make you a reduce ninja.</p>

  <h2>Pattern 1: Group By</h2>
  <p>One of the most common interview questions and real-world tasks.</p>
  <div class="playground">
    <div class="pg-head"><span>üíª Group By</span><button class="run-btn" onclick="runPG('pg2')">Run ‚ñ∂</button></div>
    <textarea id="pg2">const people = [
  { name: 'Alice', dept: 'Engineering' },
  { name: 'Bob', dept: 'Marketing' },
  { name: 'Charlie', dept: 'Engineering' },
  { name: 'Diana', dept: 'Marketing' },
  { name: 'Eve', dept: 'Design' }
];

const byDept = people.reduce((groups, person) => {
  const key = person.dept;
  if (!groups[key]) groups[key] = [];
  groups[key].push(person.name);
  return groups;
}, {});

console.log(JSON.stringify(byDept, null, 2));</textarea>
    <div id="pg2-out" class="output"></div>
  </div>

  <h2>Pattern 2: Array to Object (Index By)</h2>
  <div class="code-block"><span class="kw">const</span> users = [
  { id: <span class="nu">1</span>, name: <span class="st">'Alice'</span> },
  { id: <span class="nu">2</span>, name: <span class="st">'Bob'</span> },
  { id: <span class="nu">3</span>, name: <span class="st">'Charlie'</span> }
];

<span class="kw">const</span> usersById = users.<span class="mt">reduce</span>((acc, user) => {
  acc[user.id] = user;
  <span class="kw">return</span> acc;
}, {});

<span class="cm">// { 1: { id: 1, name: 'Alice' }, 2: { id: 2, ... }, ... }</span>
<span class="cm">// Now O(1) lookup: usersById[2].name ‚Üí 'Bob'</span></div>

  <h2>Pattern 3: Pipeline / Compose</h2>
  <div class="playground">
    <div class="pg-head"><span>üíª Function Pipeline</span><button class="run-btn" onclick="runPG('pg3')">Run ‚ñ∂</button></div>
    <textarea id="pg3">const pipe = (...fns) => (x) =>
  fns.reduce((val, fn) => fn(val), x);

// Build a text processing pipeline
const processText = pipe(
  str => str.trim(),
  str => str.toLowerCase(),
  str => str.replace(/[^a-z0-9 ]/g, ''),
  str => str.split(' ').filter(Boolean),
  words => words.join('-')
);

console.log(processText('  Hello, World! This is FUN!  '));
// "hello-world-this-is-fun"

// Math pipeline
const calculate = pipe(
  x => x * 2,
  x => x + 10,
  x => x / 3
);
console.log(calculate(5)); // (5*2+10)/3 = 6.666...</textarea>
    <div id="pg3-out" class="output"></div>
  </div>

  <h2>Pattern 4: Implement Map & Filter with Reduce</h2>
  <p>This proves reduce is the "mother of all array methods" ‚Äî you can build any other method with it!</p>
  <div class="playground">
    <div class="pg-head"><span>üíª Reduce is Universal</span><button class="run-btn" onclick="runPG('pg4')">Run ‚ñ∂</button></div>
    <textarea id="pg4">// map using reduce
const myMap = (arr, fn) =>
  arr.reduce((acc, item, i) => {
    acc.push(fn(item, i));
    return acc;
  }, []);

// filter using reduce
const myFilter = (arr, fn) =>
  arr.reduce((acc, item, i) => {
    if (fn(item, i)) acc.push(item);
    return acc;
  }, []);

// find using reduce
const myFind = (arr, fn) =>
  arr.reduce((found, item) =>
    found !== undefined ? found : fn(item) ? item : undefined
  , undefined);

const nums = [1, 2, 3, 4, 5, 6];
console.log('map x2:', myMap(nums, x => x * 2));
console.log('filter even:', myFilter(nums, x => x % 2 === 0));
console.log('find >3:', myFind(nums, x => x > 3));</textarea>
    <div id="pg4-out" class="output"></div>
  </div>

  <h2>Pattern 5: Running Total / Scan</h2>
  <div class="code-block"><span class="kw">const</span> monthly = [<span class="nu">100</span>, <span class="nu">200</span>, <span class="nu">150</span>, <span class="nu">300</span>, <span class="nu">250</span>];

<span class="cm">// Cumulative sum at each point</span>
<span class="kw">const</span> cumulative = monthly.<span class="mt">reduce</span>((acc, val) => {
  <span class="kw">const</span> running = (acc.length ? acc[acc.length - <span class="nu">1</span>] : <span class="nu">0</span>) + val;
  acc.<span class="mt">push</span>(running);
  <span class="kw">return</span> acc;
}, []);

<span class="cm">// [100, 300, 450, 750, 1000]</span></div>

  <h2>Pattern 6: Partition</h2>
  <div class="code-block"><span class="kw">const</span> partition = (arr, predicate) =>
  arr.<span class="mt">reduce</span>(([pass, fail], item) =>
    predicate(item) ? [[...pass, item], fail] : [pass, [...fail, item]]
  , [[], []]);

<span class="kw">const</span> [evens, odds] = partition([<span class="nu">1</span>,<span class="nu">2</span>,<span class="nu">3</span>,<span class="nu">4</span>,<span class="nu">5</span>,<span class="nu">6</span>], x => x % <span class="nu">2</span> === <span class="nu">0</span>);
<span class="cm">// evens: [2, 4, 6]</span>
<span class="cm">// odds:  [1, 3, 5]</span></div>

  <h2>Pattern 7: Deduplicate</h2>
  <div class="code-block"><span class="kw">const</span> unique = arr => arr.<span class="mt">reduce</span>((acc, item) =>
  acc.<span class="mt">includes</span>(item) ? acc : [...acc, item]
, []);

unique([<span class="nu">1</span>,<span class="nu">2</span>,<span class="nu">2</span>,<span class="nu">3</span>,<span class="nu">3</span>,<span class="nu">3</span>]); <span class="cm">// [1, 2, 3]</span>

<span class="cm">// But honestly, just use Set for this:</span>
[...new <span class="bi">Set</span>([<span class="nu">1</span>,<span class="nu">2</span>,<span class="nu">2</span>,<span class="nu">3</span>,<span class="nu">3</span>,<span class="nu">3</span>])]; <span class="cm">// [1, 2, 3]  ‚Üê simpler!</span></div>

  <div class="tip-box">
    <h4>üí° reduceRight()</h4>
    <p>Works exactly like <code>reduce()</code> but iterates from <strong>right to left</strong>. Useful for composing functions in reverse order:</p>
    <div class="code-block"><span class="kw">const</span> compose = (...fns) => (x) =>
  fns.<span class="mt">reduceRight</span>((val, fn) => fn(val), x);

<span class="cm">// compose(f, g, h)(x)  ‚Üí  f(g(h(x)))</span></div>
  </div>
</section>

<!-- ============ FLAT & FLATMAP ============ -->
<section id="sec-flat" class="section">
  <h1>üìê Flat & FlatMap</h1>
  <p class="subtitle">Unwrap nested arrays and perform one-to-many transformations.</p>

  <h2>Array.flat(depth)</h2>
  <div class="syntax-box">
array.<span class="mt">flat</span>(<span class="bi">depth</span>)  <span class="cm">// depth defaults to 1</span>
  </div>
  <p>Flattens nested arrays by the specified depth. Does <strong>not</strong> mutate the original array.</p>

  <h3>üé¨ Interactive Flat Demo</h3>
  <div class="visualizer">
    <p style="text-align:center;color:var(--dim);font-size:.9em;margin-bottom:12px">
      <code>[1, [2, 3], [4, [5, [6]]]]</code>
    </p>
    <div style="text-align:center;margin-bottom:12px;font-family:var(--font-code);font-size:.9em">
      <button class="run-btn" style="margin:4px" onclick="flatDemo(0)">Original</button>
      <button class="run-btn" style="margin:4px;background:linear-gradient(135deg,#4facfe,#00f2fe)" onclick="flatDemo(1)">.flat(1)</button>
      <button class="run-btn" style="margin:4px;background:linear-gradient(135deg,#a855f7,#6366f1)" onclick="flatDemo(2)">.flat(2)</button>
      <button class="run-btn" style="margin:4px;background:linear-gradient(135deg,#f59e0b,#ef4444)" onclick="flatDemo(3)">.flat(Infinity)</button>
    </div>
    <div id="flat-result" class="flat-demo" style="font-size:1.1em;text-align:center;color:var(--accent2)">
      Click a button above to see the result!
    </div>
  </div>

  <h3>Examples</h3>
  <div class="playground">
    <div class="pg-head"><span>üíª flat() Examples</span><button class="run-btn" onclick="runPG('pg5')">Run ‚ñ∂</button></div>
    <textarea id="pg5">// Basic flattening
console.log([1, [2, 3], [4, 5]].flat());
// [1, 2, 3, 4, 5]

// Deeper nesting
console.log([1, [2, [3, [4]]]].flat(1));   // [1, 2, [3, [4]]]
console.log([1, [2, [3, [4]]]].flat(2));   // [1, 2, 3, [4]]
console.log([1, [2, [3, [4]]]].flat(Infinity)); // [1, 2, 3, 4]

// Bonus: flat() removes empty slots!
console.log([1, , 3, , 5].flat());  // [1, 3, 5]

// Real-world: merge sub-arrays
const matrix = [[1,2,3], [4,5,6], [7,8,9]];
console.log('Flattened matrix:', matrix.flat());</textarea>
    <div id="pg5-out" class="output"></div>
  </div>

  <h2>Array.flatMap(callback)</h2>
  <div class="syntax-box">
array.<span class="mt">flatMap</span>(<span class="bi">callback</span>)
<span class="cm">// Equivalent to: array.map(callback).flat(1)</span>
<span class="cm">// But more efficient ‚Äî single pass!</span>
  </div>
  <p>flatMap is perfect for <strong>one-to-many</strong> mappings and <strong>filter+map</strong> combos.</p>

  <h3>Key Insight: What flatMap Enables</h3>
  <div class="code-block"><span class="cm">// map:     1 element  ‚Üí  1 element</span>
<span class="cm">// flatMap: 1 element  ‚Üí  0, 1, or MANY elements</span>

<span class="cm">// Return []    ‚Üí element removed (like filter)</span>
<span class="cm">// Return [x]   ‚Üí element kept/transformed (like map)</span>
<span class="cm">// Return [x,y] ‚Üí element expanded into multiple!</span></div>

  <h3>Examples</h3>
  <div class="playground">
    <div class="pg-head"><span>üíª flatMap() Examples</span><button class="run-btn" onclick="runPG('pg6')">Run ‚ñ∂</button></div>
    <textarea id="pg6">// 1. Split sentences into words
const sentences = ["Hello world", "foo bar baz"];
console.log(sentences.flatMap(s => s.split(' ')));
// ["Hello", "world", "foo", "bar", "baz"]

// 2. Filter and map in ONE pass
const nums = [1, 2, 3, 4, 5, 6];
const doubledEvens = nums.flatMap(n =>
  n % 2 === 0 ? [n * 2] : []   // empty array = filtered out
);
console.log('Doubled evens:', doubledEvens); // [4, 8, 12]

// 3. Duplicate elements
console.log([1, 2, 3].flatMap(x => [x, x]));
// [1, 1, 2, 2, 3, 3]

// 4. Extract nested data
const users = [
  { name: 'Alice', hobbies: ['reading', 'coding'] },
  { name: 'Bob', hobbies: ['gaming', 'cooking', 'coding'] }
];
const allHobbies = users.flatMap(u => u.hobbies);
console.log('All hobbies:', allHobbies);
console.log('Unique:', [...new Set(allHobbies)]);</textarea>
    <div id="pg6-out" class="output"></div>
  </div>

  <div class="pitfall">
    <h4>‚ö†Ô∏è flatMap only flattens ONE level</h4>
    <div class="code-block"><span class="cm">// ‚ùå This won't work as expected for deeply nested results</span>
[[<span class="nu">1</span>,<span class="nu">2</span>], [<span class="nu">3</span>,[<span class="nu">4</span>]]].<span class="mt">flatMap</span>(x => x);
<span class="cm">// [1, 2, 3, [4]]  ‚Äî inner [4] NOT flattened!</span>

<span class="cm">// ‚úÖ Use .flat(Infinity) for deep flattening</span>
[[<span class="nu">1</span>,<span class="nu">2</span>], [<span class="nu">3</span>,[<span class="nu">4</span>]]].<span class="mt">flat</span>(<span class="bi">Infinity</span>);
<span class="cm">// [1, 2, 3, 4]</span></div>
  </div>
</section>

<!-- ============ METHOD CHAINING ============ -->
<section id="sec-chain" class="section">
  <h1>üîó Method Chaining Mastery</h1>
  <p class="subtitle">Build elegant data transformation pipelines.</p>

  <h2>The Power of Chaining</h2>
  <p>Since <code>map</code>, <code>filter</code>, <code>flat</code>, <code>flatMap</code>, <code>slice</code>, and <code>sort</code> all return new arrays, you can chain them together into powerful pipelines.</p>

  <h3>üé¨ Visual: Data Pipeline</h3>
  <div class="visualizer" style="padding:16px">
    <div class="chain-step">üì¶ <code>[{name:'Widget', price:25, inStock:true}, ...]</code></div>
    <div class="chain-arrow">‚Üì .filter(p => p.inStock)</div>
    <div class="chain-step">üì¶ <code>[{name:'Widget', price:25, inStock:true}, ...]</code> <span style="color:var(--green);margin-left:auto">only in-stock</span></div>
    <div class="chain-arrow">‚Üì .sort((a,b) => a.price - b.price)</div>
    <div class="chain-step">üì¶ <code>[{price:10,...}, {price:25,...}, {price:50,...}]</code> <span style="color:var(--accent);margin-left:auto">sorted cheap‚Üíexpensive</span></div>
    <div class="chain-arrow">‚Üì .slice(0, 3)</div>
    <div class="chain-step">üì¶ <code>[{price:10,...}, {price:25,...}, {price:30,...}]</code> <span style="color:var(--purple);margin-left:auto">top 3 cheapest</span></div>
    <div class="chain-arrow">‚Üì .map(p => `${p.name}: $${p.price}`)</div>
    <div class="chain-step">üéâ <code>["Bolt: $10", "Widget: $25", "Gear: $30"]</code> <span style="color:var(--yellow);margin-left:auto">formatted strings</span></div>
  </div>

  <h3>Real-World Example: E-Commerce</h3>
  <div class="playground">
    <div class="pg-head"><span>üíª E-Commerce Pipeline</span><button class="run-btn" onclick="runPG('pg7')">Run ‚ñ∂</button></div>
    <textarea id="pg7">const products = [
  { name: 'Laptop', price: 999, category: 'electronics', rating: 4.5 },
  { name: 'Book', price: 15, category: 'books', rating: 4.8 },
  { name: 'Phone', price: 699, category: 'electronics', rating: 4.2 },
  { name: 'Pen', price: 2, category: 'office', rating: 3.9 },
  { name: 'Tablet', price: 449, category: 'electronics', rating: 4.7 },
  { name: 'Notebook', price: 5, category: 'office', rating: 4.1 },
  { name: 'Novel', price: 12, category: 'books', rating: 4.9 },
  { name: 'Monitor', price: 350, category: 'electronics', rating: 4.6 }
];

// "Top rated electronics under $500, formatted for display"
const result = products
  .filter(p => p.category === 'electronics')
  .filter(p => p.price <= 500)
  .sort((a, b) => b.rating - a.rating)
  .map(p => `‚≠ê${p.rating} ${p.name} ‚Äî $${p.price}`)

console.log(result);

// Category summary with totals
const summary = products.reduce((acc, p) => {
  if (!acc[p.category]) acc[p.category] = { count: 0, total: 0 };
  acc[p.category].count++;
  acc[p.category].total += p.price;
  return acc;
}, {});
console.log('\nCategory summary:', JSON.stringify(summary, null, 2));</textarea>
    <div id="pg7-out" class="output"></div>
  </div>

  <h3>Complex Transformation: Student Report</h3>
  <div class="playground">
    <div class="pg-head"><span>üíª Student Grade Pipeline</span><button class="run-btn" onclick="runPG('pg8')">Run ‚ñ∂</button></div>
    <textarea id="pg8">const students = [
  { name: 'Alice', scores: [90, 85, 92, 88] },
  { name: 'Bob', scores: [75, 60, 70, 65] },
  { name: 'Charlie', scores: [95, 98, 92, 96] },
  { name: 'Diana', scores: [80, 85, 78, 82] }
];

const report = students
  .map(s => ({
    ...s,
    avg: s.scores.reduce((a, c) => a + c, 0) / s.scores.length
  }))
  .map(s => ({
    ...s,
    grade: s.avg >= 90 ? 'A' : s.avg >= 80 ? 'B' : s.avg >= 70 ? 'C' : 'F'
  }))
  .sort((a, b) => b.avg - a.avg)
  .map(s => `${s.grade} | ${s.name}: ${s.avg.toFixed(1)}%`);

report.forEach(r => console.log(r));

// Class average
const classAvg = students
  .flatMap(s => s.scores)  // all scores in one array
  .reduce((a, c, _, arr) => a + c / arr.length, 0);
console.log(`\nClass average: ${classAvg.toFixed(1)}%`);</textarea>
    <div id="pg8-out" class="output"></div>
  </div>

  <div class="tip-box">
    <h4>üìù Chaining Readability Tips</h4>
    <ul>
      <li>Put each method on its own line, indented</li>
      <li>Add comments for complex transformations</li>
      <li>If the chain is > 5 methods, consider breaking into named steps</li>
      <li>End chains with <code>reduce</code> when you need a non-array result</li>
    </ul>
  </div>
</section>

<!-- ============ PERFORMANCE ============ -->
<section id="sec-perf" class="section">
  <h1>üèéÔ∏è Performance Considerations</h1>
  <p class="subtitle">Know when performance matters and when it doesn't.</p>

  <h2>Single Pass vs. Multi Pass</h2>
  <p>Chaining <code>filter().map()</code> iterates the array <strong>twice</strong>. A single <code>reduce()</code> does it in <strong>one pass</strong>. Does it matter?</p>

  <div class="code-block"><span class="cm">// TWO passes (filter + map)</span>
<span class="kw">const</span> result1 = nums
  .<span class="mt">filter</span>(x => x > <span class="nu">5</span>)     <span class="cm">// pass 1: filter</span>
  .<span class="mt">map</span>(x => x * <span class="nu">2</span>);       <span class="cm">// pass 2: map</span>

<span class="cm">// ONE pass (reduce)</span>
<span class="kw">const</span> result2 = nums.<span class="mt">reduce</span>((acc, x) => {
  <span class="kw">if</span> (x > <span class="nu">5</span>) acc.<span class="mt">push</span>(x * <span class="nu">2</span>);
  <span class="kw">return</span> acc;
}, []);</div>

  <h3>üìä When Does It Actually Matter?</h3>
  <div class="perf-bar-chart">
    <div class="perf-row"><span class="perf-label">100 items</span><div class="perf-bar" style="width:40%;background:var(--green)">~0.01ms</div></div>
    <div class="perf-row"><span class="perf-label">10,000 items</span><div class="perf-bar" style="width:55%;background:var(--green)">~0.5ms</div></div>
    <div class="perf-row"><span class="perf-label">100,000 items</span><div class="perf-bar" style="width:70%;background:var(--yellow)">~5ms</div></div>
    <div class="perf-row"><span class="perf-label">1,000,000 items</span><div class="perf-bar" style="width:90%;background:var(--orange)">~50ms</div></div>
    <div class="perf-row"><span class="perf-label">10,000,000 items</span><div class="perf-bar" style="width:100%;background:var(--red)">~500ms+</div></div>
  </div>
  <p style="color:var(--dim);font-size:.9em">Approximate difference between chained vs single-pass for filter+map.</p>

  <h3>Live Benchmark</h3>
  <div class="playground">
    <div class="pg-head"><span>üíª Run Benchmark</span><button class="run-btn" onclick="runPG('pg9')">Run ‚ñ∂</button></div>
    <textarea id="pg9">const SIZE = 100000;
const data = Array.from({ length: SIZE }, (_, i) => i);

// Method 1: Chained filter + map
console.time('filter().map()');
const r1 = data.filter(x => x % 2 === 0).map(x => x * 3);
console.timeEnd('filter().map()');

// Method 2: Single reduce
console.time('reduce()');
const r2 = data.reduce((acc, x) => {
  if (x % 2 === 0) acc.push(x * 3);
  return acc;
}, []);
console.timeEnd('reduce()');

// Method 3: flatMap
console.time('flatMap()');
const r3 = data.flatMap(x => x % 2 === 0 ? [x * 3] : []);
console.timeEnd('flatMap()');

// Method 4: for loop
console.time('for loop');
const r4 = [];
for (let i = 0; i < data.length; i++) {
  if (data[i] % 2 === 0) r4.push(data[i] * 3);
}
console.timeEnd('for loop');

console.log(`\nAll produce ${r1.length} items ‚úì`);</textarea>
    <div id="pg9-out" class="output"></div>
  </div>

  <h2>The Golden Rule</h2>
  <div class="info-box">
    <h4>üéØ Readability First, Optimize Later</h4>
    <p>For arrays under <strong>10,000 items</strong> (which is 99% of front-end work), the difference is negligible. <strong>Choose the most readable approach.</strong></p>
    <p style="margin-bottom:0">Only optimize to single-pass when:</p>
    <ul style="margin-top:4px">
      <li>Processing very large datasets (100k+)</li>
      <li>Running in tight loops / animations</li>
      <li>You've profiled and confirmed it's a bottleneck</li>
    </ul>
  </div>

  <h2>Avoid These Performance Traps</h2>
  <div class="pitfall">
    <h4>‚ö†Ô∏è Creating new arrays in reduce with spread</h4>
    <div class="code-block"><span class="cm">// ‚ùå SLOW ‚Äî O(n¬≤) because spread copies entire array each time</span>
arr.<span class="mt">reduce</span>((acc, x) => [...acc, x * <span class="nu">2</span>], []);

<span class="cm">// ‚úÖ FAST ‚Äî O(n) with push</span>
arr.<span class="mt">reduce</span>((acc, x) => { acc.<span class="mt">push</span>(x * <span class="nu">2</span>); <span class="kw">return</span> acc; }, []);</div>
    <p>Using <code>[...acc, item]</code> in reduce creates a brand new array on each iteration. For 10,000 items, that's 10,000 array copies of increasing size! Use <code>push</code> instead.</p>
  </div>

  <div class="pitfall">
    <h4>‚ö†Ô∏è Using reduce for everything</h4>
    <div class="code-block"><span class="cm">// ‚ùå Over-engineered ‚Äî reduce for a simple sum</span>
<span class="kw">const</span> hasAdmin = users.<span class="mt">reduce</span>((found, u) =>
  found || u.role === <span class="st">'admin'</span>, <span class="kw">false</span>);

<span class="cm">// ‚úÖ Simple ‚Äî use the right tool</span>
<span class="kw">const</span> hasAdmin = users.<span class="mt">some</span>(u => u.role === <span class="st">'admin'</span>);
<span class="cm">// some() short-circuits on first match = faster!</span></div>
  </div>
</section>

<!-- ============ PITFALLS ============ -->
<section id="sec-pitfalls" class="section">
  <h1>‚ö†Ô∏è Pitfalls & Common Mistakes</h1>
  <p class="subtitle">Avoid these traps that trip up even experienced developers.</p>

  <div class="pitfall">
    <h4>‚ö†Ô∏è Mistake #1: Forgetting to Return the Accumulator</h4>
    <div class="code-block"><span class="cm">// ‚ùå BUG ‚Äî no return statement!</span>
[<span class="nu">1</span>,<span class="nu">2</span>,<span class="nu">3</span>].<span class="mt">reduce</span>((acc, n) => {
  acc.<span class="mt">push</span>(n * <span class="nu">2</span>);
  <span class="cm">// forgot return acc!</span>
}, []);
<span class="cm">// Result: TypeError ‚Äî acc is undefined on 2nd iteration</span>

<span class="cm">// ‚úÖ FIX</span>
[<span class="nu">1</span>,<span class="nu">2</span>,<span class="nu">3</span>].<span class="mt">reduce</span>((acc, n) => {
  acc.<span class="mt">push</span>(n * <span class="nu">2</span>);
  <span class="kw">return</span> acc;  <span class="cm">// ‚Üê Don't forget this!</span>
}, []);</div>
  </div>

  <div class="pitfall">
    <h4>‚ö†Ô∏è Mistake #2: Mutating Objects Inside Reduce</h4>
    <div class="code-block"><span class="kw">const</span> original = [{ val: <span class="nu">1</span> }, { val: <span class="nu">2</span> }, { val: <span class="nu">3</span> }];

<span class="cm">// ‚ùå BUG ‚Äî mutates original objects!</span>
<span class="kw">const</span> doubled = original.<span class="mt">reduce</span>((acc, obj) => {
  obj.val *= <span class="nu">2</span>;  <span class="cm">// modifying the original object!</span>
  acc.<span class="mt">push</span>(obj);
  <span class="kw">return</span> acc;
}, []);

<span class="cm">// ‚úÖ FIX ‚Äî create new objects</span>
<span class="kw">const</span> doubled = original.<span class="mt">reduce</span>((acc, obj) => {
  acc.<span class="mt">push</span>({ ...obj, val: obj.val * <span class="nu">2</span> });
  <span class="kw">return</span> acc;
}, []);</div>
  </div>

  <div class="pitfall">
    <h4>‚ö†Ô∏è Mistake #3: Wrong Initial Value Type</h4>
    <div class="code-block"><span class="cm">// ‚ùå Expected number but got string concatenation</span>
[<span class="nu">1</span>, <span class="nu">2</span>, <span class="nu">3</span>].<span class="mt">reduce</span>((acc, n) => acc + n, <span class="st">''</span>);
<span class="cm">// "123" ‚Üê string, not 6!</span>

<span class="cm">// ‚ùå Expected object but no initial value</span>
[<span class="st">'a'</span>, <span class="st">'b'</span>].<span class="mt">reduce</span>((acc, c) => { acc[c] = <span class="kw">true</span>; <span class="kw">return</span> acc; });
<span class="cm">// TypeError or wrong result ‚Äî 'a' is the initial acc (a string!)</span>

<span class="cm">// ‚úÖ Always match initial value to expected result type</span>
[<span class="st">'a'</span>, <span class="st">'b'</span>].<span class="mt">reduce</span>((acc, c) => { acc[c] = <span class="kw">true</span>; <span class="kw">return</span> acc; }, {});
<span class="cm">// { a: true, b: true } ‚úì</span></div>
  </div>

  <div class="pitfall">
    <h4>‚ö†Ô∏è Mistake #4: Using Reduce When Simpler Methods Exist</h4>
    <div class="code-block"><span class="cm">// ‚ùå Over-complicated</span>
<span class="kw">const</span> allPositive = nums.<span class="mt">reduce</span>((a, n) => a && n > <span class="nu">0</span>, <span class="kw">true</span>);
<span class="cm">// ‚úÖ Use every()</span>
<span class="kw">const</span> allPositive = nums.<span class="mt">every</span>(n => n > <span class="nu">0</span>);

<span class="cm">// ‚ùå Over-complicated</span>
<span class="kw">const</span> first = arr.<span class="mt">reduce</span>((f, x) => f ?? (pred(x) ? x : <span class="kw">null</span>), <span class="kw">null</span>);
<span class="cm">// ‚úÖ Use find()</span>
<span class="kw">const</span> first = arr.<span class="mt">find</span>(pred);

<span class="cm">// ‚ùå Over-complicated</span>
<span class="kw">const</span> joined = arr.<span class="mt">reduce</span>((s, x) => s + <span class="st">','</span> + x);
<span class="cm">// ‚úÖ Use join()</span>
<span class="kw">const</span> joined = arr.<span class="mt">join</span>(<span class="st">','</span>);</div>
  </div>

  <div class="pitfall">
    <h4>‚ö†Ô∏è Mistake #5: flat(Infinity) on User Input</h4>
    <div class="code-block"><span class="cm">// ‚ùå DANGER ‚Äî if data has circular references or is extremely deep</span>
userInput.<span class="mt">flat</span>(<span class="bi">Infinity</span>);

<span class="cm">// ‚úÖ Use a specific depth you expect</span>
userInput.<span class="mt">flat</span>(<span class="nu">2</span>);  <span class="cm">// flatten only as deep as your data model requires</span></div>
  </div>

  <h3>‚ñ∂ Mistake Spotter Challenge</h3>
  <div class="playground">
    <div class="pg-head"><span>üíª Find and Fix the Bugs!</span><button class="run-btn" onclick="runPG('pg10')">Run ‚ñ∂</button></div>
    <textarea id="pg10">// This code has 3 bugs! Fix them all.

const orders = [
  { product: 'Shirt', price: 25, qty: 2 },
  { product: 'Pants', price: 40, qty: 1 },
  { product: 'Shoes', price: 60, qty: 1 }
];

// Bug 1: Should calculate total cost (price * qty for each)
const total = orders.reduce((sum, order) => {
  sum + order.price * order.qty;  // Hint: what's missing?
}, 0);
console.log('Total:', total);

// Bug 2: Should create { Shirt: 25, Pants: 40, Shoes: 60 }
const priceMap = orders.reduce((acc, o) => {
  acc[o.product] = o.price;
}, {});
console.log('Price map:', priceMap);

// Bug 3: Should get all products as a flat array from nested
const departments = [['Shirt', 'Hat'], ['Pants'], ['Shoes', 'Socks']];
const allProducts = departments.flatMap();
console.log('All products:', allProducts);</textarea>
    <div id="pg10-out" class="output"></div>
  </div>
</section>

<!-- ============ EXERCISES ============ -->
<section id="sec-exercises" class="section">
  <h1>üí™ Practice Exercises</h1>
  <p class="subtitle">Solidify your skills with hands-on challenges.</p>

  <div class="exercise">
    <h3>Exercise 1: Frequency Counter <span class="diff easy">Easy</span></h3>
    <p>Write a function that counts how many times each character appears in a string. Use <code>reduce</code>.</p>
    <div class="playground">
      <div class="pg-head"><span>Your Solution</span><button class="check-btn" onclick="checkEx(1)">Check ‚úì</button></div>
      <textarea id="ex1">function charCount(str) {
  // Your code here ‚Äî use reduce on str.split('')
  // Should return an object like { h: 1, e: 1, l: 3, o: 2, ... }

}

// Test
console.log(charCount('hello world'));</textarea>
      <div id="ex1-out" class="output"></div>
      <div id="ex1-result" class="ex-result"></div>
    </div>
  </div>

  <div class="exercise">
    <h3>Exercise 2: Group & Count <span class="diff med">Medium</span></h3>
    <p>Given an array of transactions, group by <code>type</code> and calculate total amount per type.</p>
    <div class="playground">
      <div class="pg-head"><span>Your Solution</span><button class="check-btn" onclick="checkEx(2)">Check ‚úì</button></div>
      <textarea id="ex2">const transactions = [
  { type: 'sale', amount: 100 },
  { type: 'refund', amount: 25 },
  { type: 'sale', amount: 200 },
  { type: 'sale', amount: 50 },
  { type: 'refund', amount: 10 }
];

function totalByType(txns) {
  // Return { sale: 350, refund: 35 }
  // Use reduce!

}

console.log(totalByType(transactions));</textarea>
      <div id="ex2-out" class="output"></div>
      <div id="ex2-result" class="ex-result"></div>
    </div>
  </div>

  <div class="exercise">
    <h3>Exercise 3: FlatMap Magic <span class="diff med">Medium</span></h3>
    <p>Extract all tags from blog posts and return unique tags sorted alphabetically. Use <code>flatMap</code>.</p>
    <div class="playground">
      <div class="pg-head"><span>Your Solution</span><button class="check-btn" onclick="checkEx(3)">Check ‚úì</button></div>
      <textarea id="ex3">const posts = [
  { title: 'JS Tips', tags: ['javascript', 'webdev'] },
  { title: 'CSS Guide', tags: ['css', 'webdev', 'design'] },
  { title: 'React 101', tags: ['javascript', 'react'] }
];

function uniqueSortedTags(posts) {
  // Should return: ['css', 'design', 'javascript', 'react', 'webdev']
  // Use flatMap + Set + sort

}

console.log(uniqueSortedTags(posts));</textarea>
      <div id="ex3-out" class="output"></div>
      <div id="ex3-result" class="ex-result"></div>
    </div>
  </div>

  <div class="exercise">
    <h3>Exercise 4: Data Pipeline <span class="diff hard">Hard</span></h3>
    <p>Process sales data: filter completed orders, calculate revenue per product, return top 3 by revenue.</p>
    <div class="playground">
      <div class="pg-head"><span>Your Solution</span><button class="check-btn" onclick="checkEx(4)">Check ‚úì</button></div>
      <textarea id="ex4">const orders = [
  { product: 'Widget', qty: 10, price: 5, status: 'completed' },
  { product: 'Gadget', qty: 3, price: 50, status: 'completed' },
  { product: 'Widget', qty: 5, price: 5, status: 'cancelled' },
  { product: 'Doohickey', qty: 20, price: 2, status: 'completed' },
  { product: 'Gadget', qty: 2, price: 50, status: 'completed' },
  { product: 'Thingamajig', qty: 1, price: 500, status: 'completed' },
  { product: 'Widget', qty: 8, price: 5, status: 'completed' }
];

function topProducts(orders) {
  // Steps:
  // 1. Filter only 'completed' orders
  // 2. Reduce to calculate total revenue per product (qty * price)
  // 3. Convert to array, sort by revenue desc, take top 3
  // Return: [{ product: 'Thingamajig', revenue: 500 }, ...]

}

console.log(topProducts(orders));</textarea>
      <div id="ex4-out" class="output"></div>
      <div id="ex4-result" class="ex-result"></div>
    </div>
  </div>

  <div class="exercise">
    <h3>Exercise 5: Compose Functions <span class="diff hard">Hard</span></h3>
    <p>Implement a <code>pipe</code> function using reduce that chains functions left-to-right.</p>
    <div class="playground">
      <div class="pg-head"><span>Your Solution</span><button class="check-btn" onclick="checkEx(5)">Check ‚úì</button></div>
      <textarea id="ex5">function pipe(...fns) {
  // Return a function that passes its argument through
  // each fn in sequence, left to right
  // Use reduce!

}

// Test it:
const transform = pipe(
  x => x * 2,      // 5 ‚Üí 10
  x => x + 3,      // 10 ‚Üí 13
  x => x.toString(), // 13 ‚Üí "13"
  x => '($' + x + ')' // "13" ‚Üí "($13)"
);

console.log(transform(5)); // Should output: "($13)"</textarea>
      <div id="ex5-out" class="output"></div>
      <div id="ex5-result" class="ex-result"></div>
    </div>
  </div>
</section>

<!-- ============ QUIZ ============ -->
<section id="sec-quiz" class="section">
  <h1>üèÜ Final Boss Quiz</h1>
  <p class="subtitle">Test your mastery! 10 questions. Can you get them all right?</p>
  <p id="quiz-score" style="font-size:1.2em;text-align:center;margin:20px 0;color:var(--yellow)"></p>

  <div class="quiz-card" id="q1">
    <h3>Q1: What does this return?</h3>
    <div class="quiz-code">[1, 2, 3].reduce((a, c) => a + c)</div>
    <div class="quiz-options">
      <button class="quiz-option" onclick="answer(1,this,'a')">A) 0</button>
      <button class="quiz-option" onclick="answer(1,this,'b')">B) 6</button>
      <button class="quiz-option" onclick="answer(1,this,'c')">C) NaN</button>
      <button class="quiz-option" onclick="answer(1,this,'d')">D) TypeError</button>
    </div>
    <div class="quiz-explain" id="q1-exp">‚úÖ <strong>B) 6</strong> ‚Äî Without an initial value, reduce uses the first element (1) as the starting accumulator: 1+2=3, 3+3=6.</div>
  </div>

  <div class="quiz-card" id="q2">
    <h3>Q2: What does this return?</h3>
    <div class="quiz-code">[].reduce((a, c) => a + c)</div>
    <div class="quiz-options">
      <button class="quiz-option" onclick="answer(2,this,'a')">A) 0</button>
      <button class="quiz-option" onclick="answer(2,this,'b')">B) undefined</button>
      <button class="quiz-option" onclick="answer(2,this,'c')">C) NaN</button>
      <button class="quiz-option" onclick="answer(2,this,'d')">D) TypeError</button>
    </div>
    <div class="quiz-explain" id="q2-exp">‚úÖ <strong>D) TypeError</strong> ‚Äî "Reduce of empty array with no initial value." Always provide an initial value to be safe!</div>
  </div>

  <div class="quiz-card" id="q3">
    <h3>Q3: What does this return?</h3>
    <div class="quiz-code">[1, [2, [3]]].flat()</div>
    <div class="quiz-options">
      <button class="quiz-option" onclick="answer(3,this,'a')">A) [1, 2, 3]</button>
      <button class="quiz-option" onclick="answer(3,this,'b')">B) [1, 2, [3]]</button>
      <button class="quiz-option" onclick="answer(3,this,'c')">C) [1, [2, [3]]]</button>
      <button class="quiz-option" onclick="answer(3,this,'d')">D) [1, [2], [3]]</button>
    </div>
    <div class="quiz-explain" id="q3-exp">‚úÖ <strong>B) [1, 2, [3]]</strong> ‚Äî flat() defaults to depth 1, so only the first level of nesting is removed. [3] stays nested.</div>
  </div>

  <div class="quiz-card" id="q4">
    <h3>Q4: What does this return?</h3>
    <div class="quiz-code">["hi there", "bye now"].flatMap(s => s.split(' '))</div>
    <div class="quiz-options">
      <button class="quiz-option" onclick="answer(4,this,'a')">A) [["hi","there"],["bye","now"]]</button>
      <button class="quiz-option" onclick="answer(4,this,'b')">B) ["hi","there","bye","now"]</button>
      <button class="quiz-option" onclick="answer(4,this,'c')">C) "hi there bye now"</button>
      <button class="quiz-option" onclick="answer(4,this,'d')">D) ["hi there", "bye now"]</button>
    </div>
    <div class="quiz-explain" id="q4-exp">‚úÖ <strong>B) ["hi","there","bye","now"]</strong> ‚Äî map produces [["hi","there"],["bye","now"]], then flat(1) unwraps one level.</div>
  </div>

  <div class="quiz-card" id="q5">
    <h3>Q5: What does this return?</h3>
    <div class="quiz-code">[1, 2, 3].reduce((a, c) => a + c, '')</div>
    <div class="quiz-options">
      <button class="quiz-option" onclick="answer(5,this,'a')">A) 6</button>
      <button class="quiz-option" onclick="answer(5,this,'b')">B) "6"</button>
      <button class="quiz-option" onclick="answer(5,this,'c')">C) "123"</button>
      <button class="quiz-option" onclick="answer(5,this,'d')">D) NaN</button>
    </div>
    <div class="quiz-explain" id="q5-exp">‚úÖ <strong>C) "123"</strong> ‚Äî Initial value '' is a string, so + does string concatenation: ''+1='1', '1'+2='12', '12'+3='123'.</div>
  </div>

  <div class="quiz-card" id="q6">
    <h3>Q6: What does flatMap effectively do here?</h3>
    <div class="quiz-code">[1,2,3,4,5].flatMap(x => x % 2 === 0 ? [x] : [])</div>
    <div class="quiz-options">
      <button class="quiz-option" onclick="answer(6,this,'a')">A) Doubles all numbers</button>
      <button class="quiz-option" onclick="answer(6,this,'b')">B) Removes even numbers</button>
      <button class="quiz-option" onclick="answer(6,this,'c')">C) Filters to only even numbers</button>
      <button class="quiz-option" onclick="answer(6,this,'d')">D) Returns empty array</button>
    </div>
    <div class="quiz-explain" id="q6-exp">‚úÖ <strong>C) Filters to only even numbers</strong> ‚Üí [2, 4]. Returning [] removes items, returning [x] keeps them. This is the flatMap-as-filter pattern!</div>
  </div>

  <div class="quiz-card" id="q7">
    <h3>Q7: Which is faster for large arrays?</h3>
    <div class="quiz-code">// A) arr.filter(x => x > 5).map(x => x * 2)
// B) arr.reduce((a,x) => { if(x>5) a.push(x*2); return a; }, [])</div>
    <div class="quiz-options">
      <button class="quiz-option" onclick="answer(7,this,'a')">A) Option A is always faster</button>
      <button class="quiz-option" onclick="answer(7,this,'b')">B) Option B (single pass)</button>
      <button class="quiz-option" onclick="answer(7,this,'c')">C) They're exactly the same</button>
      <button class="quiz-option" onclick="answer(7,this,'d')">D) Depends on the engine</button>
    </div>
    <div class="quiz-explain" id="q7-exp">‚úÖ <strong>B)</strong> The reduce version makes a single pass, while filter+map makes two. For very large arrays (100k+), this matters. For small arrays, the difference is negligible ‚Äî prefer readability!</div>
  </div>

  <div class="quiz-card" id="q8">
    <h3>Q8: What's wrong with this reduce?</h3>
    <div class="quiz-code">const result = [1,2,3].reduce((acc, n) => {
  acc.push(n * 2);
}, []);</div>
    <div class="quiz-options">
      <button class="quiz-option" onclick="answer(8,this,'a')">A) push() doesn't work in reduce</button>
      <button class="quiz-option" onclick="answer(8,this,'b')">B) Missing return statement</button>
      <button class="quiz-option" onclick="answer(8,this,'c')">C) Wrong initial value</button>
      <button class="quiz-option" onclick="answer(8,this,'d')">D) Nothing, it works fine</button>
    </div>
    <div class="quiz-explain" id="q8-exp">‚úÖ <strong>B) Missing return statement</strong> ‚Äî Without returning acc, it becomes undefined on the next iteration, causing "Cannot read property 'push' of undefined".</div>
  </div>

  <div class="quiz-card" id="q9">
    <h3>Q9: What does this produce?</h3>
    <div class="quiz-code">[1, , 3, , 5].flat()</div>
    <div class="quiz-options">
      <button class="quiz-option" onclick="answer(9,this,'a')">A) [1, undefined, 3, undefined, 5]</button>
      <button class="quiz-option" onclick="answer(9,this,'b')">B) [1, 3, 5]</button>
      <button class="quiz-option" onclick="answer(9,this,'c')">C) [1, null, 3, null, 5]</button>
      <button class="quiz-option" onclick="answer(9,this,'d')">D) Error</button>
    </div>
    <div class="quiz-explain" id="q9-exp">‚úÖ <strong>B) [1, 3, 5]</strong> ‚Äî flat() removes empty slots (holes) in arrays. This is a useful trick to clean up sparse arrays!</div>
  </div>

  <div class="quiz-card" id="q10">
    <h3>Q10: Which should you use to check if ALL items pass a test?</h3>
    <div class="quiz-code">// Check if all numbers are positive</div>
    <div class="quiz-options">
      <button class="quiz-option" onclick="answer(10,this,'a')">A) arr.reduce((a,n) => a && n>0, true)</button>
      <button class="quiz-option" onclick="answer(10,this,'b')">B) arr.filter(n => n>0).length === arr.length</button>
      <button class="quiz-option" onclick="answer(10,this,'c')">C) arr.every(n => n > 0)</button>
      <button class="quiz-option" onclick="answer(10,this,'d')">D) !arr.some(n => n <= 0)</button>
    </div>
    <div class="quiz-explain" id="q10-exp">‚úÖ <strong>C) every()</strong> ‚Äî It's the most readable AND it short-circuits (stops on first failure). All options technically work, but every() is the right tool for this job.</div>
  </div>
</section>

</main>

<script>
// ============ APP STATE ============
const state = {
  section: 'home',
  xp: 0,
  completed: new Set(),
  quizAnswers: {},
  quizCorrect: 0,
  quizTotal: 10
};

const ANSWERS = {1:'b',2:'d',3:'b',4:'b',5:'c',6:'c',7:'b',8:'b',9:'b',10:'c'};

// ============ NAVIGATION ============
function go(id) {
  document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
  document.getElementById('sec-' + id).classList.add('active');
  document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
  const items = document.querySelectorAll('.nav-item');
  const map = ['home','reduce1','reduce2','flat','chain','perf','pitfalls','exercises','quiz'];
  const idx = map.indexOf(id);
  if (idx >= 0) items[idx].classList.add('active');
  state.section = id;
  if (id !== 'home') markComplete(id);
  document.getElementById('sidebar').classList.remove('open');
  window.scrollTo(0, 0);
  updateProgress();
}

function markComplete(id) {
  state.completed.add(id);
  const items = document.querySelectorAll('.nav-item');
  const map = ['home','reduce1','reduce2','flat','chain','perf','pitfalls','exercises','quiz'];
  const idx = map.indexOf(id);
  if (idx >= 0) items[idx].classList.add('completed');
}

function updateProgress() {
  const total = 8;
  const done = state.completed.size;
  document.getElementById('progress-fill').style.width = (done/total*100) + '%';
}

function addXP(n) {
  state.xp += n;
  document.getElementById('xp-count').textContent = state.xp;
  const el = document.getElementById('xp-count');
  el.style.transform = 'scale(1.4)';
  setTimeout(() => el.style.transform = 'scale(1)', 300);
}

// ============ CODE PLAYGROUND ============
function runPG(id) {
  const code = document.getElementById(id).value;
  const out = document.getElementById(id + '-out');
  out.textContent = '';
  const logs = [];
  const origLog = console.log;
  const origTime = console.time;
  const origTimeEnd = console.timeEnd;
  const timers = {};

  console.log = (...args) => {
    logs.push(args.map(a => {
      if (a === undefined) return 'undefined';
      if (a === null) return 'null';
      if (typeof a === 'object') {
        try { return JSON.stringify(a, null, 2); } catch(e) { return String(a); }
      }
      return String(a);
    }).join(' '));
  };
  console.time = (label) => { timers[label] = performance.now(); };
  console.timeEnd = (label) => {
    const elapsed = performance.now() - (timers[label] || 0);
    logs.push(label + ': ' + elapsed.toFixed(3) + 'ms');
  };

  try {
    const result = eval(code);
    if (result !== undefined && !code.includes('console.log')) {
      logs.push('‚Üí ' + (typeof result === 'object' ? JSON.stringify(result, null, 2) : String(result)));
    }
    out.textContent = logs.join('\n');
    out.className = 'output success';
  } catch(e) {
    out.textContent = (logs.length ? logs.join('\n') + '\n' : '') + '‚ùå ' + e.name + ': ' + e.message;
    out.className = 'output error';
  }
  console.log = origLog;
  console.time = origTime;
  console.timeEnd = origTimeEnd;
}

// ============ REDUCE VISUALIZER ============
const vizData = [10, 20, 30, 40, 50];
const vizColors = ['#4facfe','#00f2fe','#a855f7','#f59e0b','#10b981'];
let vizStep = -1;
let vizPlaying = false;
let vizTimer = null;

function vizInit() {
  const container = document.getElementById('viz-array');
  container.innerHTML = '';
  vizData.forEach((val, i) => {
    const el = document.createElement('div');
    el.className = 'vis-item';
    el.style.background = vizColors[i];
    el.style.color = '#000';
    el.textContent = val;
    el.id = 'viz-el-' + i;
    container.appendChild(el);
  });
  document.getElementById('viz-acc-val').textContent = '0';
  document.getElementById('viz-step').textContent = 'Click "Next" or "Play" to start';
  vizStep = -1;
}

function vizRender() {
  let acc = 0;
  vizData.forEach((val, i) => {
    const el = document.getElementById('viz-el-' + i);
    el.className = 'vis-item';
    el.style.background = vizColors[i];
    if (i < vizStep) {
      el.classList.add('done');
      acc += val;
    } else if (i === vizStep) {
      el.classList.add('active');
      acc += val;
    }
  });

  document.getElementById('viz-acc-val').textContent = acc;

  if (vizStep < 0) {
    document.getElementById('viz-step').textContent = 'Click "Next" or "Play" to start';
    document.getElementById('viz-acc-val').textContent = '0';
  } else if (vizStep < vizData.length) {
    const prevAcc = vizData.slice(0, vizStep).reduce((a,b)=>a+b, 0);
    document.getElementById('viz-step').innerHTML =
      `Step ${vizStep+1}/${vizData.length}: <strong>${prevAcc} + ${vizData[vizStep]} = ${prevAcc + vizData[vizStep]}</strong>`;
  } else {
    const total = vizData.reduce((a,b)=>a+b,0);
    document.getElementById('viz-step').innerHTML = `‚úÖ Done! Final result: <strong>${total}</strong>`;
  }
}

function vizNext() {
  if (vizStep < vizData.length) { vizStep++; vizRender(); }
}
function vizPrev() {
  if (vizStep > -1) { vizStep--; vizRender(); }
}
function vizReset() {
  vizPlaying = false;
  clearInterval(vizTimer);
  document.getElementById('viz-play-btn').textContent = '‚ñ∂ Play';
  vizStep = -1;
  vizInit();
}
function vizPlay() {
  if (vizPlaying) {
    vizPlaying = false;
    clearInterval(vizTimer);
    document.getElementById('viz-play-btn').textContent = '‚ñ∂ Play';
    return;
  }
  vizPlaying = true;
  document.getElementById('viz-play-btn').textContent = '‚è∏ Pause';
  if (vizStep >= vizData.length) { vizStep = -1; vizInit(); }
  vizTimer = setInterval(() => {
    vizStep++;
    vizRender();
    if (vizStep >= vizData.length) {
      vizPlaying = false;
      clearInterval(vizTimer);
      document.getElementById('viz-play-btn').textContent = '‚ñ∂ Play';
      addXP(5);
    }
  }, 900);
}

// ============ FLAT DEMO ============
function flatDemo(depth) {
  const el = document.getElementById('flat-result');
  const original = [1, [2, 3], [4, [5, [6]]]];
  let result;
  let label;
  if (depth === 0) {
    result = JSON.stringify(original);
    label = 'Original (no flattening)';
  } else if (depth === 3) {
    result = JSON.stringify(original.flat(Infinity));
    label = '.flat(Infinity) ‚Äî completely flat!';
  } else {
    result = JSON.stringify(original.flat(depth));
    label = `.flat(${depth})`;
  }
  el.innerHTML = `<div style="color:var(--dim);font-size:.8em;margin-bottom:6px">${label}</div>
    <div style="font-size:1.2em;color:var(--accent2)">${result}</div>`;
}

// ============ QUIZ SYSTEM ============
function answer(qNum, btn, choice) {
  if (state.quizAnswers[qNum]) return;
  state.quizAnswers[qNum] = choice;

  const correct = ANSWERS[qNum];
  const isCorrect = choice === correct;
  const options = btn.parentElement.querySelectorAll('.quiz-option');

  options.forEach(o => {
    o.classList.add('chosen');
    const optChoice = o.textContent[0].toLowerCase();
    if (o === btn && !isCorrect) o.classList.add('wrong');
  });

  // Highlight correct answer
  const correctIdx = correct.charCodeAt(0) - 97;
  options[correctIdx].classList.add('correct');

  const exp = document.getElementById('q' + qNum + '-exp');
  exp.classList.add('show');
  if (isCorrect) {
    exp.classList.add('ok');
    state.quizCorrect++;
    addXP(10);
  } else {
    exp.classList.add('no');
    exp.innerHTML = '‚ùå Wrong! ' + exp.innerHTML.replace('‚úÖ','The correct answer is:');
  }

  // Update score
  const answered = Object.keys(state.quizAnswers).length;
  document.getElementById('quiz-score').textContent =
    `Score: ${state.quizCorrect}/${answered} answered (${state.quizTotal} total)`;

  if (answered === state.quizTotal) {
    markComplete('quiz');
    const pct = Math.round(state.quizCorrect / state.quizTotal * 100);
    document.getElementById('quiz-score').innerHTML +=
      `<br><br>${pct >= 80 ? 'üéâ Excellent! You\'re ready for interviews!' :
        pct >= 60 ? 'üëç Good job! Review the sections you missed.' :
        'üìö Keep studying! Review the earlier sections and try again.'}`;
    if (pct >= 80) addXP(50);
  }
}

// ============ EXERCISE SYSTEM ============
function checkEx(num) {
  const code = document.getElementById('ex' + num).value;
  const outEl = document.getElementById('ex' + num + '-out');
  const resEl = document.getElementById('ex' + num + '-result');

  // First run the code to show output
  const logs = [];
  const origLog = console.log;
  console.log = (...args) => {
    logs.push(args.map(a => {
      if (typeof a === 'object' && a !== null) {
        try { return JSON.stringify(a); } catch(e) { return String(a); }
      }
      return String(a);
    }).join(' '));
  };

  try {
    eval(code);
    outEl.textContent = logs.join('\n');
    outEl.className = 'output success';
  } catch(e) {
    outEl.textContent = '‚ùå ' + e.message;
    outEl.className = 'output error';
    resEl.textContent = '‚ùå Code has errors. Fix them first!';
    resEl.className = 'ex-result fail';
    console.log = origLog;
    return;
  }
  console.log = origLog;

  // Now validate
  let passed = false;
  let feedback = '';

  try {
    switch(num) {
      case 1: {
        eval(code);
        const fn = eval('charCount');
        const r = fn('hello world');
        if (r && r.h === 1 && r.e === 1 && r.l === 3 && r.o === 2 && r.w === 1 && r.r === 1 && r.d === 1) {
          passed = true;
          feedback = '‚úÖ Perfect! Character counting with reduce ‚Äî nailed it!';
        } else {
          feedback = '‚ùå Not quite. Expected { h:1, e:1, l:3, o:2, " ":1, w:1, r:1, d:1 }. Got: ' + JSON.stringify(r);
        }
        break;
      }
      case 2: {
        eval(code);
        const fn = eval('totalByType');
        const t = [
          { type: 'sale', amount: 100 },
          { type: 'refund', amount: 25 },
          { type: 'sale', amount: 200 },
          { type: 'sale', amount: 50 },
          { type: 'refund', amount: 10 }
        ];
        const r = fn(t);
        if (r && r.sale === 350 && r.refund === 35) {
          passed = true;
          feedback = '‚úÖ Excellent! GroupBy + sum in one reduce!';
        } else {
          feedback = '‚ùå Expected { sale: 350, refund: 35 }. Got: ' + JSON.stringify(r);
        }
        break;
      }
      case 3: {
        eval(code);
        const fn = eval('uniqueSortedTags');
        const p = [
          { title: 'JS Tips', tags: ['javascript', 'webdev'] },
          { title: 'CSS Guide', tags: ['css', 'webdev', 'design'] },
          { title: 'React 101', tags: ['javascript', 'react'] }
        ];
        const r = fn(p);
        const expected = ['css','design','javascript','react','webdev'];
        if (r && JSON.stringify(r) === JSON.stringify(expected)) {
          passed = true;
          feedback = '‚úÖ Great use of flatMap + Set + sort!';
        } else {
          feedback = '‚ùå Expected ' + JSON.stringify(expected) + '\nGot: ' + JSON.stringify(r);
        }
        break;
      }
      case 4: {
        eval(code);
        const fn = eval('topProducts');
        const o = [
          { product: 'Widget', qty: 10, price: 5, status: 'completed' },
          { product: 'Gadget', qty: 3, price: 50, status: 'completed' },
          { product: 'Widget', qty: 5, price: 5, status: 'cancelled' },
          { product: 'Doohickey', qty: 20, price: 2, status: 'completed' },
          { product: 'Gadget', qty: 2, price: 50, status: 'completed' },
          { product: 'Thingamajig', qty: 1, price: 500, status: 'completed' },
          { product: 'Widget', qty: 8, price: 5, status: 'completed' }
        ];
        const r = fn(o);
        if (r && r.length === 3 && r[0].product === 'Thingamajig' && r[0].revenue === 500
            && r[1].product === 'Gadget' && r[1].revenue === 250) {
          passed = true;
          feedback = '‚úÖ Masterful pipeline! Filter ‚Üí Reduce ‚Üí Sort ‚Üí Slice!';
        } else {
          feedback = '‚ùå Expected top 3: Thingamajig($500), Gadget($250), Widget($90)\nGot: ' + JSON.stringify(r);
        }
        break;
      }
      case 5: {
        eval(code);
        const fn = eval('pipe');
        const t = fn(x=>x*2, x=>x+3, x=>x.toString(), x=>'($'+x+')');
        const r = t(5);
        if (r === '($13)') {
          passed = true;
          feedback = '‚úÖ You\'ve mastered function composition with reduce!';
        } else {
          feedback = '‚ùå Expected "($13)" for input 5. Got: ' + JSON.stringify(r);
        }
        break;
      }
    }
  } catch(e) {
    feedback = '‚ùå Error during validation: ' + e.message;
  }

  resEl.textContent = feedback;
  resEl.className = 'ex-result ' + (passed ? 'pass' : 'fail');
  if (passed) {
    addXP(20);
    markComplete('exercises');
  }
}

// ============ INIT ============
document.addEventListener('DOMContentLoaded', () => {
  vizInit();

  // Add keyboard shortcut for playgrounds
  document.querySelectorAll('.playground textarea').forEach(ta => {
    ta.addEventListener('keydown', e => {
      if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
        e.preventDefault();
        const btn = ta.closest('.playground').querySelector('.run-btn, .check-btn');
        if (btn) btn.click();
      }
      // Tab support
      if (e.key === 'Tab') {
        e.preventDefault();
        const start = ta.selectionStart;
        const end = ta.selectionEnd;
        ta.value = ta.value.substring(0, start) + '  ' + ta.value.substring(end);
        ta.selectionStart = ta.selectionEnd = start + 2;
      }
    });
  });
});
</script>
</body>
</html>