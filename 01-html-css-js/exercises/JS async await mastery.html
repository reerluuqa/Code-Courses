<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>‚ö° Async/Await Mastery ‚Äî Interactive JavaScript Course</title>
<style>
:root {
  --bg: #0d1117; --surface: #161b22; --surface2: #1c2333;
  --border: #30363d; --text: #c9d1d9; --text-dim: #8b949e;
  --blue: #58a6ff; --green: #3fb950; --red: #f85149;
  --yellow: #d29922; --purple: #bc8cff; --orange: #f0883e;
  --cyan: #39d2c0; --pink: #f778ba;
  --radius: 10px; --sidebar-w: 260px;
  --font-mono: 'Consolas','Monaco','Courier New', monospace;
}
* { margin:0; padding:0; box-sizing:border-box; }
html { scroll-behavior: smooth; }
body { font-family: system-ui,-apple-system,sans-serif; background:var(--bg); color:var(--text); line-height:1.7; display:flex; min-height:100vh; }

/* Sidebar */
#sidebar { position:fixed; left:0; top:0; bottom:0; width:var(--sidebar-w); background:var(--surface); border-right:1px solid var(--border); display:flex; flex-direction:column; z-index:100; overflow-y:auto; }
.logo { padding:20px; display:flex; align-items:center; gap:12px; border-bottom:1px solid var(--border); }
.logo-icon { font-size:2rem; }
.logo-text { font-size:.95rem; font-weight:700; color:var(--blue); }
.logo-text small { font-weight:400; color:var(--text-dim); font-size:.7rem; }
.nav-links { list-style:none; padding:12px 0; flex:1; }
.nav-links li a { display:flex; align-items:center; gap:10px; padding:10px 20px; color:var(--text-dim); text-decoration:none; font-size:.85rem; transition:.2s; border-left:3px solid transparent; }
.nav-links li a:hover { background:var(--surface2); color:var(--text); }
.nav-links li a.active { color:var(--blue); border-left-color:var(--blue); background:rgba(88,166,255,.08); }
.nav-links li a .checkmark { margin-left:auto; color:var(--green); opacity:0; font-size:.8rem; }
.nav-links li a.completed .checkmark { opacity:1; }
.progress-box { padding:16px 20px; border-top:1px solid var(--border); }
.progress-label { font-size:.75rem; color:var(--text-dim); margin-bottom:6px; }
.progress-bar { height:6px; background:var(--surface2); border-radius:3px; overflow:hidden; }
.progress-fill { height:100%; width:0%; background:linear-gradient(90deg,var(--blue),var(--purple)); border-radius:3px; transition:width .5s; }
.progress-text { font-size:.75rem; color:var(--blue); margin-top:4px; text-align:right; }

/* Hamburger for mobile */
#hamburger { display:none; position:fixed; top:12px; left:12px; z-index:200; background:var(--surface); border:1px solid var(--border); color:var(--text); font-size:1.4rem; padding:6px 10px; border-radius:6px; cursor:pointer; }

/* Main */
#main { margin-left:var(--sidebar-w); flex:1; }
.section { padding:40px 50px 60px; max-width:900px; margin:0 auto; display:none; }
.section.active { display:block; }
.section h1 { font-size:2rem; margin-bottom:8px; background:linear-gradient(135deg,var(--blue),var(--purple)); -webkit-background-clip:text; -webkit-text-fill-color:transparent; background-clip:text; }
.section h2 { font-size:1.4rem; color:var(--blue); margin:30px 0 12px; padding-bottom:8px; border-bottom:1px solid var(--border); }
.section h3 { font-size:1.1rem; color:var(--purple); margin:20px 0 8px; }
.section p { color:var(--text-dim); margin-bottom:14px; }
.section p strong { color:var(--text); }
.section ul, .section ol { color:var(--text-dim); margin:0 0 16px 20px; }
.section li { margin-bottom:6px; }

/* Cards */
.card { background:var(--surface); border:1px solid var(--border); border-radius:var(--radius); padding:20px; margin:16px 0; }
.card.highlight { border-color:var(--blue); }
.card.warning { border-color:var(--yellow); background:rgba(210,153,34,.06); }
.card.danger { border-color:var(--red); background:rgba(248,81,73,.06); }
.card.success { border-color:var(--green); background:rgba(63,185,80,.06); }
.card-title { font-weight:700; margin-bottom:8px; display:flex; align-items:center; gap:8px; }

/* Evolution cards */
.evolution { display:grid; grid-template-columns:1fr 1fr 1fr; gap:12px; margin:16px 0; }
.evo-card { background:var(--surface); border:1px solid var(--border); border-radius:var(--radius); padding:16px; text-align:center; }
.evo-card.best { border-color:var(--green); box-shadow:0 0 20px rgba(63,185,80,.15); }
.evo-card h4 { margin-bottom:8px; }
.evo-card .emoji { font-size:2rem; margin-bottom:8px; }

/* Code blocks */
.code-block { background:var(--surface2); border:1px solid var(--border); border-radius:var(--radius); overflow:hidden; margin:12px 0; }
.code-header { display:flex; justify-content:space-between; align-items:center; padding:8px 14px; background:var(--surface); border-bottom:1px solid var(--border); }
.code-title { font-size:.8rem; color:var(--text-dim); font-family:var(--font-mono); }
.run-btn { background:var(--green); color:#000; border:none; padding:4px 14px; border-radius:4px; font-size:.78rem; cursor:pointer; font-weight:600; transition:.2s; }
.run-btn:hover { opacity:.85; transform:scale(1.05); }
.code-body { padding:14px; overflow-x:auto; }
.code-body pre { font-family:var(--font-mono); font-size:.85rem; line-height:1.6; white-space:pre; color:var(--text); }
.console-output { border-top:1px solid var(--border); padding:10px 14px; background:rgba(0,0,0,.3); min-height:30px; max-height:200px; overflow-y:auto; font-family:var(--font-mono); font-size:.8rem; }
.console-output:empty::before { content:'‚ñ∂ Click "Run" to see output'; color:var(--text-dim); font-style:italic; }
.console-output .log-line { padding:2px 0; color:var(--green); }
.console-output .log-line::before { content:'‚Ä∫ '; color:var(--text-dim); }
.console-output .error-line { color:var(--red); }
.console-output .error-line::before { content:'‚úñ '; }
.console-output .info-line { color:var(--cyan); font-style:italic; }

/* Syntax highlighting */
.kw { color:var(--purple); } /* keywords */
.fn { color:var(--blue); } /* function names */
.str { color:var(--green); } /* strings */
.num { color:var(--orange); } /* numbers */
.cm { color:var(--text-dim); font-style:italic; } /* comments */
.op { color:var(--cyan); } /* operators */
.bi { color:var(--yellow); } /* built-in */

/* Tabs */
.tabs { display:flex; gap:4px; margin:16px 0 0; border-bottom:1px solid var(--border); }
.tab-btn { padding:8px 18px; background:none; border:none; color:var(--text-dim); cursor:pointer; font-size:.85rem; border-bottom:2px solid transparent; transition:.2s; }
.tab-btn:hover { color:var(--text); }
.tab-btn.active { color:var(--blue); border-bottom-color:var(--blue); }
.tab-content { display:none; }
.tab-content.active { display:block; }

/* Pitfall comparison */
.pitfall { display:grid; grid-template-columns:1fr 1fr; gap:12px; margin:16px 0; }
.pitfall-bad, .pitfall-good { border-radius:var(--radius); overflow:hidden; border:1px solid var(--border); }
.pitfall-bad { border-color:var(--red); }
.pitfall-good { border-color:var(--green); }
.pitfall-label { padding:6px 14px; font-size:.8rem; font-weight:700; }
.pitfall-bad .pitfall-label { background:rgba(248,81,73,.15); color:var(--red); }
.pitfall-good .pitfall-label { background:rgba(63,185,80,.15); color:var(--green); }
.pitfall-bad pre, .pitfall-good pre { padding:12px 14px; font-family:var(--font-mono); font-size:.82rem; line-height:1.6; background:var(--surface2); }

/* Visual execution flow */
.exec-viz { background:var(--surface); border:1px solid var(--border); border-radius:var(--radius); padding:20px; margin:16px 0; }
.exec-timeline { display:flex; flex-direction:column; gap:8px; margin:12px 0; }
.exec-step { display:flex; align-items:center; gap:12px; padding:8px 12px; border-radius:6px; transition:.3s; opacity:.4; }
.exec-step.active { opacity:1; background:rgba(88,166,255,.1); }
.exec-step.done { opacity:.7; }
.exec-step .step-num { width:28px; height:28px; border-radius:50%; display:flex; align-items:center; justify-content:center; font-size:.75rem; font-weight:700; background:var(--surface2); border:2px solid var(--border); flex-shrink:0; }
.exec-step.active .step-num { border-color:var(--blue); color:var(--blue); }
.exec-step.done .step-num { border-color:var(--green); color:var(--green); background:rgba(63,185,80,.1); }
.exec-step .step-code { font-family:var(--font-mono); font-size:.82rem; flex:1; }
.exec-step .step-note { font-size:.75rem; color:var(--yellow); max-width:200px; }
.exec-controls { display:flex; gap:8px; margin-top:12px; }
.exec-controls button { padding:6px 16px; border:1px solid var(--border); background:var(--surface2); color:var(--text); border-radius:6px; cursor:pointer; font-size:.82rem; transition:.2s; }
.exec-controls button:hover { border-color:var(--blue); color:var(--blue); }
.exec-controls button.primary { background:var(--blue); color:#000; border-color:var(--blue); font-weight:600; }

/* Parallel vs Sequential viz */
.race-viz { background:var(--surface); border:1px solid var(--border); border-radius:var(--radius); padding:20px; margin:16px 0; }
.race-row { margin:12px 0; }
.race-row label { font-size:.82rem; color:var(--text-dim); margin-bottom:4px; display:block; }
.race-bar-track { height:28px; background:var(--surface2); border-radius:4px; overflow:hidden; position:relative; }
.race-bar { height:100%; border-radius:4px; display:flex; align-items:center; padding-left:10px; font-size:.75rem; font-weight:600; color:#000; width:0%; transition:width linear; }
.race-total { font-size:.9rem; font-weight:700; margin-top:8px; }

/* Quiz */
.quiz-question { background:var(--surface); border:1px solid var(--border); border-radius:var(--radius); padding:20px; margin:16px 0; }
.quiz-question h4 { margin-bottom:12px; }
.quiz-question pre { background:var(--surface2); padding:12px; border-radius:6px; margin:10px 0; font-family:var(--font-mono); font-size:.84rem; line-height:1.6; overflow-x:auto; }
.quiz-options { display:flex; flex-direction:column; gap:8px; }
.quiz-opt { padding:10px 14px; border:1px solid var(--border); border-radius:6px; cursor:pointer; transition:.2s; font-size:.9rem; }
.quiz-opt:hover { border-color:var(--blue); background:rgba(88,166,255,.06); }
.quiz-opt.selected { border-color:var(--blue); background:rgba(88,166,255,.12); }
.quiz-opt.correct { border-color:var(--green); background:rgba(63,185,80,.12); color:var(--green); }
.quiz-opt.wrong { border-color:var(--red); background:rgba(248,81,73,.12); color:var(--red); }
.quiz-opt.disabled { pointer-events:none; }
.quiz-explanation { margin-top:12px; padding:12px; border-radius:6px; font-size:.85rem; display:none; }
.quiz-explanation.show { display:block; }
.quiz-explanation.right { background:rgba(63,185,80,.1); border:1px solid rgba(63,185,80,.3); color:var(--green); }
.quiz-explanation.wrong-exp { background:rgba(248,81,73,.1); border:1px solid rgba(248,81,73,.3); color:var(--red); }
.quiz-score { background:var(--surface); border:1px solid var(--border); border-radius:var(--radius); padding:24px; text-align:center; margin:20px 0; display:none; }
.quiz-score h3 { font-size:1.5rem; margin-bottom:8px; }
.quiz-score .score-num { font-size:3rem; font-weight:800; }
.quiz-submit { padding:10px 28px; background:var(--blue); color:#000; border:none; border-radius:6px; font-size:.95rem; font-weight:600; cursor:pointer; margin-top:12px; transition:.2s; }
.quiz-submit:hover { opacity:.85; }

/* Exercise */
.exercise { background:var(--surface); border:1px solid var(--border); border-radius:var(--radius); margin:16px 0; overflow:hidden; }
.exercise-header { padding:16px 20px; border-bottom:1px solid var(--border); }
.exercise-header h4 { display:flex; align-items:center; gap:8px; }
.exercise-diff { font-size:.7rem; padding:2px 8px; border-radius:10px; font-weight:600; }
.exercise-diff.easy { background:rgba(63,185,80,.15); color:var(--green); }
.exercise-diff.medium { background:rgba(210,153,34,.15); color:var(--yellow); }
.exercise-diff.hard { background:rgba(248,81,73,.15); color:var(--red); }
.exercise-desc { padding:12px 20px; font-size:.88rem; color:var(--text-dim); border-bottom:1px solid var(--border); }
.exercise textarea { width:100%; min-height:180px; background:var(--surface2); color:var(--text); border:none; padding:14px; font-family:var(--font-mono); font-size:.85rem; line-height:1.6; resize:vertical; outline:none; }
.exercise textarea:focus { box-shadow:inset 0 0 0 1px var(--blue); }
.exercise-actions { padding:12px 20px; display:flex; gap:8px; border-top:1px solid var(--border); }
.hint-btn { padding:6px 16px; border:1px solid var(--border); background:none; color:var(--yellow); border-radius:6px; cursor:pointer; font-size:.82rem; }
.check-btn { padding:6px 16px; border:none; background:var(--green); color:#000; border-radius:6px; cursor:pointer; font-size:.82rem; font-weight:600; }
.exercise-result { padding:12px 20px; font-size:.85rem; display:none; }
.exercise-result.pass { background:rgba(63,185,80,.1); color:var(--green); }
.exercise-result.fail { background:rgba(248,81,73,.1); color:var(--red); }
.hint-box { padding:12px 20px; background:rgba(210,153,34,.08); border-top:1px solid rgba(210,153,34,.2); font-size:.85rem; color:var(--yellow); display:none; }

/* Key concept callout */
.key-concept { display:flex; gap:12px; padding:16px; background:rgba(188,140,255,.08); border:1px solid rgba(188,140,255,.3); border-radius:var(--radius); margin:16px 0; }
.key-concept .icon { font-size:1.5rem; flex-shrink:0; }
.key-concept p { margin:0; color:var(--text); font-size:.9rem; }

/* Navigation buttons */
.nav-btns { display:flex; justify-content:space-between; margin-top:40px; padding-top:20px; border-top:1px solid var(--border); }
.nav-btn { padding:10px 22px; border:1px solid var(--border); background:var(--surface); color:var(--text); border-radius:6px; cursor:pointer; font-size:.88rem; transition:.2s; text-decoration:none; }
.nav-btn:hover { border-color:var(--blue); color:var(--blue); }
.nav-btn.next { background:var(--blue); color:#000; border-color:var(--blue); font-weight:600; }

/* Badges */
.badge { display:inline-flex; align-items:center; gap:4px; padding:2px 10px; border-radius:12px; font-size:.75rem; font-weight:600; }
.badge.new { background:rgba(88,166,255,.15); color:var(--blue); }
.badge.important { background:rgba(248,81,73,.15); color:var(--red); }

/* Responsive */
@media(max-width:850px) {
  #sidebar { transform:translateX(-100%); transition:transform .3s; }
  #sidebar.open { transform:translateX(0); }
  #hamburger { display:block; }
  #main { margin-left:0; }
  .section { padding:20px 16px 40px; }
  .evolution { grid-template-columns:1fr; }
  .pitfall { grid-template-columns:1fr; }
  .exec-step .step-note { display:none; }
}
</style>
</head>
<body>

<button id="hamburger" onclick="document.getElementById('sidebar').classList.toggle('open')">‚ò∞</button>

<nav id="sidebar">
  <div class="logo">
    <span class="logo-icon">‚ö°</span>
    <span class="logo-text">Async/Await<br><small>Master Course</small></span>
  </div>
  <ul class="nav-links" id="navLinks">
    <li><a href="#" data-s="intro" class="active">üöÄ Introduction<span class="checkmark">‚úì</span></a></li>
    <li><a href="#" data-s="async-fn">üì¶ Async Functions<span class="checkmark">‚úì</span></a></li>
    <li><a href="#" data-s="await-kw">‚è≥ Await Keyword<span class="checkmark">‚úì</span></a></li>
    <li><a href="#" data-s="exec-flow">üîÑ Execution Flow<span class="checkmark">‚úì</span></a></li>
    <li><a href="#" data-s="errors">üõ°Ô∏è Error Handling<span class="checkmark">‚úì</span></a></li>
    <li><a href="#" data-s="patterns">üß© Async Patterns<span class="checkmark">‚úì</span></a></li>
    <li><a href="#" data-s="pitfalls">‚ö†Ô∏è Pitfalls<span class="checkmark">‚úì</span></a></li>
    <li><a href="#" data-s="quiz">üìù Master Quiz<span class="checkmark">‚úì</span></a></li>
    <li><a href="#" data-s="exercises">üí™ Exercises<span class="checkmark">‚úì</span></a></li>
  </ul>
  <div class="progress-box">
    <div class="progress-label">Course Progress</div>
    <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
    <div class="progress-text" id="progressText">0 / 9</div>
  </div>
</nav>

<main id="main">

<!-- ==================== SECTION 1: INTRO ==================== -->
<div class="section active" id="s-intro">
  <h1>üöÄ Mastering Async/Await</h1>
  <p>Write clean, readable asynchronous JavaScript ‚Äî the modern way. This course will take you from fundamentals to job-ready confidence.</p>

  <h2>The Evolution of Async JavaScript</h2>
  <p>JavaScript has evolved through <strong>three major eras</strong> of handling asynchronous operations:</p>

  <div class="evolution">
    <div class="evo-card">
      <div class="emoji">üò∞</div>
      <h4 style="color:var(--red)">Callbacks</h4>
      <p style="font-size:.82rem;color:var(--text-dim)">Nested, hard to read, "callback hell"</p>
    </div>
    <div class="evo-card">
      <div class="emoji">ü§î</div>
      <h4 style="color:var(--yellow)">Promises</h4>
      <p style="font-size:.82rem;color:var(--text-dim)">Better chaining, but .then() chains get long</p>
    </div>
    <div class="evo-card best">
      <div class="emoji">üòé</div>
      <h4 style="color:var(--green)">Async/Await</h4>
      <p style="font-size:.82rem;color:var(--text-dim)">Reads like sync code, easy error handling</p>
    </div>
  </div>

  <h3>See the Difference</h3>
  <div class="tabs">
    <button class="tab-btn active" data-tab="cb-tab">Callbacks üò∞</button>
    <button class="tab-btn" data-tab="pr-tab">Promises ü§î</button>
    <button class="tab-btn" data-tab="aa-tab">Async/Await üòé</button>
  </div>
  <div class="tab-content active" id="cb-tab">
    <div class="code-block"><div class="code-header"><span class="code-title">callbacks.js</span></div><div class="code-body"><pre><span class="cm">// ‚ùå Callback Hell ‚Äî deeply nested, hard to follow</span>
<span class="fn">getUser</span>(<span class="num">1</span>, <span class="kw">function</span>(<span class="op">err</span>, <span class="op">user</span>) {
  <span class="kw">if</span> (err) <span class="kw">return</span> <span class="fn">handleError</span>(err);
  <span class="fn">getPosts</span>(user.id, <span class="kw">function</span>(<span class="op">err</span>, <span class="op">posts</span>) {
    <span class="kw">if</span> (err) <span class="kw">return</span> <span class="fn">handleError</span>(err);
    <span class="fn">getComments</span>(posts[<span class="num">0</span>].id, <span class="kw">function</span>(<span class="op">err</span>, <span class="op">comments</span>) {
      <span class="kw">if</span> (err) <span class="kw">return</span> <span class="fn">handleError</span>(err);
      <span class="bi">console</span>.<span class="fn">log</span>(comments);  <span class="cm">// Finally!</span>
    });
  });
});</pre></div></div>
  </div>
  <div class="tab-content" id="pr-tab">
    <div class="code-block"><div class="code-header"><span class="code-title">promises.js</span></div><div class="code-body"><pre><span class="cm">// ü§∑ Promise chains ‚Äî better, but still verbose</span>
<span class="fn">getUser</span>(<span class="num">1</span>)
  .<span class="fn">then</span>(<span class="op">user</span> <span class="kw">=></span> <span class="fn">getPosts</span>(user.id))
  .<span class="fn">then</span>(<span class="op">posts</span> <span class="kw">=></span> <span class="fn">getComments</span>(posts[<span class="num">0</span>].id))
  .<span class="fn">then</span>(<span class="op">comments</span> <span class="kw">=></span> {
    <span class="bi">console</span>.<span class="fn">log</span>(comments);
  })
  .<span class="fn">catch</span>(<span class="op">err</span> <span class="kw">=></span> <span class="fn">handleError</span>(err));</pre></div></div>
  </div>
  <div class="tab-content" id="aa-tab">
    <div class="code-block"><div class="code-header"><span class="code-title">async-await.js ‚ú®</span></div><div class="code-body"><pre><span class="cm">// ‚úÖ Async/Await ‚Äî clean, readable, easy error handling</span>
<span class="kw">async function</span> <span class="fn">loadData</span>() {
  <span class="kw">try</span> {
    <span class="kw">const</span> user = <span class="kw">await</span> <span class="fn">getUser</span>(<span class="num">1</span>);
    <span class="kw">const</span> posts = <span class="kw">await</span> <span class="fn">getPosts</span>(user.id);
    <span class="kw">const</span> comments = <span class="kw">await</span> <span class="fn">getComments</span>(posts[<span class="num">0</span>].id);
    <span class="bi">console</span>.<span class="fn">log</span>(comments);
  } <span class="kw">catch</span> (err) {
    <span class="fn">handleError</span>(err);
  }
}</pre></div></div>
  </div>

  <div class="key-concept">
    <span class="icon">üí°</span>
    <p><strong>Key Insight:</strong> Async/Await is <em>syntactic sugar</em> built on top of Promises. It doesn't replace Promises ‚Äî it makes them easier to write and read. Under the hood, <code>await</code> is still working with Promises.</p>
  </div>

  <h2>What You'll Master</h2>
  <ul>
    <li>‚úÖ <strong>Async function syntax</strong> ‚Äî all the ways to declare them</li>
    <li>‚úÖ <strong>The await keyword</strong> ‚Äî how it pauses and resumes execution</li>
    <li>‚úÖ <strong>Error handling</strong> ‚Äî try/catch/finally patterns</li>
    <li>‚úÖ <strong>Async patterns</strong> ‚Äî sequential, parallel, racing</li>
    <li>‚úÖ <strong>Common pitfalls</strong> ‚Äî mistakes that trip up beginners (and seniors!)</li>
    <li>‚úÖ <strong>Interview-ready knowledge</strong> ‚Äî quizzes & coding exercises</li>
  </ul>

  <div class="nav-btns">
    <span></span>
    <button class="nav-btn next" onclick="goTo('async-fn')">Start Learning ‚Üí</button>
  </div>
</div>

<!-- ==================== SECTION 2: ASYNC FUNCTIONS ==================== -->
<div class="section" id="s-async-fn">
  <h1>üì¶ Async Functions</h1>
  <p>An <strong>async function</strong> is a function that always returns a Promise and allows you to use the <code>await</code> keyword inside it.</p>

  <h2>Syntax ‚Äî 4 Ways to Declare</h2>

  <div class="code-block"><div class="code-header"><span class="code-title">1. Function Declaration</span><button class="run-btn" onclick="runExample(this)">‚ñ∂ Run</button></div><div class="code-body"><pre>
async function fetchData() {
  return "Hello from async!";
}

// It returns a Promise!
fetchData().then(result => console.log(result));
console.log("Type:", typeof fetchData());
</pre></div><div class="console-output"></div></div>

  <div class="code-block"><div class="code-header"><span class="code-title">2. Function Expression</span><button class="run-btn" onclick="runExample(this)">‚ñ∂ Run</button></div><div class="code-body"><pre>
const fetchData = async function() {
  return 42;
};

fetchData().then(val => console.log("Got:", val));
</pre></div><div class="console-output"></div></div>

  <div class="code-block"><div class="code-header"><span class="code-title">3. Arrow Function (most common in modern code)</span><button class="run-btn" onclick="runExample(this)">‚ñ∂ Run</button></div><div class="code-body"><pre>
const fetchData = async () => {
  return { name: "Alice", age: 30 };
};

fetchData().then(user => console.log("User:", JSON.stringify(user)));
</pre></div><div class="console-output"></div></div>

  <div class="code-block"><div class="code-header"><span class="code-title">4. Method in Object / Class</span><button class="run-btn" onclick="runExample(this)">‚ñ∂ Run</button></div><div class="code-body"><pre>
const api = {
  async getUser(id) {
    return { id, name: "User " + id };
  }
};

class UserService {
  async findById(id) {
    return { id, name: "Class User " + id };
  }
}

api.getUser(1).then(u => console.log("Object method:", JSON.stringify(u)));
new UserService().findById(2).then(u => console.log("Class method:", JSON.stringify(u)));
</pre></div><div class="console-output"></div></div>

  <h2>The Golden Rule</h2>
  <div class="card highlight">
    <div class="card-title">‚≠ê An async function ALWAYS returns a Promise</div>
    <p style="margin:0;color:var(--text-dim);font-size:.9rem">Even if you return a plain value, it gets automatically wrapped in <code>Promise.resolve()</code>. If you throw an error, it returns a rejected Promise.</p>
  </div>

  <div class="code-block"><div class="code-header"><span class="code-title">Return values are wrapped in Promises</span><button class="run-btn" onclick="runExample(this)">‚ñ∂ Run</button></div><div class="code-body"><pre>
async function returnString() {
  return "hello";  // Becomes Promise.resolve("hello")
}

async function returnNothing() {
  // no return  ‚Üí  Promise.resolve(undefined)
}

async function throwError() {
  throw new Error("oops");  // Becomes Promise.reject(Error("oops"))
}

returnString().then(v => console.log("1:", v));
returnNothing().then(v => console.log("2:", v));
throwError().catch(e => console.log("3:", e.message));
</pre></div><div class="console-output"></div></div>

  <div class="key-concept">
    <span class="icon">üéØ</span>
    <p><strong>Interview Tip:</strong> When asked "What does an async function return?", the answer is <em>always a Promise</em>. Even <code>async function foo() { return 5; }</code> returns <code>Promise&lt;number&gt;</code>, not <code>5</code>.</p>
  </div>

  <div class="nav-btns">
    <button class="nav-btn" onclick="goTo('intro')">‚Üê Introduction</button>
    <button class="nav-btn next" onclick="goTo('await-kw')">Await Keyword ‚Üí</button>
  </div>
</div>

<!-- ==================== SECTION 3: AWAIT ==================== -->
<div class="section" id="s-await-kw">
  <h1>‚è≥ The Await Keyword</h1>
  <p>The <code>await</code> keyword <strong>pauses</strong> the async function until the Promise settles, then <strong>unwraps</strong> its resolved value.</p>

  <h2>How Await Works</h2>
  <div class="card highlight">
    <div class="card-title">üîë Three things await does:</div>
    <ol style="margin:8px 0 0 20px;color:var(--text-dim)">
      <li><strong>Pauses</strong> the async function execution</li>
      <li><strong>Waits</strong> for the Promise to resolve (or reject)</li>
      <li><strong>Unwraps</strong> the resolved value from the Promise</li>
    </ol>
  </div>

  <div class="code-block"><div class="code-header"><span class="code-title">Basic await usage</span><button class="run-btn" onclick="runExample(this)">‚ñ∂ Run</button></div><div class="code-body"><pre>
function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

async function demo() {
  console.log("1. Start");
  
  await delay(1000);  // Pause for 1 second
  console.log("2. After 1 second");
  
  await delay(500);   // Pause for 0.5 seconds
  console.log("3. After 1.5 seconds total");
  
  const result = await Promise.resolve(42);
  console.log("4. Result:", result);  // 42, not Promise{42}
}

demo();
</pre></div><div class="console-output"></div></div>

  <h2>Await Unwraps Promise Values</h2>
  <div class="code-block"><div class="code-header"><span class="code-title">Without await vs with await</span><button class="run-btn" onclick="runExample(this)">‚ñ∂ Run</button></div><div class="code-body"><pre>
async function example() {
  const promise = Promise.resolve("Hello!");
  
  // WITHOUT await ‚Äî you get the Promise object
  console.log("Without await:", promise);
  console.log("Is Promise?", promise instanceof Promise);
  
  // WITH await ‚Äî you get the unwrapped value
  const value = await promise;
  console.log("With await:", value);
  console.log("Is string?", typeof value === "string");
}
example();
</pre></div><div class="console-output"></div></div>

  <h2>Where Can You Use Await?</h2>
  <div class="card warning">
    <div class="card-title">‚ö†Ô∏è Rules for using await</div>
    <ul style="margin:8px 0 0 16px;color:var(--text-dim);font-size:.9rem">
      <li><strong>Inside async functions</strong> ‚Äî always works ‚úÖ</li>
      <li><strong>Top-level in ES modules</strong> ‚Äî works in modern environments ‚úÖ</li>
      <li><strong>Regular functions</strong> ‚Äî SyntaxError! ‚ùå</li>
      <li><strong>Callbacks inside async functions</strong> ‚Äî tricky! ‚ö†Ô∏è (more in Pitfalls)</li>
    </ul>
  </div>

  <div class="code-block"><div class="code-header"><span class="code-title">Where await works and doesn't</span><button class="run-btn" onclick="runExample(this)">‚ñ∂ Run</button></div><div class="code-body"><pre>
// ‚úÖ Works ‚Äî inside async function
async function works() {
  const val = await Promise.resolve("works!");
  console.log(val);
}
works();

// ‚ùå Would NOT work in a regular function:
// function broken() {
//   const val = await Promise.resolve("nope");
//   // SyntaxError: await is only valid in async functions
// }

// ‚úÖ Works ‚Äî await with any "thenable"
const thenable = {
  then(resolve) { resolve("I'm thenable!"); }
};

async function thenableDemo() {
  const result = await thenable;
  console.log("Thenable result:", result);
}
thenableDemo();
</pre></div><div class="console-output"></div></div>

  <h2>Await with Non-Promises</h2>
  <div class="code-block"><div class="code-header"><span class="code-title">Await works with regular values too</span><button class="run-btn" onclick="runExample(this)">‚ñ∂ Run</button></div><div class="code-body"><pre>
async function demo() {
  // Await on non-Promise values just returns them immediately
  const a = await 42;
  const b = await "hello";
  const c = await true;
  
  console.log(a, b, c);  // 42 "hello" true
  
  // It's equivalent to: await Promise.resolve(42)
  // Useful: you don't need to check if something is a Promise!
}
demo();
</pre></div><div class="console-output"></div></div>

  <div class="key-concept">
    <span class="icon">üí°</span>
    <p><strong>Pro Tip:</strong> <code>await</code> converts non-Promise values via <code>Promise.resolve()</code>, so you can <code>await</code> any value safely. This is useful when a function might return either a cached value or a Promise.</p>
  </div>

  <div class="nav-btns">
    <button class="nav-btn" onclick="goTo('async-fn')">‚Üê Async Functions</button>
    <button class="nav-btn next" onclick="goTo('exec-flow')">Execution Flow ‚Üí</button>
  </div>
</div>

<!-- ==================== SECTION 4: EXECUTION FLOW ==================== -->
<div class="section" id="s-exec-flow">
  <h1>üîÑ Execution Flow Visualized</h1>
  <p>Understanding <strong>when</strong> each line runs is crucial for interviews. Let's visualize it step-by-step.</p>

  <h2>Step-by-Step Execution</h2>
  <p>Click <strong>Next Step</strong> to see how JavaScript executes this async code:</p>

  <div class="exec-viz" id="execViz1">
    <div class="exec-timeline" id="execTimeline1"></div>
    <div class="exec-controls">
      <button class="primary" onclick="execStep('execViz1',1)">Next Step ‚ñ∂</button>
      <button onclick="execStep('execViz1',0)">‚ü≤ Reset</button>
    </div>
    <div class="console-output" id="execConsole1" style="margin-top:12px;min-height:60px"></div>
  </div>

  <h2>The Key Insight: Await Suspends, Not Blocks</h2>
  <div class="card highlight">
    <div class="card-title">üß† Critical Difference</div>
    <p style="margin:0;color:var(--text-dim);font-size:.9rem">When an async function hits <code>await</code>, it <strong>suspends itself</strong> and returns control to the caller. Other code can run while it waits. This is different from synchronous blocking (like <code>alert()</code>) which freezes everything.</p>
  </div>

  <div class="code-block"><div class="code-header"><span class="code-title">üß™ Predict the output order!</span><button class="run-btn" onclick="runExample(this)">‚ñ∂ Run</button></div><div class="code-body"><pre>
async function cook() {
  console.log("2. Start cooking");
  await new Promise(r => setTimeout(r, 100));
  console.log("4. Food is ready!");
}

console.log("1. Before calling cook");
const promise = cook();  // Starts cooking
console.log("3. After calling cook (cook is suspended at await)");
await promise;            // Wait for cooking to finish
console.log("5. All done!");
</pre></div><div class="console-output"></div></div>

  <h2>Sequential vs Parallel ‚Äî Visual Race</h2>
  <p>Watch the difference between running tasks one-by-one vs all at once:</p>

  <div class="race-viz" id="raceViz">
    <h3 style="margin-bottom:12px">üèÅ Task Execution Race</h3>
    <div style="display:grid;grid-template-columns:1fr 1fr;gap:20px">
      <div>
        <h4 style="color:var(--red);margin-bottom:8px">Sequential (one by one)</h4>
        <div class="race-row"><label>Task A (1s)</label><div class="race-bar-track"><div class="race-bar" id="seqA" style="background:var(--red)">A</div></div></div>
        <div class="race-row"><label>Task B (1.5s)</label><div class="race-bar-track"><div class="race-bar" id="seqB" style="background:var(--orange)">B</div></div></div>
        <div class="race-row"><label>Task C (0.8s)</label><div class="race-bar-track"><div class="race-bar" id="seqC" style="background:var(--yellow)">C</div></div></div>
        <div class="race-total" id="seqTotal">Total: ‚Äî</div>
      </div>
      <div>
        <h4 style="color:var(--green);margin-bottom:8px">Parallel (all at once)</h4>
        <div class="race-row"><label>Task A (1s)</label><div class="race-bar-track"><div class="race-bar" id="parA" style="background:var(--green)">A</div></div></div>
        <div class="race-row"><label>Task B (1.5s)</label><div class="race-bar-track"><div class="race-bar" id="parB" style="background:var(--cyan)">B</div></div></div>
        <div class="race-row"><label>Task C (0.8s)</label><div class="race-bar-track"><div class="race-bar" id="parC" style="background:var(--blue)">C</div></div></div>
        <div class="race-total" id="parTotal">Total: ‚Äî</div>
      </div>
    </div>
    <div class="exec-controls" style="margin-top:16px">
      <button class="primary" onclick="startRace()">üèÅ Start Race!</button>
      <button onclick="resetRace()">‚ü≤ Reset</button>
    </div>
  </div>

  <div class="nav-btns">
    <button class="nav-btn" onclick="goTo('await-kw')">‚Üê Await Keyword</button>
    <button class="nav-btn next" onclick="goTo('errors')">Error Handling ‚Üí</button>
  </div>
</div>

<!-- ==================== SECTION 5: ERROR HANDLING ==================== -->
<div class="section" id="s-errors">
  <h1>üõ°Ô∏è Error Handling</h1>
  <p>One of the biggest advantages of async/await: you can use <strong>try/catch</strong> just like synchronous code!</p>

  <h2>Basic try/catch</h2>
  <div class="code-block"><div class="code-header"><span class="code-title">Catching async errors</span><button class="run-btn" onclick="runExample(this)">‚ñ∂ Run</button></div><div class="code-body"><pre>
async function fetchUser(id) {
  // Simulate API that might fail
  await new Promise(r => setTimeout(r, 200));
  if (id <= 0) throw new Error("Invalid user ID");
  return { id, name: "User " + id };
}

async function main() {
  try {
    const user = await fetchUser(-1);  // This will throw!
    console.log("User:", user);        // Never reached
  } catch (error) {
    console.log("Caught error:", error.message);
  }
  console.log("Code continues after catch!");
}
main();
</pre></div><div class="console-output"></div></div>

  <h2>try / catch / finally</h2>
  <div class="code-block"><div class="code-header"><span class="code-title">Finally block ‚Äî always runs</span><button class="run-btn" onclick="runExample(this)">‚ñ∂ Run</button></div><div class="code-body"><pre>
async function loadData() {
  console.log("‚è≥ Loading started...");
  try {
    // Simulate API call
    await new Promise((_, reject) => 
      setTimeout(() => reject(new Error("Network timeout")), 300)
    );
    console.log("Data loaded!");
  } catch (error) {
    console.log("‚ùå Error:", error.message);
  } finally {
    // Always runs ‚Äî perfect for cleanup!
    console.log("üßπ Cleanup: hiding spinner, closing connections...");
  }
}
loadData();
</pre></div><div class="console-output"></div></div>

  <div class="key-concept">
    <span class="icon">üéØ</span>
    <p><strong>Real-World Pattern:</strong> Use <code>finally</code> for cleanup ‚Äî hiding loading spinners, closing database connections, releasing locks. It runs whether the operation succeeded or failed.</p>
  </div>

  <h2>Handling Multiple Awaits</h2>
  <div class="code-block"><div class="code-header"><span class="code-title">One try/catch for multiple operations</span><button class="run-btn" onclick="runExample(this)">‚ñ∂ Run</button></div><div class="code-body"><pre>
async function simulateAPI(name, shouldFail = false) {
  await new Promise(r => setTimeout(r, 200));
  if (shouldFail) throw new Error(name + " failed!");
  return name + " data";
}

async function loadDashboard() {
  try {
    // If ANY of these fail, we jump to catch
    const user = await simulateAPI("User");
    console.log("‚úÖ", user);
    
    const posts = await simulateAPI("Posts", true); // This fails!
    console.log("‚úÖ", posts);  // Never reached
    
    const comments = await simulateAPI("Comments");
    console.log("‚úÖ", comments);  // Never reached
    
  } catch (error) {
    console.log("‚ùå Dashboard error:", error.message);
    console.log("‚Ü≥ We can show a fallback UI here");
  }
}
loadDashboard();
</pre></div><div class="console-output"></div></div>

  <h2>Individual Error Handling</h2>
  <div class="code-block"><div class="code-header"><span class="code-title">Handle each operation independently</span><button class="run-btn" onclick="runExample(this)">‚ñ∂ Run</button></div><div class="code-body"><pre>
async function safeFetch(name, shouldFail = false) {
  await new Promise(r => setTimeout(r, 150));
  if (shouldFail) throw new Error(name + " unavailable");
  return name + ": OK";
}

async function loadDashboard() {
  // Each operation handles its own errors
  let user, posts, notifications;
  
  try { user = await safeFetch("User"); }
  catch { user = "User: using cached data"; }
  
  try { posts = await safeFetch("Posts", true); } // fails
  catch { posts = "Posts: unavailable, showing placeholder"; }
  
  try { notifications = await safeFetch("Notifications"); }
  catch { notifications = "Notifications: offline"; }
  
  // All results available ‚Äî some real, some fallbacks
  console.log(user);
  console.log(posts);
  console.log(notifications);
}
loadDashboard();
</pre></div><div class="console-output"></div></div>

  <h2>Error Propagation</h2>
  <div class="card warning">
    <div class="card-title">‚ö†Ô∏è Unhandled rejections crash your app!</div>
    <p style="margin:0;color:var(--text-dim);font-size:.88rem">If you don't catch an error from an async function, it becomes an <strong>unhandled promise rejection</strong>. In Node.js, this can crash your process. Always handle errors at some level.</p>
  </div>

  <div class="code-block"><div class="code-header"><span class="code-title">Errors bubble up through async calls</span><button class="run-btn" onclick="runExample(this)">‚ñ∂ Run</button></div><div class="code-body"><pre>
async function innerFn() {
  throw new Error("Deep error");  // Not caught here
}

async function middleFn() {
  await innerFn();  // Error propagates up (not caught here either)
}

async function outerFn() {
  try {
    await middleFn();  // Caught HERE!
  } catch (error) {
    console.log("Caught at outer level:", error.message);
    console.log("‚Ü≥ Errors bubble up through the async call chain");
  }
}
outerFn();
</pre></div><div class="console-output"></div></div>

  <div class="nav-btns">
    <button class="nav-btn" onclick="goTo('exec-flow')">‚Üê Execution Flow</button>
    <button class="nav-btn next" onclick="goTo('patterns')">Async Patterns ‚Üí</button>
  </div>
</div>

<!-- ==================== SECTION 6: PATTERNS ==================== -->
<div class="section" id="s-patterns">
  <h1>üß© Async Patterns</h1>
  <p>Master these patterns to write efficient async code ‚Äî a top interview topic!</p>

  <h2>1. Sequential Execution</h2>
  <p>Each operation waits for the previous one. Use when order matters or results depend on each other.</p>
  <div class="code-block"><div class="code-header"><span class="code-title">Sequential ‚Äî each await waits for the previous</span><button class="run-btn" onclick="runExample(this)">‚ñ∂ Run</button></div><div class="code-body"><pre>
async function delay(ms, label) {
  await new Promise(r => setTimeout(r, ms));
  console.log("‚úÖ " + label + " done (" + ms + "ms)");
  return label;
}

async function sequential() {
  console.time("Sequential");
  
  const a = await delay(300, "Task A");  // wait 300ms
  const b = await delay(200, "Task B");  // then wait 200ms
  const c = await delay(100, "Task C");  // then wait 100ms
  
  console.timeEnd("Sequential");  // ~600ms total
  console.log("Results:", a, b, c);
}
sequential();
</pre></div><div class="console-output"></div></div>

  <h2>2. Parallel Execution ‚Äî Promise.all()</h2>
  <p>Start all operations at once. Use when tasks are <strong>independent</strong>.</p>
  <div class="code-block"><div class="code-header"><span class="code-title">Parallel ‚Äî all at once with Promise.all</span><button class="run-btn" onclick="runExample(this)">‚ñ∂ Run</button></div><div class="code-body"><pre>
async function delay(ms, label) {
  await new Promise(r => setTimeout(r, ms));
  console.log("‚úÖ " + label + " done (" + ms + "ms)");
  return label;
}

async function parallel() {
  console.time("Parallel");
  
  // Start ALL at the same time
  const [a, b, c] = await Promise.all([
    delay(300, "Task A"),
    delay(200, "Task B"),
    delay(100, "Task C"),
  ]);
  
  console.timeEnd("Parallel");  // ~300ms total (fastest!)
  console.log("Results:", a, b, c);
}
parallel();
</pre></div><div class="console-output"></div></div>

  <div class="card danger">
    <div class="card-title">‚ö° Promise.all ‚Äî Fail-Fast Behavior</div>
    <p style="margin:0;color:var(--text-dim);font-size:.88rem">If <strong>any</strong> promise rejects, <code>Promise.all</code> immediately rejects with that error. The other promises still run, but their results are discarded.</p>
  </div>

  <h2>3. Promise.allSettled()</h2>
  <p>Like <code>Promise.all</code> but <strong>never rejects</strong>. Waits for all promises, reports each result.</p>
  <div class="code-block"><div class="code-header"><span class="code-title">allSettled ‚Äî get all results, including failures</span><button class="run-btn" onclick="runExample(this)">‚ñ∂ Run</button></div><div class="code-body"><pre>
async function task(name, shouldFail) {
  await new Promise(r => setTimeout(r, 200));
  if (shouldFail) throw new Error(name + " failed");
  return name + " succeeded";
}

async function demo() {
  const results = await Promise.allSettled([
    task("API-1", false),
    task("API-2", true),   // This one fails
    task("API-3", false),
  ]);
  
  results.forEach(r => {
    if (r.status === "fulfilled") {
      console.log("‚úÖ", r.value);
    } else {
      console.log("‚ùå", r.reason.message);
    }
  });
}
demo();
</pre></div><div class="console-output"></div></div>

  <h2>4. Promise.race()</h2>
  <p>Returns the result of the <strong>first</strong> promise to settle (resolve or reject).</p>
  <div class="code-block"><div class="code-header"><span class="code-title">Timeout pattern using Promise.race</span><button class="run-btn" onclick="runExample(this)">‚ñ∂ Run</button></div><div class="code-body"><pre>
function timeout(ms) {
  return new Promise((_, reject) => 
    setTimeout(() => reject(new Error("Timed out!")), ms)
  );
}

function slowAPI() {
  return new Promise(resolve =>
    setTimeout(() => resolve("API data"), 800)
  );
}

async function fetchWithTimeout() {
  try {
    // Race between API call and timeout
    const result = await Promise.race([
      slowAPI(),
      timeout(500)  // 500ms timeout
    ]);
    console.log("Got:", result);
  } catch (error) {
    console.log("‚ùå", error.message);
  }
}
fetchWithTimeout();
</pre></div><div class="console-output"></div></div>

  <h2>5. Promise.any()</h2>
  <p>Returns the first promise to <strong>resolve</strong>. Ignores rejections unless ALL reject.</p>
  <div class="code-block"><div class="code-header"><span class="code-title">Promise.any ‚Äî first success wins</span><button class="run-btn" onclick="runExample(this)">‚ñ∂ Run</button></div><div class="code-body"><pre>
async function fetchFromCDN(name, ms, shouldFail) {
  await new Promise(r => setTimeout(r, ms));
  if (shouldFail) throw new Error(name + " down");
  return name + " responded in " + ms + "ms";
}

async function demo() {
  try {
    const fastest = await Promise.any([
      fetchFromCDN("CDN-US", 300, true),   // Fails!
      fetchFromCDN("CDN-EU", 200, false),  // Wins! (fastest success)
      fetchFromCDN("CDN-Asia", 100, true), // Fails!
    ]);
    console.log("üèÜ Winner:", fastest);
  } catch (error) {
    console.log("All CDNs failed:", error.message);
  }
}
demo();
</pre></div><div class="console-output"></div></div>

  <h2>6. Retry Pattern</h2>
  <div class="code-block"><div class="code-header"><span class="code-title">Retry with exponential backoff</span><button class="run-btn" onclick="runExample(this)">‚ñ∂ Run</button></div><div class="code-body"><pre>
let attempt = 0;
async function unreliableAPI() {
  attempt++;
  await new Promise(r => setTimeout(r, 100));
  if (attempt < 3) throw new Error("Server busy (attempt " + attempt + ")");
  return "Success on attempt " + attempt + "!";
}

async function retry(fn, maxRetries = 3, delayMs = 200) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await fn();
    } catch (error) {
      console.log("‚ö†Ô∏è Attempt " + (i + 1) + " failed:", error.message);
      if (i === maxRetries - 1) throw error;
      const wait = delayMs * Math.pow(2, i);
      console.log("‚è≥ Retrying in " + wait + "ms...");
      await new Promise(r => setTimeout(r, wait));
    }
  }
}

async function main() {
  attempt = 0;
  try {
    const result = await retry(unreliableAPI, 4);
    console.log("üéâ", result);
  } catch (e) {
    console.log("üíÄ All retries failed:", e.message);
  }
}
main();
</pre></div><div class="console-output"></div></div>

  <h2>7. Async Loop ‚Äî Processing Items</h2>
  <div class="code-block"><div class="code-header"><span class="code-title">for...of loop with await (sequential)</span><button class="run-btn" onclick="runExample(this)">‚ñ∂ Run</button></div><div class="code-body"><pre>
async function processItem(item) {
  await new Promise(r => setTimeout(r, 150));
  return item.toUpperCase();
}

async function processAll(items) {
  // Sequential: one at a time (use when order matters)
  console.log("Sequential processing:");
  for (const item of items) {
    const result = await processItem(item);
    console.log("  ‚Üí", result);
  }
  
  // Parallel: all at once (use when independent)
  console.log("Parallel processing:");
  const results = await Promise.all(items.map(i => processItem(i)));
  console.log("  ‚Üí", results.join(", "));
}
processAll(["apple", "banana", "cherry"]);
</pre></div><div class="console-output"></div></div>

  <div class="nav-btns">
    <button class="nav-btn" onclick="goTo('errors')">‚Üê Error Handling</button>
    <button class="nav-btn next" onclick="goTo('pitfalls')">Pitfalls ‚Üí</button>
  </div>
</div>

<!-- ==================== SECTION 7: PITFALLS ==================== -->
<div class="section" id="s-pitfalls">
  <h1>‚ö†Ô∏è Pitfalls & Mistakes</h1>
  <p>These are the mistakes that <strong>trip up developers in interviews and production</strong>. Study each one carefully!</p>

  <h2>Pitfall #1: Forgetting await</h2>
  <div class="pitfall">
    <div class="pitfall-bad"><div class="pitfall-label">‚ùå WRONG ‚Äî forgot await</div><pre>
async function getUser() {
  return { name: "Alice" };
}

async function main() {
  const user = getUser();
  // user is a Promise, not the object!
  console.log(user.name); // undefined!
}</pre></div>
    <div class="pitfall-good"><div class="pitfall-label">‚úÖ CORRECT ‚Äî using await</div><pre>
async function getUser() {
  return { name: "Alice" };
}

async function main() {
  const user = await getUser();
  // user is now the actual object
  console.log(user.name); // "Alice" ‚úì
}</pre></div>
  </div>

  <h2>Pitfall #2: Unnecessary Sequential Awaits</h2>
  <div class="pitfall">
    <div class="pitfall-bad"><div class="pitfall-label">‚ùå SLOW ‚Äî sequential when could be parallel</div><pre>
async function loadPage() {
  // These don't depend on each other!
  const user = await fetchUser();     // 1s
  const posts = await fetchPosts();   // 1s
  const ads = await fetchAds();       // 1s
  // Total: ~3 seconds üò±
}</pre></div>
    <div class="pitfall-good"><div class="pitfall-label">‚úÖ FAST ‚Äî parallel with Promise.all</div><pre>
async function loadPage() {
  // Run independent tasks in parallel!
  const [user, posts, ads] = await Promise.all([
    fetchUser(),     // 1s ‚îÄ‚îê
    fetchPosts(),    // 1s ‚îÄ‚î§ all at once
    fetchAds(),      // 1s ‚îÄ‚îò
  ]);
  // Total: ~1 second üöÄ
}</pre></div>
  </div>

  <h2>Pitfall #3: await in forEach (BROKEN!)</h2>
  <div class="card danger">
    <div class="card-title">üö® forEach does NOT await! This is a top interview question.</div>
  </div>
  <div class="pitfall">
    <div class="pitfall-bad"><div class="pitfall-label">‚ùå BROKEN ‚Äî forEach ignores await</div><pre>
async function processAll(urls) {
  urls.forEach(async (url) => {
    // Each callback is its own async fn
    // forEach doesn't await them!
    const data = await fetch(url);
    console.log(data);
  });
  console.log("Done!"); 
  // "Done!" prints BEFORE fetches finish!
}</pre></div>
    <div class="pitfall-good"><div class="pitfall-label">‚úÖ CORRECT ‚Äî use for...of or Promise.all</div><pre>
// Option 1: for...of (sequential)
async function processAll(urls) {
  for (const url of urls) {
    const data = await fetch(url);
    console.log(data);
  }
  console.log("Done!"); // After ALL done
}
// Option 2: Promise.all + map (parallel)
async function processAll(urls) {
  await Promise.all(urls.map(async url => {
    const data = await fetch(url);
    console.log(data);
  }));
  console.log("Done!");
}</pre></div>
  </div>

  <h2>Pitfall #4: Missing Error Handling</h2>
  <div class="pitfall">
    <div class="pitfall-bad"><div class="pitfall-label">‚ùå DANGEROUS ‚Äî unhandled rejection</div><pre>
async function loadData() {
  const data = await fetch("/api/data");
  // If fetch fails ‚Üí unhandled rejection
  // In Node.js, this can crash your app!
  return data;
}

loadData(); // No .catch(), no try/catch</pre></div>
    <div class="pitfall-good"><div class="pitfall-label">‚úÖ SAFE ‚Äî always handle errors</div><pre>
async function loadData() {
  try {
    const data = await fetch("/api/data");
    return data;
  } catch (error) {
    console.error("Load failed:", error);
    return null; // graceful fallback
  }
}

// OR catch at the call site:
loadData().catch(console.error);</pre></div>
  </div>

  <h2>Pitfall #5: Returning await (usually unnecessary)</h2>
  <div class="pitfall">
    <div class="pitfall-bad"><div class="pitfall-label">ü§∑ UNNECESSARY ‚Äî return await</div><pre>
async function getUser() {
  // return await is redundant here
  // (the async function already wraps
  // the return in a Promise)
  return await fetchUser(1);
}

</pre></div>
    <div class="pitfall-good"><div class="pitfall-label">‚úÖ CLEANER ‚Äî just return the promise</div><pre>
async function getUser() {
  return fetchUser(1);
}

// EXCEPTION: return await IS needed 
// inside try/catch:
async function getUser() {
  try {
    return await fetchUser(1); // NEEDED!
  } catch (e) { /* handle */ }
}</pre></div>
  </div>

  <h2>Pitfall #6: Creating Promises Inside async Needlessly</h2>
  <div class="pitfall">
    <div class="pitfall-bad"><div class="pitfall-label">‚ùå ANTI-PATTERN ‚Äî promise constructor</div><pre>
async function getData() {
  return new Promise((resolve) => {
    const data = "hello";
    resolve(data);
    // Wrapping sync code in a Promise
    // inside an async function is pointless!
  });
}</pre></div>
    <div class="pitfall-good"><div class="pitfall-label">‚úÖ CLEAN ‚Äî just return the value</div><pre>
async function getData() {
  const data = "hello";
  return data;
  // async already wraps it in a Promise!
}


</pre></div>
  </div>

  <h2>Pitfall #7: Losing this Context</h2>
  <div class="code-block"><div class="code-header"><span class="code-title">‚ö†Ô∏è Be careful with 'this' in async methods</span><button class="run-btn" onclick="runExample(this)">‚ñ∂ Run</button></div><div class="code-body"><pre>
class UserService {
  constructor() {
    this.baseUrl = "https://api.example.com";
  }

  async getUser(id) {
    console.log("URL:", this.baseUrl); // 'this' works here
    return { id, name: "Alice" };
  }
}

const service = new UserService();

// ‚úÖ Works ‚Äî called as method
await service.getUser(1);

// ‚ùå Would break if you destructure the method:
// const { getUser } = service;
// await getUser(1); // 'this' is undefined!

// ‚úÖ Fix ‚Äî bind it
const getUser = service.getUser.bind(service);
await getUser(1);
console.log("Works with bind!");
</pre></div><div class="console-output"></div></div>

  <div class="nav-btns">
    <button class="nav-btn" onclick="goTo('patterns')">‚Üê Async Patterns</button>
    <button class="nav-btn next" onclick="goTo('quiz')">Master Quiz ‚Üí</button>
  </div>
</div>

<!-- ==================== SECTION 8: QUIZ ==================== -->
<div class="section" id="s-quiz">
  <h1>üìù Master Quiz</h1>
  <p>Test your knowledge! These are the types of questions you'll see in <strong>real JavaScript interviews</strong>.</p>
  <div id="quizContainer"></div>
  <div class="quiz-score" id="quizScore">
    <h3>Quiz Complete!</h3>
    <div class="score-num" id="scoreNum"></div>
    <p id="scoreMsg" style="color:var(--text-dim)"></p>
    <button class="quiz-submit" onclick="resetQuiz()">Try Again</button>
  </div>
  <button class="quiz-submit" id="submitQuiz" onclick="submitQuiz()" style="display:none;margin-top:16px">Submit Answers</button>

  <div class="nav-btns">
    <button class="nav-btn" onclick="goTo('pitfalls')">‚Üê Pitfalls</button>
    <button class="nav-btn next" onclick="goTo('exercises')">Exercises ‚Üí</button>
  </div>
</div>

<!-- ==================== SECTION 9: EXERCISES ==================== -->
<div class="section" id="s-exercises">
  <h1>üí™ Coding Exercises</h1>
  <p>Put your skills to the test! Write real async code and check your solutions.</p>
  <div id="exerciseContainer"></div>

  <div class="nav-btns" style="margin-top:40px">
    <button class="nav-btn" onclick="goTo('quiz')">‚Üê Master Quiz</button>
    <span style="color:var(--green);font-weight:700">üéâ Course Complete!</span>
  </div>
</div>

</main>

<script>
// ======================== UTILITIES ========================
function delay(ms) { return new Promise(r => setTimeout(r, ms)); }

// ======================== NAVIGATION ========================
const sections = ['intro','async-fn','await-kw','exec-flow','errors','patterns','pitfalls','quiz','exercises'];
const completed = new Set(JSON.parse(localStorage.getItem('asyncCompleted')||'[]'));

function goTo(id) {
  document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
  document.getElementById('s-' + id).classList.add('active');
  document.querySelectorAll('.nav-links a').forEach(a => {
    a.classList.remove('active');
    if (a.dataset.s === id) a.classList.add('active');
  });

  // Mark previous sections as completed
  const idx = sections.indexOf(id);
  for (let i = 0; i < idx; i++) {
    completed.add(sections[i]);
  }
  saveProgress();
  window.scrollTo(0, 0);
  document.getElementById('sidebar').classList.remove('open');
}

function saveProgress() {
  localStorage.setItem('asyncCompleted', JSON.stringify([...completed]));
  updateProgress();
}

function updateProgress() {
  const pct = Math.round((completed.size / sections.length) * 100);
  document.getElementById('progressFill').style.width = pct + '%';
  document.getElementById('progressText').textContent = completed.size + ' / ' + sections.length;
  document.querySelectorAll('.nav-links a').forEach(a => {
    if (completed.has(a.dataset.s)) a.classList.add('completed');
    else a.classList.remove('completed');
  });
}

// Sidebar click handlers
document.querySelectorAll('.nav-links a').forEach(a => {
  a.addEventListener('click', e => { e.preventDefault(); goTo(a.dataset.s); });
});

// Tab switching
document.querySelectorAll('.tab-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    const group = btn.parentElement;
    group.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    const parent = group.parentElement;
    parent.querySelectorAll('.tab-content').forEach(tc => tc.classList.remove('active'));
    document.getElementById(btn.dataset.tab).classList.add('active');
  });
});

// ======================== CODE RUNNER ========================
async function runExample(btn) {
  const block = btn.closest('.code-block');
  const code = block.querySelector('pre').textContent;
  const output = block.querySelector('.console-output');
  output.innerHTML = '';
  btn.textContent = '‚è≥ Running...';
  btn.disabled = true;

  const _log = console.log;
  const _err = console.error;
  const _time = {};

  function addLine(text, cls = 'log-line') {
    const d = document.createElement('div');
    d.className = cls;
    d.textContent = text;
    output.appendChild(d);
    output.scrollTop = output.scrollHeight;
  }

  console.log = (...args) => {
    const text = args.map(a => {
      if (a === undefined) return 'undefined';
      if (a === null) return 'null';
      if (typeof a === 'object') {
        try { return JSON.stringify(a); } catch { return String(a); }
      }
      return String(a);
    }).join(' ');
    addLine(text, 'log-line');
  };
  console.error = (...args) => addLine(args.join(' '), 'error-line');
  console.time = (label) => { _time[label] = performance.now(); };
  console.timeEnd = (label) => {
    const elapsed = _time[label] ? (performance.now() - _time[label]).toFixed(0) : '?';
    addLine(label + ': ' + elapsed + 'ms', 'info-line');
  };

  try {
    const fn = new Function('delay', `return (async()=>{\n${code}\n})()`);
    await fn(delay);
    await delay(100);
  } catch(e) {
    addLine('Error: ' + e.message, 'error-line');
  }

  console.log = _log;
  console.error = _err;
  console.time = performance.constructor.prototype.time || (() => {});
  btn.textContent = '‚ñ∂ Run';
  btn.disabled = false;
}

// ======================== EXECUTION FLOW VIZ ========================
const execSteps = [
  { code: 'console.log("1. Start")', note: 'Sync ‚Äî runs immediately', log: '1. Start' },
  { code: 'async function getData() {', note: 'Function is defined (not called yet)', log: null },
  { code: '  console.log("2. Inside async")', note: 'Sync code inside async runs immediately', log: '2. Inside async' },
  { code: '  await delay(1000)', note: '‚è∏Ô∏è PAUSED ‚Äî function suspends here, control returns to caller', log: null, pause: true },
  { code: '  console.log("4. After await")', note: '‚ñ∂Ô∏è RESUMED ‚Äî promise resolved, execution continues', log: '4. After await' },
  { code: '}', note: 'Async function completes', log: null },
  { code: 'getData()', note: 'Calls the async function', log: null, jump: true },
  { code: 'console.log("3. After calling getData")', note: 'Runs while getData is paused at await!', log: '3. After calling getData' },
];

let execState = -1;
const actualOrder = [0, 1, 2, 6, 3, 7, 4, 5]; // Execution order

function initExecViz() {
  const timeline = document.getElementById('execTimeline1');
  timeline.innerHTML = '';
  execSteps.forEach((s, i) => {
    const div = document.createElement('div');
    div.className = 'exec-step';
    div.id = 'estep-' + i;
    div.innerHTML = `
      <div class="step-num">${i + 1}</div>
      <div class="step-code" style="font-family:var(--font-mono);font-size:.82rem">${s.code}</div>
      <div class="step-note">${s.note}</div>
    `;
    timeline.appendChild(div);
  });
}

function execStep(vizId, advance) {
  const consoleEl = document.getElementById('execConsole1');
  if (!advance) {
    execState = -1;
    document.querySelectorAll('.exec-step').forEach(s => { s.className = 'exec-step'; });
    consoleEl.innerHTML = '';
    return;
  }
  execState++;
  if (execState >= actualOrder.length) { execState = actualOrder.length - 1; return; }

  const stepIdx = actualOrder[execState];
  const step = execSteps[stepIdx];

  document.querySelectorAll('.exec-step').forEach(s => {
    if (s.classList.contains('active')) {
      s.classList.remove('active');
      s.classList.add('done');
    }
  });
  const el = document.getElementById('estep-' + stepIdx);
  el.classList.add('active');
  el.classList.remove('done');

  if (step.log) {
    const line = document.createElement('div');
    line.className = 'log-line';
    line.textContent = step.log;
    consoleEl.appendChild(line);
  }
  if (step.pause) {
    const line = document.createElement('div');
    line.className = 'info-line';
    line.textContent = '‚è∏Ô∏è Function suspended ‚Äî other code can run now...';
    consoleEl.appendChild(line);
  }
}

initExecViz();

// ======================== RACE VIZ ========================
let raceRunning = false;
async function startRace() {
  if (raceRunning) return;
  raceRunning = true;
  resetRace();
  await delay(100);

  const tasks = [
    { time: 1000, seqEl: 'seqA', parEl: 'parA' },
    { time: 1500, seqEl: 'seqB', parEl: 'parB' },
    { time: 800,  seqEl: 'seqC', parEl: 'parC' },
  ];

  // Sequential
  const seqStart = performance.now();
  (async () => {
    for (const t of tasks) {
      const el = document.getElementById(t.seqEl);
      el.style.transition = `width ${t.time}ms linear`;
      el.style.width = '100%';
      await delay(t.time + 50);
    }
    const total = ((performance.now() - seqStart) / 1000).toFixed(1);
    document.getElementById('seqTotal').textContent = `Total: ~${total}s`;
    document.getElementById('seqTotal').style.color = 'var(--red)';
  })();

  // Parallel
  const parStart = performance.now();
  (async () => {
    const promises = tasks.map(t => {
      const el = document.getElementById(t.parEl);
      el.style.transition = `width ${t.time}ms linear`;
      el.style.width = '100%';
      return delay(t.time + 50);
    });
    await Promise.all(promises);
    const total = ((performance.now() - parStart) / 1000).toFixed(1);
    document.getElementById('parTotal').textContent = `Total: ~${total}s`;
    document.getElementById('parTotal').style.color = 'var(--green)';
    raceRunning = false;
  })();
}

function resetRace() {
  ['seqA','seqB','seqC','parA','parB','parC'].forEach(id => {
    const el = document.getElementById(id);
    el.style.transition = 'none';
    el.style.width = '0%';
  });
  document.getElementById('seqTotal').textContent = 'Total: ‚Äî';
  document.getElementById('seqTotal').style.color = '';
  document.getElementById('parTotal').textContent = 'Total: ‚Äî';
  document.getElementById('parTotal').style.color = '';
  raceRunning = false;
}

// ======================== QUIZ ========================
const quizData = [
  {
    q: 'What does an async function always return?',
    code: null,
    opts: ['The value from the return statement', 'undefined', 'A Promise', 'A callback'],
    correct: 2,
    explain: 'An async function ALWAYS returns a Promise. If you return a value, it\'s wrapped in Promise.resolve(). If you throw, it returns a rejected Promise.'
  },
  {
    q: 'What does this code output?',
    code: `async function foo() {\n  return 42;\n}\nconsole.log(foo());`,
    opts: ['42', 'undefined', 'Promise {<fulfilled>: 42}', 'Error'],
    correct: 2,
    explain: 'foo() returns a Promise (because it\'s async), not the raw value 42. You need await or .then() to get 42.'
  },
  {
    q: 'What does this code output?',
    code: `async function test() {\n  console.log("A");\n  await Promise.resolve();\n  console.log("B");\n}\nconsole.log("C");\ntest();\nconsole.log("D");`,
    opts: ['C, A, B, D', 'C, A, D, B', 'A, B, C, D', 'C, D, A, B'],
    correct: 1,
    explain: '"C" prints first (sync). Then test() is called ‚Äî "A" prints (sync part of async). At await, test() suspends. "D" prints (back in caller). Then "B" prints (test() resumes after await).'
  },
  {
    q: 'Which is the correct way to catch errors from async functions?',
    code: null,
    opts: [
      'if (error) handleError(error)',
      'async function fn() { try { await op(); } catch(e) { } }',
      'async function fn() { await op() || handleError(); }',
      'async function fn() { await op().error(e => {}); }'
    ],
    correct: 1,
    explain: 'try/catch is the standard way to handle errors in async/await code. It works just like synchronous error handling.'
  },
  {
    q: 'What happens with await in a forEach callback?',
    code: `[1, 2, 3].forEach(async (n) => {\n  await delay(100);\n  console.log(n);\n});\nconsole.log("done");`,
    opts: [
      '1, 2, 3, done (sequential)',
      'done, 1, 2, 3 (forEach doesn\'t wait)',
      'Error: await not allowed in forEach',
      '1, 2, 3, done (parallel)'
    ],
    correct: 1,
    explain: 'forEach does NOT await async callbacks! "done" prints first, then 1, 2, 3 all appear at roughly the same time. Use for...of or Promise.all with map instead.'
  },
  {
    q: 'Which runs tasks in parallel?',
    code: null,
    opts: [
      'const a = await fn1(); const b = await fn2();',
      'const [a, b] = await Promise.all([fn1(), fn2()]);',
      'await fn1(); await fn2();',
      'for (const fn of [fn1, fn2]) { await fn(); }'
    ],
    correct: 1,
    explain: 'Promise.all() starts all promises simultaneously and waits for all to resolve. The other options all run sequentially ‚Äî each await waits before starting the next.'
  },
  {
    q: 'What is the key difference between Promise.all and Promise.allSettled?',
    code: null,
    opts: [
      'Promise.all is faster',
      'Promise.allSettled doesn\'t need await',
      'Promise.all rejects on first failure; allSettled waits for all',
      'There is no difference'
    ],
    correct: 2,
    explain: 'Promise.all() "fails fast" ‚Äî it rejects immediately when ANY promise rejects. Promise.allSettled() waits for ALL promises to settle and returns an array of {status, value/reason} objects.'
  },
  {
    q: 'What does this code output?',
    code: `async function foo() {\n  throw new Error("oops");\n}\n\nfoo();\nconsole.log("after");`,
    opts: [
      '"after" then UnhandledPromiseRejection warning',
      'Error crashes the program immediately',
      '"after" never prints',
      'Error: "oops" is caught automatically'
    ],
    correct: 0,
    explain: 'The throw creates a rejected Promise, but since we don\'t await or .catch() foo(), "after" prints normally. Then the unhandled rejection warning appears. Always handle async errors!'
  },
  {
    q: 'When IS "return await" necessary inside an async function?',
    code: null,
    opts: [
      'Always ‚Äî it\'s required syntax',
      'Never ‚Äî it\'s always redundant',
      'Inside a try/catch block to catch the rejection',
      'When returning a primitive value'
    ],
    correct: 2,
    explain: 'Normally "return await" is redundant. BUT inside try/catch, you NEED "return await" so the catch block can handle rejections. Without await, the promise passes through uncaught.'
  },
  {
    q: 'What does Promise.race() return?',
    code: null,
    opts: [
      'An array of all results',
      'The result of the first promise to settle (resolve OR reject)',
      'The result of the fastest resolving promise',
      'The result of the slowest promise'
    ],
    correct: 1,
    explain: 'Promise.race() returns the result of the FIRST promise to settle ‚Äî whether it resolves or rejects. Promise.any() is the one that waits for the first to resolve specifically.'
  },
];

let quizAnswers = {};

function renderQuiz() {
  const container = document.getElementById('quizContainer');
  container.innerHTML = '';
  quizData.forEach((q, i) => {
    const div = document.createElement('div');
    div.className = 'quiz-question';
    div.id = 'qq-' + i;
    let codeHtml = q.code ? `<pre>${escHtml(q.code)}</pre>` : '';
    div.innerHTML = `
      <h4>Question ${i + 1} of ${quizData.length}</h4>
      <p>${q.q}</p>
      ${codeHtml}
      <div class="quiz-options">
        ${q.opts.map((o, j) => `<div class="quiz-opt" data-q="${i}" data-o="${j}" onclick="selectQuizOpt(this)">${escHtml(o)}</div>`).join('')}
      </div>
      <div class="quiz-explanation" id="qexp-${i}">${q.explain}</div>
    `;
    container.appendChild(div);
  });
  document.getElementById('submitQuiz').style.display = 'inline-block';
  document.getElementById('quizScore').style.display = 'none';
}

function escHtml(s) { return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

function selectQuizOpt(el) {
  const q = parseInt(el.dataset.q);
  const parent = el.parentElement;
  parent.querySelectorAll('.quiz-opt').forEach(o => o.classList.remove('selected'));
  el.classList.add('selected');
  quizAnswers[q] = parseInt(el.dataset.o);
}

function submitQuiz() {
  let score = 0;
  quizData.forEach((q, i) => {
    const opts = document.querySelectorAll(`[data-q="${i}"]`);
    opts.forEach(o => {
      o.classList.add('disabled');
      const j = parseInt(o.dataset.o);
      if (j === q.correct) o.classList.add('correct');
      if (quizAnswers[i] === j && j !== q.correct) o.classList.add('wrong');
    });
    const exp = document.getElementById('qexp-' + i);
    exp.classList.add('show');
    if (quizAnswers[i] === q.correct) {
      score++;
      exp.classList.add('right');
    } else {
      exp.classList.add('wrong-exp');
    }
  });

  const scoreEl = document.getElementById('quizScore');
  scoreEl.style.display = 'block';
  document.getElementById('scoreNum').textContent = score + ' / ' + quizData.length;
  const pct = Math.round(score / quizData.length * 100);
  document.getElementById('scoreNum').style.color = pct >= 70 ? 'var(--green)' : pct >= 50 ? 'var(--yellow)' : 'var(--red)';
  document.getElementById('scoreMsg').textContent =
    pct === 100 ? 'üèÜ Perfect! You\'re interview-ready!' :
    pct >= 80 ? 'üéâ Great job! Almost there!' :
    pct >= 60 ? 'üìö Good effort! Review the sections you missed.' :
    'üí™ Keep studying! Re-read the sections and try again.';
  document.getElementById('submitQuiz').style.display = 'none';
  if (pct >= 70) { completed.add('quiz'); saveProgress(); }
}

function resetQuiz() {
  quizAnswers = {};
  renderQuiz();
}
renderQuiz();

// ======================== EXERCISES ========================
const exercises = [
  {
    title: 'Convert Promise Chain to Async/Await',
    diff: 'easy',
    desc: 'Rewrite this Promise chain using async/await. The function should return the final result.',
    starter: `// Convert this Promise chain to async/await:
// fetchUser(1)
//   .then(user => fetchPosts(user.id))
//   .then(posts => posts.length)
//   .catch(err => console.error(err));

// Helper functions (already defined):
// fetchUser(id) ‚Üí Promise<{id, name}>
// fetchPosts(userId) ‚Üí Promise<[...]>

async function getUserPostCount(userId) {
  // Your code here

}`,
    validate: async (code) => {
      const fn = new Function('fetchUser', 'fetchPosts', `
        ${code}
        return getUserPostCount(1);
      `);
      const fetchUser = async (id) => ({ id, name: 'Alice' });
      const fetchPosts = async (uid) => ['p1', 'p2', 'p3'];
      const result = await fn(fetchUser, fetchPosts);
      return result === 3;
    },
    hint: 'Use await on fetchUser(), then use the result to call fetchPosts(). Return the .length of the posts array. Wrap in try/catch for the error handling.'
  },
  {
    title: 'Add Error Handling',
    diff: 'easy',
    desc: 'Add proper try/catch/finally error handling. On error, return the object { error: true, message: error.message }. In finally, log "cleanup done".',
    starter: `async function safeFetch(url) {
  // Add try/catch/finally to this code:
  const response = await fetch(url);
  const data = await response.json();
  return data;
}`,
    validate: async (code) => {
      const fn = new Function('fetch', `
        ${code}
        return safeFetch("bad-url");
      `);
      const mockFetch = async () => { throw new Error('Network error'); };
      const logs = [];
      const _log = console.log;
      console.log = (...a) => logs.push(a.join(' '));
      const result = await fn(mockFetch);
      console.log = _log;
      return result && result.error === true && result.message === 'Network error' && logs.some(l => l.includes('cleanup'));
    },
    hint: 'Wrap the existing code in try { ... } catch (error) { return { error: true, message: error.message }; } finally { console.log("cleanup done"); }'
  },
  {
    title: 'Parallel Data Loading',
    diff: 'medium',
    desc: 'Load user, posts, and settings IN PARALLEL using Promise.all. Return an object { user, posts, settings }. Functions: getUser(), getPosts(), getSettings() ‚Äî all return Promises.',
    starter: `async function loadDashboard() {
  // Load all three in PARALLEL, not sequentially!
  // Return { user, posts, settings }

}`,
    validate: async (code) => {
      let callOrder = [];
      const getUser = async () => { callOrder.push('u-start'); await delay(50); callOrder.push('u-end'); return { name: 'A' }; };
      const getPosts = async () => { callOrder.push('p-start'); await delay(50); callOrder.push('p-end'); return [1,2]; };
      const getSettings = async () => { callOrder.push('s-start'); await delay(50); callOrder.push('s-end'); return { theme: 'dark' }; };
      const fn = new Function('getUser', 'getPosts', 'getSettings', 'Promise', 'delay', `
        ${code}
        return loadDashboard();
      `);
      const result = await fn(getUser, getPosts, getSettings, Promise, delay);
      // Check all started before any ended (parallel)
      const starts = callOrder.filter(c => c.endsWith('-start'));
      const firstEnd = callOrder.findIndex(c => c.endsWith('-end'));
      const isParallel = starts.length >= 2 && callOrder.indexOf(starts[1]) < firstEnd;
      return result && result.user && result.posts && result.settings && isParallel;
    },
    hint: 'Use destructuring with Promise.all: const [user, posts, settings] = await Promise.all([getUser(), getPosts(), getSettings()]); Then return { user, posts, settings }.'
  },
  {
    title: 'Implement a Retry Function',
    diff: 'hard',
    desc: 'Create an async function "withRetry(fn, maxAttempts)" that retries fn() up to maxAttempts times. If all attempts fail, throw the last error. Add a 100ms delay between retries.',
    starter: `async function withRetry(fn, maxAttempts) {
  // Implement retry logic:
  // 1. Try calling fn()
  // 2. If it throws, retry up to maxAttempts times
  // 3. Wait 100ms between retries
  // 4. If all attempts fail, throw the last error

}`,
    validate: async (code) => {
      let calls = 0;
      const failTwice = async () => { calls++; if (calls < 3) throw new Error('fail'); return 'success'; };
      const fn = new Function('delay', `
        ${code}
        return { withRetry };
      `);
      const { withRetry: wr } = fn(delay);
      calls = 0;
      const r1 = await wr(failTwice, 5);
      const ok1 = r1 === 'success' && calls === 3;
      calls = 0;
      let threw = false;
      const alwaysFail = async () => { calls++; throw new Error('nope'); };
      try { await wr(alwaysFail, 2); } catch { threw = true; }
      return ok1 && threw && calls === 2;
    },
    hint: 'Use a for loop from 0 to maxAttempts. Inside, use try/catch. In try, return await fn(). In catch, if it\'s the last attempt (i === maxAttempts - 1), re-throw the error. Otherwise, await delay(100).'
  },
  {
    title: 'Process Array with Concurrency Limit',
    diff: 'hard',
    desc: 'Implement "processWithLimit(items, fn, limit)" that processes items using fn() but with at most "limit" concurrent operations. Return all results in order.',
    starter: `async function processWithLimit(items, fn, limit) {
  // Process items with fn() but max 'limit' concurrent
  // Return results array in same order as items

}`,
    validate: async (code) => {
      let concurrent = 0;
      let maxConcurrent = 0;
      const fn = async (item) => {
        concurrent++;
        if (concurrent > maxConcurrent) maxConcurrent = concurrent;
        await delay(50);
        concurrent--;
        return item * 2;
      };
      const wrapper = new Function('delay', 'Promise', `
        ${code}
        return { processWithLimit };
      `);
      const { processWithLimit: pwl } = wrapper(delay, Promise);
      const result = await pwl([1, 2, 3, 4, 5, 6], fn, 2);
      return JSON.stringify(result) === '[2,4,6,8,10,12]' && maxConcurrent <= 2;
    },
    hint: 'Use a "pool" approach: create a results array. Use an index counter. Create a worker function that grabs the next item, processes it, and stores the result. Start "limit" workers with Promise.all. Each worker loops until all items are processed.'
  }
];

function renderExercises() {
  const container = document.getElementById('exerciseContainer');
  container.innerHTML = '';
  exercises.forEach((ex, i) => {
    const div = document.createElement('div');
    div.className = 'exercise';
    div.id = 'ex-' + i;
    div.innerHTML = `
      <div class="exercise-header">
        <h4>Exercise ${i + 1}: ${ex.title} <span class="exercise-diff ${ex.diff}">${ex.diff.toUpperCase()}</span></h4>
      </div>
      <div class="exercise-desc">${ex.desc}</div>
      <textarea id="excode-${i}" spellcheck="false">${ex.starter}</textarea>
      <div class="exercise-actions">
        <button class="check-btn" onclick="checkExercise(${i})">‚ñ∂ Run & Check</button>
        <button class="hint-btn" onclick="toggleHint(${i})">üí° Hint</button>
      </div>
      <div class="hint-box" id="exhint-${i}">üí° ${ex.hint}</div>
      <div class="exercise-result" id="exresult-${i}"></div>
      <div class="console-output" id="exout-${i}"></div>
    `;
    container.appendChild(div);
  });
}

function toggleHint(i) {
  const h = document.getElementById('exhint-' + i);
  h.style.display = h.style.display === 'block' ? 'none' : 'block';
}

async function checkExercise(i) {
  const code = document.getElementById('excode-' + i).value;
  const resultEl = document.getElementById('exresult-' + i);
  const outputEl = document.getElementById('exout-' + i);
  outputEl.innerHTML = '';
  resultEl.style.display = 'block';

  const _log = console.log;
  console.log = (...args) => {
    const d = document.createElement('div');
    d.className = 'log-line';
    d.textContent = args.map(a => typeof a === 'object' ? JSON.stringify(a) : String(a)).join(' ');
    outputEl.appendChild(d);
  };

  try {
    const passed = await exercises[i].validate(code);
    if (passed) {
      resultEl.className = 'exercise-result pass';
      resultEl.textContent = '‚úÖ All tests passed! Great job!';
      completed.add('ex-' + i);
      if (exercises.every((_, j) => completed.has('ex-' + j))) {
        completed.add('exercises');
        saveProgress();
      }
    } else {
      resultEl.className = 'exercise-result fail';
      resultEl.textContent = '‚ùå Tests failed. Check your logic and try again.';
    }
  } catch (e) {
    resultEl.className = 'exercise-result fail';
    resultEl.textContent = '‚ùå Error: ' + e.message;
  }
  console.log = _log;
}

renderExercises();

// ======================== INIT ========================
updateProgress();
</script>
</body>
</html>