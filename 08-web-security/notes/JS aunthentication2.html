can you provide the missing or remaining code until the </html> tag: <!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>üîê Auth Mastery - JavaScript Authentication & Authorization</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
:root{
  --bg:#0a0a1a;--surface:#12122a;--card:#1a1a3e;--card2:#222250;
  --accent:#00d4ff;--accent2:#7c3aed;--success:#10b981;--error:#ef4444;
  --warn:#f59e0b;--text:#e2e8f0;--text2:#94a3b8;--border:#2a2a5a;
  --gradient:linear-gradient(135deg,#00d4ff,#7c3aed);
}
body{font-family:'Segoe UI',system-ui,sans-serif;background:var(--bg);color:var(--text);line-height:1.7;overflow-x:hidden}
::-webkit-scrollbar{width:8px}
::-webkit-scrollbar-track{background:var(--surface)}
::-webkit-scrollbar-thumb{background:var(--accent2);border-radius:4px}

/* HEADER */
.header{position:fixed;top:0;left:0;right:0;height:60px;background:var(--surface);border-bottom:1px solid var(--border);display:flex;align-items:center;justify-content:space-between;padding:0 24px;z-index:100;backdrop-filter:blur(20px)}
.logo{font-size:1.3rem;font-weight:800;background:var(--gradient);-webkit-background-clip:text;-webkit-text-fill-color:transparent;display:flex;align-items:center;gap:8px}
.logo span{font-size:1.5rem;-webkit-text-fill-color:initial}
.xp-bar-wrap{display:flex;align-items:center;gap:12px}
.xp-label{font-size:.85rem;color:var(--accent);font-weight:700}
.xp-bar{width:200px;height:8px;background:var(--card);border-radius:4px;overflow:hidden}
.xp-fill{height:100%;background:var(--gradient);border-radius:4px;transition:width .5s ease}
.level-badge{background:var(--accent2);color:#fff;padding:2px 10px;border-radius:12px;font-size:.75rem;font-weight:700}
.streak{display:flex;align-items:center;gap:4px;color:var(--warn);font-weight:700;font-size:.9rem}

/* SIDEBAR */
.sidebar{position:fixed;top:60px;left:0;width:280px;height:calc(100vh - 60px);background:var(--surface);border-right:1px solid var(--border);overflow-y:auto;padding:16px 0;z-index:90;transition:transform .3s}
.sidebar-section{padding:8px 16px;font-size:.7rem;text-transform:uppercase;letter-spacing:2px;color:var(--text2);margin-top:8px}
.nav-item{display:flex;align-items:center;gap:12px;padding:10px 20px;cursor:pointer;transition:all .2s;border-left:3px solid transparent;font-size:.9rem}
.nav-item:hover{background:rgba(0,212,255,.05);color:var(--accent)}
.nav-item.active{background:rgba(0,212,255,.1);border-left-color:var(--accent);color:var(--accent)}
.nav-item.completed .nav-check{color:var(--success)}
.nav-icon{font-size:1.1rem;width:24px;text-align:center}
.nav-check{margin-left:auto;font-size:.8rem;color:var(--border)}
.nav-item.locked{opacity:.4;pointer-events:none}

/* MAIN CONTENT */
.main{margin-left:280px;margin-top:60px;padding:32px;min-height:calc(100vh - 60px)}
.module-header{text-align:center;padding:40px 0;margin-bottom:32px}
.module-header h1{font-size:2.5rem;font-weight:800;margin-bottom:8px;background:var(--gradient);-webkit-background-clip:text;-webkit-text-fill-color:transparent}
.module-header p{color:var(--text2);font-size:1.1rem;max-width:600px;margin:0 auto}

/* CARDS */
.card{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:28px;margin-bottom:24px;transition:transform .2s,box-shadow .2s}
.card:hover{transform:translateY(-2px);box-shadow:0 8px 30px rgba(0,0,0,.3)}
.card h2{font-size:1.4rem;margin-bottom:16px;display:flex;align-items:center;gap:10px}
.card h3{font-size:1.1rem;margin:20px 0 10px;color:var(--accent)}
.card p{color:var(--text2);margin-bottom:12px}
.card ul,.card ol{color:var(--text2);padding-left:24px;margin-bottom:12px}
.card li{margin-bottom:6px}

/* CODE BLOCKS */
.code-block{background:#0d0d22;border:1px solid var(--border);border-radius:10px;padding:20px;margin:16px 0;overflow-x:auto;position:relative;font-size:.88rem}
.code-block pre{font-family:'Fira Code',Consolas,monospace;white-space:pre;line-height:1.6}
.code-block .copy-btn{position:absolute;top:8px;right:8px;background:var(--card2);border:1px solid var(--border);color:var(--text2);padding:4px 12px;border-radius:6px;cursor:pointer;font-size:.75rem;transition:all .2s}
.code-block .copy-btn:hover{background:var(--accent);color:var(--bg)}
.code-label{position:absolute;top:8px;left:12px;font-size:.7rem;color:var(--accent);text-transform:uppercase;letter-spacing:1px;font-weight:700}
.code-block.has-label pre{margin-top:12px}

/* SYNTAX COLORS */
.kw{color:#c792ea}.str{color:#c3e88d}.num{color:#f78c6c}.cm{color:#546e7a;font-style:italic}
.fn{color:#82aaff}.op{color:#89ddff}.prop{color:#f07178}.type{color:#ffcb6b}.const{color:#ff5370}

/* INTERACTIVE DEMOS */
.demo-area{background:var(--surface);border:2px solid var(--accent2);border-radius:12px;padding:24px;margin:20px 0}
.demo-area h3{color:var(--accent);margin-bottom:16px;display:flex;align-items:center;gap:8px}
.demo-input{width:100%;background:var(--bg);border:1px solid var(--border);color:var(--text);padding:10px 14px;border-radius:8px;font-family:inherit;font-size:.9rem;margin-bottom:10px;transition:border .2s}
.demo-input:focus{outline:none;border-color:var(--accent)}
textarea.demo-input{min-height:80px;resize:vertical;font-family:'Fira Code',Consolas,monospace}
.demo-output{background:var(--bg);border:1px solid var(--border);border-radius:8px;padding:16px;margin-top:12px;font-family:'Fira Code',Consolas,monospace;font-size:.85rem;word-break:break-all;line-height:1.8}
.demo-row{display:grid;grid-template-columns:1fr 1fr;gap:16px;margin-bottom:12px}
.demo-label{font-size:.8rem;color:var(--accent);text-transform:uppercase;letter-spacing:1px;margin-bottom:6px;font-weight:700}
.jwt-part{padding:4px 0;border-radius:4px}
.jwt-header{color:#ff6b6b}
.jwt-payload{color:#7c3aed}
.jwt-signature{color:#00d4ff}

/* BUTTONS */
.btn{padding:10px 24px;border:none;border-radius:8px;cursor:pointer;font-weight:700;font-size:.9rem;transition:all .2s;display:inline-flex;align-items:center;gap:8px}
.btn-primary{background:var(--gradient);color:#fff}
.btn-primary:hover{transform:translateY(-1px);box-shadow:0 4px 15px rgba(0,212,255,.3)}
.btn-secondary{background:var(--card2);color:var(--text);border:1px solid var(--border)}
.btn-secondary:hover{border-color:var(--accent)}
.btn-success{background:var(--success);color:#fff}
.btn-danger{background:var(--error);color:#fff}
.btn-sm{padding:6px 14px;font-size:.8rem}
.btn-group{display:flex;gap:8px;flex-wrap:wrap;margin:12px 0}

/* PITFALL BOX */
.pitfall{background:rgba(239,68,68,.08);border:1px solid rgba(239,68,68,.3);border-left:4px solid var(--error);border-radius:8px;padding:16px 20px;margin:16px 0}
.pitfall h4{color:var(--error);margin-bottom:8px;display:flex;align-items:center;gap:8px}
.pitfall p,.pitfall li{color:var(--text2);font-size:.9rem}
.tip{background:rgba(16,185,129,.08);border:1px solid rgba(16,185,129,.3);border-left:4px solid var(--success);border-radius:8px;padding:16px 20px;margin:16px 0}
.tip h4{color:var(--success);margin-bottom:8px;display:flex;align-items:center;gap:8px}
.tip p,.tip li{color:var(--text2);font-size:.9rem}
.warn{background:rgba(245,158,11,.08);border:1px solid rgba(245,158,11,.3);border-left:4px solid var(--warn);border-radius:8px;padding:16px 20px;margin:16px 0}
.warn h4{color:var(--warn);margin-bottom:8px;display:flex;align-items:center;gap:8px}
.warn p{color:var(--text2);font-size:.9rem}

/* QUIZ */
.quiz-container{margin:20px 0}
.quiz-q{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:24px;margin-bottom:16px}
.quiz-q h4{margin-bottom:16px;font-size:1rem}
.quiz-q .q-num{color:var(--accent);font-weight:800;margin-right:8px}
.quiz-option{display:block;padding:12px 16px;margin:6px 0;background:var(--surface);border:2px solid var(--border);border-radius:8px;cursor:pointer;transition:all .2s;font-size:.9rem}
.quiz-option:hover{border-color:var(--accent);background:rgba(0,212,255,.05)}
.quiz-option.selected{border-color:var(--accent2);background:rgba(124,58,237,.1)}
.quiz-option.correct{border-color:var(--success);background:rgba(16,185,129,.1)}
.quiz-option.wrong{border-color:var(--error);background:rgba(239,68,68,.1)}
.quiz-option input{display:none}
.quiz-explain{margin-top:12px;padding:12px;background:rgba(0,212,255,.05);border-radius:8px;font-size:.85rem;color:var(--text2);display:none}
.quiz-explain.show{display:block}
.quiz-score{text-align:center;padding:30px;background:var(--card);border-radius:16px;margin:20px 0}
.quiz-score .score-num{font-size:3rem;font-weight:800;background:var(--gradient);-webkit-background-clip:text;-webkit-text-fill-color:transparent}
.quiz-score p{color:var(--text2);margin-top:8px}

/* EXERCISE */
.exercise{background:var(--card);border:2px solid var(--accent2);border-radius:12px;padding:24px;margin:20px 0}
.exercise h3{color:var(--accent2);margin-bottom:12px;display:flex;align-items:center;gap:8px}
.exercise-editor{background:var(--bg);border:1px solid var(--border);border-radius:8px;padding:16px;margin:12px 0}
.exercise-editor textarea{width:100%;background:transparent;border:none;color:var(--text);font-family:'Fira Code',Consolas,monospace;font-size:.88rem;resize:vertical;min-height:120px;outline:none;line-height:1.6}
.exercise-result{padding:12px;border-radius:8px;margin-top:12px;font-size:.9rem;display:none}
.exercise-result.pass{display:block;background:rgba(16,185,129,.1);border:1px solid var(--success);color:var(--success)}
.exercise-result.fail{display:block;background:rgba(239,68,68,.1);border:1px solid var(--error);color:var(--error)}

/* FLOW DIAGRAM */
.flow-diagram{display:flex;flex-direction:column;gap:12px;padding:20px;background:var(--bg);border-radius:12px;margin:16px 0}
.flow-step{display:flex;align-items:center;gap:16px;padding:14px 18px;background:var(--card);border-radius:10px;border-left:4px solid var(--border);opacity:.3;transform:translateX(-20px);transition:all .4s ease}
.flow-step.active{opacity:1;transform:translateX(0);border-left-color:var(--accent)}
.flow-step.done{opacity:.7;transform:translateX(0);border-left-color:var(--success)}
.flow-step-num{width:32px;height:32px;border-radius:50%;background:var(--card2);display:flex;align-items:center;justify-content:center;font-weight:800;font-size:.85rem;flex-shrink:0}
.flow-step.active .flow-step-num{background:var(--accent);color:var(--bg)}
.flow-step.done .flow-step-num{background:var(--success);color:#fff}
.flow-step-content h4{font-size:.9rem;margin-bottom:2px}
.flow-step-content p{font-size:.8rem;color:var(--text2)}
.flow-actors{display:flex;justify-content:space-around;margin-bottom:16px;padding:12px;background:var(--card);border-radius:10px}
.flow-actor{text-align:center;font-size:.8rem;font-weight:700}
.flow-actor .actor-icon{font-size:2rem;margin-bottom:4px}

/* TABS */
.tabs{display:flex;gap:4px;margin-bottom:20px;flex-wrap:wrap}
.tab{padding:8px 18px;background:var(--card);border:1px solid var(--border);border-radius:8px 8px 0 0;cursor:pointer;font-size:.85rem;transition:all .2s;color:var(--text2)}
.tab:hover{color:var(--text)}
.tab.active{background:var(--accent2);border-color:var(--accent2);color:#fff}
.tab-content{display:none}
.tab-content.active{display:block}

/* COMPARISON TABLE */
.compare-table{width:100%;border-collapse:collapse;margin:16px 0;font-size:.88rem}
.compare-table th{background:var(--card2);padding:12px 16px;text-align:left;font-size:.8rem;text-transform:uppercase;letter-spacing:1px;color:var(--accent)}
.compare-table td{padding:12px 16px;border-bottom:1px solid var(--border);color:var(--text2)}
.compare-table tr:hover td{background:rgba(0,212,255,.03)}

/* VISUAL HASH */
.hash-grid{display:grid;grid-template-columns:repeat(16,1fr);gap:2px;margin:12px 0}
.hash-cell{aspect-ratio:1;border-radius:3px;transition:background .3s}

/* PROGRESS CARDS */
.progress-grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:16px;margin:20px 0}
.progress-card{background:var(--card);border:1px solid var(--border);border-radius:12px;padding:20px;text-align:center;cursor:pointer;transition:all .2s}
.progress-card:hover{border-color:var(--accent);transform:translateY(-3px)}
.progress-card .pc-icon{font-size:2.5rem;margin-bottom:10px}
.progress-card h3{font-size:1rem;margin-bottom:6px}
.progress-card .pc-prog{color:var(--text2);font-size:.8rem}
.pc-bar{height:4px;background:var(--border);border-radius:2px;margin-top:10px;overflow:hidden}
.pc-bar-fill{height:100%;background:var(--gradient);border-radius:2px;transition:width .5s}

/* BADGE */
.badge{display:inline-flex;align-items:center;gap:4px;padding:2px 10px;border-radius:20px;font-size:.75rem;font-weight:700}
.badge-new{background:rgba(0,212,255,.15);color:var(--accent)}
.badge-important{background:rgba(239,68,68,.15);color:var(--error)}

/* MOBILE */
.menu-toggle{display:none;background:none;border:none;color:var(--text);font-size:1.5rem;cursor:pointer}
@media(max-width:768px){
  .sidebar{transform:translateX(-100%)}
  .sidebar.open{transform:translateX(0)}
  .main{margin-left:0}
  .menu-toggle{display:block}
  .demo-row{grid-template-columns:1fr}
  .module-header h1{font-size:1.8rem}
}

/* ANIMATIONS */
@keyframes fadeIn{from{opacity:0;transform:translateY(20px)}to{opacity:1;transform:translateY(0)}}
@keyframes pulse{0%,100%{transform:scale(1)}50%{transform:scale(1.05)}}
@keyframes slideRight{from{transform:translateX(-30px);opacity:0}to{transform:translateX(0);opacity:1}}
.animate-in{animation:fadeIn .4s ease forwards}
.pulse{animation:pulse .5s ease}
.slide-right{animation:slideRight .3s ease forwards}

/* NOTIFICATION */
.notif{position:fixed;top:80px;right:24px;background:var(--card);border:1px solid var(--success);border-radius:12px;padding:16px 24px;z-index:200;display:flex;align-items:center;gap:10px;transform:translateX(400px);transition:transform .4s ease;box-shadow:0 8px 30px rgba(0,0,0,.4)}
.notif.show{transform:translateX(0)}
.notif-icon{font-size:1.5rem}
.notif-text{font-size:.9rem}
.notif-xp{color:var(--accent);font-weight:800}

/* TOKEN VISUAL */
.token-visual{display:flex;gap:4px;margin:16px 0;flex-wrap:wrap;font-family:'Fira Code',Consolas,monospace;font-size:.8rem;word-break:break-all}
.token-visual .tv-header{background:rgba(255,107,107,.15);color:#ff6b6b;padding:8px 12px;border-radius:8px 0 0 8px}
.token-visual .tv-dot{color:var(--text2);padding:8px 2px;font-weight:800;font-size:1.2rem;align-self:center}
.token-visual .tv-payload{background:rgba(124,58,237,.15);color:#a78bfa;padding:8px 12px}
.token-visual .tv-sig{background:rgba(0,212,255,.15);color:var(--accent);padding:8px 12px;border-radius:0 8px 8px 0}

/* SESSION COOKIE VISUAL */
.cookie-jar{display:grid;grid-template-columns:repeat(auto-fill,minmax(180px,1fr));gap:12px;margin:12px 0}
.cookie-item{background:var(--surface);border:1px solid var(--border);border-radius:10px;padding:14px;font-size:.82rem}
.cookie-item .ci-name{color:var(--accent);font-weight:700;margin-bottom:4px}
.cookie-item .ci-val{color:var(--text2);word-break:break-all;font-family:monospace}
.cookie-item .ci-flags{display:flex;gap:4px;flex-wrap:wrap;margin-top:8px}
.cookie-flag{padding:2px 6px;border-radius:4px;font-size:.65rem;font-weight:700}
.cf-secure{background:rgba(16,185,129,.2);color:var(--success)}
.cf-httponly{background:rgba(0,212,255,.2);color:var(--accent)}
.cf-samesite{background:rgba(124,58,237,.2);color:#a78bfa}

/* Inline highlights */
code{background:var(--card2);padding:2px 7px;border-radius:4px;font-family:'Fira Code',Consolas,monospace;font-size:.85em;color:var(--accent)}
strong{color:var(--text)}
.highlight{color:var(--accent);font-weight:700}
.separator{height:1px;background:var(--border);margin:24px 0}

/* CHECKLIST */
.checklist{list-style:none;padding:0}
.checklist li{padding:8px 12px;display:flex;align-items:center;gap:10px;cursor:pointer;border-radius:6px;transition:background .2s;font-size:.9rem}
.checklist li:hover{background:rgba(0,212,255,.05)}
.checklist li .check-box{width:20px;height:20px;border:2px solid var(--border);border-radius:4px;display:flex;align-items:center;justify-content:center;transition:all .2s;flex-shrink:0}
.checklist li.checked .check-box{background:var(--success);border-color:var(--success)}

/* Attack demo */
.attack-demo{background:#1a0a0a;border:2px solid var(--error);border-radius:12px;padding:20px;margin:16px 0}
.attack-demo h4{color:var(--error);margin-bottom:12px}
.attack-input{width:100%;background:var(--bg);border:1px solid rgba(239,68,68,.3);color:var(--text);padding:10px;border-radius:6px;font-family:monospace;font-size:.85rem;margin-bottom:8px}
.attack-output{background:var(--bg);border:1px solid var(--border);padding:12px;border-radius:6px;min-height:40px;font-size:.85rem;color:var(--text2)}
</style>
</head>
<body>

<header class="header">
  <div style="display:flex;align-items:center;gap:16px">
    <button class="menu-toggle" onclick="toggleSidebar()">‚ò∞</button>
    <div class="logo"><span>üîê</span> Auth Mastery</div>
  </div>
  <div class="xp-bar-wrap">
    <div class="streak" id="streak">üî• 0</div>
    <div class="xp-label" id="xpLabel">0 XP</div>
    <div class="xp-bar"><div class="xp-fill" id="xpFill" style="width:0%"></div></div>
    <div class="level-badge" id="levelBadge">Level 1</div>
  </div>
</header>

<nav class="sidebar" id="sidebar">
  <div class="sidebar-section">Dashboard</div>
  <div class="nav-item active" data-page="dashboard" onclick="navigate('dashboard')">
    <span class="nav-icon">üè†</span> Overview
    <span class="nav-check">‚Ä∫</span>
  </div>
  
  <div class="sidebar-section">Module 1 ‚Äî JWT</div>
  <div class="nav-item" data-page="jwt-basics" onclick="navigate('jwt-basics')">
    <span class="nav-icon">üìñ</span> JWT Fundamentals
    <span class="nav-check">‚óã</span>
  </div>
  <div class="nav-item" data-page="jwt-lab" onclick="navigate('jwt-lab')">
    <span class="nav-icon">üî¨</span> JWT Lab
    <span class="nav-check">‚óã</span>
  </div>
  <div class="nav-item" data-page="jwt-pitfalls" onclick="navigate('jwt-pitfalls')">
    <span class="nav-icon">‚ö†Ô∏è</span> JWT Pitfalls
    <span class="nav-check">‚óã</span>
  </div>
  <div class="nav-item" data-page="jwt-quiz" onclick="navigate('jwt-quiz')">
    <span class="nav-icon">‚ùì</span> JWT Quiz
    <span class="nav-check">‚óã</span>
  </div>

  <div class="sidebar-section">Module 2 ‚Äî OAuth 2.0</div>
  <div class="nav-item" data-page="oauth-basics" onclick="navigate('oauth-basics')">
    <span class="nav-icon">üìñ</span> OAuth Fundamentals
    <span class="nav-check">‚óã</span>
  </div>
  <div class="nav-item" data-page="oauth-flows" onclick="navigate('oauth-flows')">
    <span class="nav-icon">üîÑ</span> OAuth Flows Simulator
    <span class="nav-check">‚óã</span>
  </div>
  <div class="nav-item" data-page="oauth-quiz" onclick="navigate('oauth-quiz')">
    <span class="nav-icon">‚ùì</span> OAuth Quiz
    <span class="nav-check">‚óã</span>
  </div>

  <div class="sidebar-section">Module 3 ‚Äî Password Security</div>
  <div class="nav-item" data-page="password-basics" onclick="navigate('password-basics')">
    <span class="nav-icon">üìñ</span> Hashing Fundamentals
    <span class="nav-check">‚óã</span>
  </div>
  <div class="nav-item" data-page="password-lab" onclick="navigate('password-lab')">
    <span class="nav-icon">üî¨</span> Hashing Lab
    <span class="nav-check">‚óã</span>
  </div>
  <div class="nav-item" data-page="password-quiz" onclick="navigate('password-quiz')">
    <span class="nav-icon">‚ùì</span> Password Quiz
    <span class="nav-check">‚óã</span>
  </div>

  <div class="sidebar-section">Module 4 ‚Äî Sessions</div>
  <div class="nav-item" data-page="session-basics" onclick="navigate('session-basics')">
    <span class="nav-icon">üìñ</span> Session Management
    <span class="nav-check">‚óã</span>
  </div>
  <div class="nav-item" data-page="session-lab" onclick="navigate('session-lab')">
    <span class="nav-icon">üî¨</span> Session Lab
    <span class="nav-check">‚óã</span>
  </div>
  <div class="nav-item" data-page="session-quiz" onclick="navigate('session-quiz')">
    <span class="nav-icon">‚ùì</span> Session Quiz
    <span class="nav-check">‚óã</span>
  </div>

  <div class="sidebar-section">Final</div>
  <div class="nav-item" data-page="final-challenge" onclick="navigate('final-challenge')">
    <span class="nav-icon">üèÜ</span> Final Challenge
    <span class="nav-check">‚óã</span>
  </div>
</nav>

<main class="main" id="mainContent"></main>

<div class="notif" id="notification">
  <span class="notif-icon">üéâ</span>
  <div>
    <div class="notif-text" id="notifText">Great job!</div>
    <div class="notif-xp" id="notifXp">+25 XP</div>
  </div>
</div>

<script>
// ============================================================
// APP STATE
// ============================================================
const state = {
  xp: 0,
  level: 1,
  streak: 0,
  currentPage: 'dashboard',
  completed: new Set(),
  quizAnswers: {},
  exercisesDone: new Set()
};

function saveState() {
  localStorage.setItem('authMastery', JSON.stringify({
    ...state,
    completed: [...state.completed],
    exercisesDone: [...state.exercisesDone]
  }));
}

function loadState() {
  const saved = localStorage.getItem('authMastery');
  if (saved) {
    const d = JSON.parse(saved);
    Object.assign(state, d);
    state.completed = new Set(d.completed || []);
    state.exercisesDone = new Set(d.exercisesDone || []);
  }
  updateXPBar();
  updateNav();
}

// ============================================================
// XP & PROGRESS
// ============================================================
function addXP(amount, msg) {
  state.xp += amount;
  const newLevel = Math.floor(state.xp / 100) + 1;
  if (newLevel > state.level) {
    state.level = newLevel;
    showNotification(`üéä Level ${state.level} reached!`, `+${amount} XP`);
  } else {
    showNotification(msg || 'Great work!', `+${amount} XP`);
  }
  updateXPBar();
  saveState();
}

function updateXPBar() {
  const pct = (state.xp % 100);
  document.getElementById('xpFill').style.width = pct + '%';
  document.getElementById('xpLabel').textContent = state.xp + ' XP';
  document.getElementById('levelBadge').textContent = 'Level ' + state.level;
  document.getElementById('streak').textContent = 'üî• ' + state.completed.size;
}

function showNotification(text, xp) {
  const el = document.getElementById('notification');
  document.getElementById('notifText').textContent = text;
  document.getElementById('notifXp').textContent = xp;
  el.classList.add('show');
  setTimeout(() => el.classList.remove('show'), 3000);
}

function markComplete(page) {
  if (!state.completed.has(page)) {
    state.completed.add(page);
    addXP(25, 'Section completed!');
    updateNav();
    saveState();
  }
}

function updateNav() {
  document.querySelectorAll('.nav-item[data-page]').forEach(el => {
    const page = el.dataset.page;
    const check = el.querySelector('.nav-check');
    if (state.completed.has(page)) {
      el.classList.add('completed');
      if (check) check.textContent = '‚úì';
    }
  });
}

// ============================================================
// NAVIGATION
// ============================================================
function navigate(page) {
  state.currentPage = page;
  document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
  const navItem = document.querySelector(`[data-page="${page}"]`);
  if (navItem) navItem.classList.add('active');
  
  const main = document.getElementById('mainContent');
  main.innerHTML = '';
  main.scrollTop = 0;
  window.scrollTo(0, 0);
  
  const renderer = pages[page];
  if (renderer) {
    main.innerHTML = renderer();
    main.querySelectorAll('.animate-in-delay').forEach((el, i) => {
      el.style.animationDelay = (i * 0.1) + 's';
    });
    if (pageInit[page]) pageInit[page]();
  }
  
  // Close mobile sidebar
  document.getElementById('sidebar').classList.remove('open');
}

function toggleSidebar() {
  document.getElementById('sidebar').classList.toggle('open');
}

// ============================================================
// UTILITY FUNCTIONS
// ============================================================
function b64urlEncode(str) {
  if (typeof str === 'string') {
    return btoa(unescape(encodeURIComponent(str)))
      .replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
  }
  // ArrayBuffer
  const bytes = new Uint8Array(str);
  let binary = '';
  bytes.forEach(b => binary += String.fromCharCode(b));
  return btoa(binary).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
}

function b64urlDecode(str) {
  str = str.replace(/-/g, '+').replace(/_/g, '/');
  while (str.length % 4) str += '=';
  return decodeURIComponent(escape(atob(str)));
}

function escapeHtml(str) {
  const d = document.createElement('div');
  d.textContent = str;
  return d.innerHTML;
}

function codeBlock(code, label) {
  const id = 'cb_' + Math.random().toString(36).substr(2, 9);
  return `<div class="code-block ${label ? 'has-label' : ''}">
    ${label ? `<span class="code-label">${label}</span>` : ''}
    <button class="copy-btn" onclick="copyCode('${id}')">Copy</button>
    <pre id="${id}">${code}</pre>
  </div>`;
}

function copyCode(id) {
  const text = document.getElementById(id).textContent;
  navigator.clipboard.writeText(text).then(() => {
    const btn = document.getElementById(id).parentElement.querySelector('.copy-btn');
    btn.textContent = 'Copied!';
    setTimeout(() => btn.textContent = 'Copy', 2000);
  });
}

async function hmacSHA256(message, secret) {
  const enc = new TextEncoder();
  const key = await crypto.subtle.importKey(
    'raw', enc.encode(secret),
    { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']
  );
  const sig = await crypto.subtle.sign('HMAC', enc.encode(message), key);
  return sig;
}

async function sha256(message) {
  const enc = new TextEncoder();
  const hash = await crypto.subtle.digest('SHA-256', enc.encode(message));
  return Array.from(new Uint8Array(hash)).map(b => b.toString(16).padStart(2, '0')).join('');
}

function simpleHash(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = ((hash << 5) - hash) + char;
    hash = hash & hash;
  }
  return Math.abs(hash).toString(16).padStart(8, '0');
}

// ============================================================
// PAGE RENDERERS
// ============================================================
const pages = {};
const pageInit = {};

// ============================================================
// DASHBOARD
// ============================================================
pages.dashboard = () => `
<div class="module-header animate-in">
  <h1>üîê Authentication & Authorization Mastery</h1>
  <p>Master JWT, OAuth, password security, and session management through interactive lessons, labs, and challenges.</p>
</div>

<div class="progress-grid">
  <div class="progress-card animate-in" onclick="navigate('jwt-basics')" style="animation-delay:.1s">
    <div class="pc-icon">üîë</div>
    <h3>JWT Deep Dive</h3>
    <div class="pc-prog">${['jwt-basics','jwt-lab','jwt-pitfalls','jwt-quiz'].filter(p => state.completed.has(p)).length}/4 complete</div>
    <div class="pc-bar"><div class="pc-bar-fill" style="width:${['jwt-basics','jwt-lab','jwt-pitfalls','jwt-quiz'].filter(p => state.completed.has(p)).length * 25}%"></div></div>
  </div>
  <div class="progress-card animate-in" onclick="navigate('oauth-basics')" style="animation-delay:.2s">
    <div class="pc-icon">üîÑ</div>
    <h3>OAuth 2.0</h3>
    <div class="pc-prog">${['oauth-basics','oauth-flows','oauth-quiz'].filter(p => state.completed.has(p)).length}/3 complete</div>
    <div class="pc-bar"><div class="pc-bar-fill" style="width:${['oauth-basics','oauth-flows','oauth-quiz'].filter(p => state.completed.has(p)).length * 33}%"></div></div>
  </div>
  <div class="progress-card animate-in" onclick="navigate('password-basics')" style="animation-delay:.3s">
    <div class="pc-icon">üõ°Ô∏è</div>
    <h3>Password Security</h3>
    <div class="pc-prog">${['password-basics','password-lab','password-quiz'].filter(p => state.completed.has(p)).length}/3 complete</div>
    <div class="pc-bar"><div class="pc-bar-fill" style="width:${['password-basics','password-lab','password-quiz'].filter(p => state.completed.has(p)).length * 33}%"></div></div>
  </div>
  <div class="progress-card animate-in" onclick="navigate('session-basics')" style="animation-delay:.4s">
    <div class="pc-icon">üç™</div>
    <h3>Session Management</h3>
    <div class="pc-prog">${['session-basics','session-lab','session-quiz'].filter(p => state.completed.has(p)).length}/3 complete</div>
    <div class="pc-bar"><div class="pc-bar-fill" style="width:${['session-basics','session-lab','session-quiz'].filter(p => state.completed.has(p)).length * 33}%"></div></div>
  </div>
</div>

<div class="card animate-in" style="animation-delay:.5s">
  <h2>üìã What You'll Master</h2>
  <ul class="checklist" id="masterChecklist">
    <li class="${state.completed.has('jwt-basics') ? 'checked' : ''}" onclick="this.classList.toggle('checked')"><span class="check-box">${state.completed.has('jwt-basics') ? '‚úì' : ''}</span> Understand JWT structure: Header, Payload, Signature</li>
    <li class="${state.completed.has('jwt-lab') ? 'checked' : ''}" onclick="this.classList.toggle('checked')"><span class="check-box">${state.completed.has('jwt-lab') ? '‚úì' : ''}</span> Create and verify JWTs with HMAC-SHA256</li>
    <li class="${state.completed.has('jwt-pitfalls') ? 'checked' : ''}" onclick="this.classList.toggle('checked')"><span class="check-box">${state.completed.has('jwt-pitfalls') ? '‚úì' : ''}</span> Avoid common JWT security mistakes</li>
    <li class="${state.completed.has('oauth-basics') ? 'checked' : ''}" onclick="this.classList.toggle('checked')"><span class="check-box">${state.completed.has('oauth-basics') ? '‚úì' : ''}</span> Understand OAuth 2.0 roles and grant types</li>
    <li class="${state.completed.has('oauth-flows') ? 'checked' : ''}" onclick="this.classList.toggle('checked')"><span class="check-box">${state.completed.has('oauth-flows') ? '‚úì' : ''}</span> Implement Authorization Code + PKCE flow</li>
    <li class="${state.completed.has('password-basics') ? 'checked' : ''}" onclick="this.classList.toggle('checked')"><span class="check-box">${state.completed.has('password-basics') ? '‚úì' : ''}</span> Hash passwords correctly with bcrypt/Argon2</li>
    <li class="${state.completed.has('session-basics') ? 'checked' : ''}" onclick="this.classList.toggle('checked')"><span class="check-box">${state.completed.has('session-basics') ? '‚úì' : ''}</span> Implement secure session management</li>
    <li class="${state.completed.has('final-challenge') ? 'checked' : ''}" onclick="this.classList.toggle('checked')"><span class="check-box">${state.completed.has('final-challenge') ? '‚úì' : ''}</span> Pass the final authentication challenge</li>
  </ul>
</div>

<div class="card animate-in" style="animation-delay:.6s">
  <h2>‚ö° Quick Stats</h2>
  <div style="display:grid;grid-template-columns:repeat(4,1fr);gap:16px;text-align:center">
    <div><div style="font-size:2rem;font-weight:800;color:var(--accent)">${state.xp}</div><div style="color:var(--text2);font-size:.85rem">Total XP</div></div>
    <div><div style="font-size:2rem;font-weight:800;color:var(--accent2)">${state.level}</div><div style="color:var(--text2);font-size:.85rem">Level</div></div>
    <div><div style="font-size:2rem;font-weight:800;color:var(--success)">${state.completed.size}</div><div style="color:var(--text2);font-size:.85rem">Completed</div></div>
    <div><div style="font-size:2rem;font-weight:800;color:var(--warn)">${14 - state.completed.size}</div><div style="color:var(--text2);font-size:.85rem">Remaining</div></div>
  </div>
</div>
`;

// ============================================================
// JWT BASICS
// ============================================================
pages['jwt-basics'] = () => `
<div class="module-header animate-in">
  <h1>üîë JWT Fundamentals</h1>
  <p>JSON Web Tokens ‚Äî the backbone of modern stateless authentication</p>
</div>

<div class="card animate-in">
  <h2>üìñ What is a JWT?</h2>
  <p>A <strong>JSON Web Token (JWT)</strong> is a compact, URL-safe token format used to securely transmit information between parties as a JSON object. The information is <strong>digitally signed</strong>, so it can be verified and trusted.</p>
  
  <div class="tip">
    <h4>üí° Key Insight</h4>
    <p>JWTs are <strong>signed, not encrypted</strong> by default. Anyone can read the payload ‚Äî the signature only guarantees the data hasn't been tampered with.</p>
  </div>

  <h3>When to Use JWT</h3>
  <ul>
    <li><strong>Authorization:</strong> After login, each request includes the JWT, allowing access to routes, services, and resources</li>
    <li><strong>Information Exchange:</strong> Securely transmitting data between parties with verified integrity</li>
    <li><strong>Stateless APIs:</strong> No server-side session storage needed</li>
    <li><strong>Microservices:</strong> Cross-service authentication without shared databases</li>
  </ul>
</div>

<div class="card animate-in">
  <h2>üèóÔ∏è JWT Structure ‚Äî The Three Parts</h2>
  <p>A JWT consists of three parts separated by dots (<code>.</code>):</p>
  
  <div class="token-visual">
    <span class="tv-header">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9</span>
    <span class="tv-dot">.</span>
    <span class="tv-payload">eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ</span>
    <span class="tv-dot">.</span>
    <span class="tv-sig">SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</span>
  </div>

  <h3>1. Header <span class="badge badge-new">RED</span></h3>
  <p>Contains the token type and signing algorithm:</p>
  ${codeBlock(`<span class="kw">{</span>
  <span class="prop">"alg"</span>: <span class="str">"HS256"</span>,    <span class="cm">// HMAC SHA-256</span>
  <span class="prop">"typ"</span>: <span class="str">"JWT"</span>       <span class="cm">// Token type</span>
<span class="kw">}</span>`, 'Header JSON')}

  <h3>2. Payload <span class="badge" style="background:rgba(124,58,237,.15);color:#a78bfa">PURPLE</span></h3>
  <p>Contains the claims ‚Äî statements about the user and additional metadata:</p>
  ${codeBlock(`<span class="kw">{</span>
  <span class="cm">// Registered claims (predefined, recommended)</span>
  <span class="prop">"sub"</span>: <span class="str">"1234567890"</span>,  <span class="cm">// Subject (user ID)</span>
  <span class="prop">"iss"</span>: <span class="str">"auth.myapp.com"</span>, <span class="cm">// Issuer</span>
  <span class="prop">"aud"</span>: <span class="str">"api.myapp.com"</span>,  <span class="cm">// Audience</span>
  <span class="prop">"exp"</span>: <span class="num">1516239022</span>,      <span class="cm">// Expiration time</span>
  <span class="prop">"iat"</span>: <span class="num">1516239022</span>,      <span class="cm">// Issued at</span>
  <span class="prop">"nbf"</span>: <span class="num">1516239022</span>,      <span class="cm">// Not before</span>
  <span class="prop">"jti"</span>: <span class="str">"unique-id"</span>,     <span class="cm">// JWT ID</span>
  
  <span class="cm">// Public/Private claims (custom data)</span>
  <span class="prop">"name"</span>: <span class="str">"John Doe"</span>,
  <span class="prop">"role"</span>: <span class="str">"admin"</span>
<span class="kw">}</span>`, 'Payload JSON')}

  <h3>3. Signature <span class="badge" style="background:rgba(0,212,255,.15);color:var(--accent)">BLUE</span></h3>
  <p>Created by signing the encoded header + payload with a secret key:</p>
  ${codeBlock(`HMACSHA256(
  base64urlEncode(header) + <span class="str">"."</span> + base64urlEncode(payload),
  <span class="str">secret</span>
)`, 'Signature Algorithm')}

  <div class="pitfall">
    <h4>üö´ Common Mistake</h4>
    <p>Never put sensitive data (passwords, SSNs, credit cards) in the JWT payload. It's only base64-encoded, NOT encrypted ‚Äî anyone can decode it!</p>
  </div>
</div>

<div class="card animate-in">
  <h2>üîÑ JWT Authentication Flow</h2>
  <div class="flow-diagram" id="jwtFlow">
    <div class="flow-step active">
      <div class="flow-step-num">1</div>
      <div class="flow-step-content">
        <h4>User sends credentials</h4>
        <p>POST /login with username & password</p>
      </div>
    </div>
    <div class="flow-step">
      <div class="flow-step-num">2</div>
      <div class="flow-step-content">
        <h4>Server validates credentials</h4>
        <p>Check against database, verify password hash</p>
      </div>
    </div>
    <div class="flow-step">
      <div class="flow-step-num">3</div>
      <div class="flow-step-content">
        <h4>Server creates JWT</h4>
        <p>Sign token with secret key, include user claims</p>
      </div>
    </div>
    <div class="flow-step">
      <div class="flow-step-num">4</div>
      <div class="flow-step-content">
        <h4>Server returns JWT to client</h4>
        <p>Token sent in response body or Set-Cookie header</p>
      </div>
    </div>
    <div class="flow-step">
      <div class="flow-step-num">5</div>
      <div class="flow-step-content">
        <h4>Client stores JWT</h4>
        <p>Saved in memory, localStorage, or httpOnly cookie</p>
      </div>
    </div>
    <div class="flow-step">
      <div class="flow-step-num">6</div>
      <div class="flow-step-content">
        <h4>Client sends JWT with requests</h4>
        <p>Authorization: Bearer &lt;token&gt;</p>
      </div>
    </div>
    <div class="flow-step">
      <div class="flow-step-num">7</div>
      <div class="flow-step-content">
        <h4>Server verifies JWT</h4>
        <p>Validate signature, check expiration, extract claims</p>
      </div>
    </div>
  </div>
  <div class="btn-group">
    <button class="btn btn-primary" onclick="animateFlow('jwtFlow')">‚ñ∂ Play Flow</button>
    <button class="btn btn-secondary" onclick="resetFlow('jwtFlow')">‚Ü∫ Reset</button>
  </div>
</div>

<div class="card animate-in">
  <h2>üíª Implementation Example</h2>
  <h3>Server-side: Creating a JWT (Node.js + jsonwebtoken)</h3>
  ${codeBlock(`<span class="kw">const</span> jwt = <span class="fn">require</span>(<span class="str">'jsonwebtoken'</span>);

<span class="kw">const</span> SECRET = process.env.JWT_SECRET; <span class="cm">// Never hardcode!</span>

<span class="cm">// Login endpoint</span>
app.<span class="fn">post</span>(<span class="str">'/login'</span>, <span class="kw">async</span> (req, res) => {
  <span class="kw">const</span> { email, password } = req.body;
  
  <span class="cm">// 1. Find user in database</span>
  <span class="kw">const</span> user = <span class="kw">await</span> User.<span class="fn">findOne</span>({ email });
  <span class="kw">if</span> (!user) <span class="kw">return</span> res.<span class="fn">status</span>(<span class="num">401</span>).<span class="fn">json</span>({ error: <span class="str">'Invalid credentials'</span> });
  
  <span class="cm">// 2. Verify password</span>
  <span class="kw">const</span> valid = <span class="kw">await</span> bcrypt.<span class="fn">compare</span>(password, user.passwordHash);
  <span class="kw">if</span> (!valid) <span class="kw">return</span> res.<span class="fn">status</span>(<span class="num">401</span>).<span class="fn">json</span>({ error: <span class="str">'Invalid credentials'</span> });
  
  <span class="cm">// 3. Create access token (short-lived)</span>
  <span class="kw">const</span> accessToken = jwt.<span class="fn">sign</span>(
    { sub: user.id, role: user.role },
    SECRET,
    { expiresIn: <span class="str">'15m'</span>, issuer: <span class="str">'myapp.com'</span> }
  );
  
  <span class="cm">// 4. Create refresh token (long-lived)</span>
  <span class="kw">const</span> refreshToken = jwt.<span class="fn">sign</span>(
    { sub: user.id, type: <span class="str">'refresh'</span> },
    REFRESH_SECRET,
    { expiresIn: <span class="str">'7d'</span> }
  );
  
  <span class="cm">// 5. Send tokens</span>
  res.<span class="fn">json</span>({ accessToken, refreshToken });
});`, 'Node.js ‚Äî Login & JWT Creation')}

  <h3>Server-side: Verifying a JWT (Middleware)</h3>
  ${codeBlock(`<span class="kw">function</span> <span class="fn">authenticateToken</span>(req, res, next) {
  <span class="kw">const</span> authHeader = req.headers[<span class="str">'authorization'</span>];
  <span class="kw">const</span> token = authHeader && authHeader.<span class="fn">split</span>(<span class="str">' '</span>)[<span class="num">1</span>]; <span class="cm">// "Bearer TOKEN"</span>
  
  <span class="kw">if</span> (!token) {
    <span class="kw">return</span> res.<span class="fn">status</span>(<span class="num">401</span>).<span class="fn">json</span>({ error: <span class="str">'Token required'</span> });
  }
  
  <span class="kw">try</span> {
    <span class="kw">const</span> decoded = jwt.<span class="fn">verify</span>(token, SECRET, {
      issuer: <span class="str">'myapp.com'</span>,
      algorithms: [<span class="str">'HS256'</span>] <span class="cm">// Explicitly specify!</span>
    });
    req.user = decoded;
    <span class="fn">next</span>();
  } <span class="kw">catch</span> (err) {
    <span class="kw">if</span> (err.name === <span class="str">'TokenExpiredError'</span>) {
      <span class="kw">return</span> res.<span class="fn">status</span>(<span class="num">401</span>).<span class="fn">json</span>({ error: <span class="str">'Token expired'</span> });
    }
    <span class="kw">return</span> res.<span class="fn">status</span>(<span class="num">403</span>).<span class="fn">json</span>({ error: <span class="str">'Invalid token'</span> });
  }
}`, 'Node.js ‚Äî JWT Middleware')}

  <h3>Client-side: Sending JWT with Requests</h3>
  ${codeBlock(`<span class="cm">// Store token after login</span>
<span class="kw">async function</span> <span class="fn">login</span>(email, password) {
  <span class="kw">const</span> res = <span class="kw">await</span> <span class="fn">fetch</span>(<span class="str">'/api/login'</span>, {
    method: <span class="str">'POST'</span>,
    headers: { <span class="str">'Content-Type'</span>: <span class="str">'application/json'</span> },
    body: <span class="fn">JSON.stringify</span>({ email, password })
  });
  <span class="kw">const</span> { accessToken, refreshToken } = <span class="kw">await</span> res.<span class="fn">json</span>();
  
  <span class="cm">// Option 1: Memory (safest for SPAs)</span>
  tokenStore.accessToken = accessToken;
  
  <span class="cm">// Option 2: HttpOnly cookie (set by server, safest overall)</span>
  <span class="cm">// Automatically included in requests</span>
}

<span class="cm">// Make authenticated requests</span>
<span class="kw">async function</span> <span class="fn">fetchProtectedData</span>() {
  <span class="kw">const</span> res = <span class="kw">await</span> <span class="fn">fetch</span>(<span class="str">'/api/protected'</span>, {
    headers: {
      <span class="str">'Authorization'</span>: <span class="str">\`Bearer \${tokenStore.accessToken}\`</span>
    }
  });
  <span class="kw">return</span> res.<span class="fn">json</span>();
}`, 'JavaScript ‚Äî Client-Side Usage')}
</div>

<div class="card animate-in">
  <h2>‚ôªÔ∏è Access Tokens vs Refresh Tokens</h2>
  <table class="compare-table">
    <tr><th>Feature</th><th>Access Token</th><th>Refresh Token</th></tr>
    <tr><td>Purpose</td><td>Authorize API requests</td><td>Get new access tokens</td></tr>
    <tr><td>Lifetime</td><td>Short (5-15 minutes)</td><td>Long (days to weeks)</td></tr>
    <tr><td>Storage</td><td>Memory or httpOnly cookie</td><td>httpOnly cookie (server-set)</td></tr>
    <tr><td>Sent with</td><td>Every API request</td><td>Only to /refresh endpoint</td></tr>
    <tr><td>Contains</td><td>User claims, permissions</td><td>Minimal (user ID only)</td></tr>
    <tr><td>Revocable?</td><td>Not easily (stateless)</td><td>Yes (store in DB, blacklist)</td></tr>
  </table>

  ${codeBlock(`<span class="cm">// Token refresh flow</span>
<span class="kw">async function</span> <span class="fn">refreshAccessToken</span>() {
  <span class="kw">const</span> res = <span class="kw">await</span> <span class="fn">fetch</span>(<span class="str">'/api/refresh'</span>, {
    method: <span class="str">'POST'</span>,
    credentials: <span class="str">'include'</span> <span class="cm">// Send httpOnly cookie</span>
  });
  
  <span class="kw">if</span> (!res.ok) {
    <span class="cm">// Refresh token expired ‚Äî force re-login</span>
    <span class="fn">redirectToLogin</span>();
    <span class="kw">return</span>;
  }
  
  <span class="kw">const</span> { accessToken } = <span class="kw">await</span> res.<span class="fn">json</span>();
  tokenStore.accessToken = accessToken;
}

<span class="cm">// Axios interceptor for auto-refresh</span>
axios.interceptors.response.<span class="fn">use</span>(
  response => response,
  <span class="kw">async</span> error => {
    <span class="kw">if</span> (error.response?.status === <span class="num">401</span> && !error.config._retry) {
      error.config._retry = <span class="kw">true</span>;
      <span class="kw">await</span> <span class="fn">refreshAccessToken</span>();
      error.config.headers[<span class="str">'Authorization'</span>] = 
        <span class="str">\`Bearer \${tokenStore.accessToken}\`</span>;
      <span class="kw">return</span> <span class="fn">axios</span>(error.config);
    }
    <span class="kw">return</span> Promise.<span class="fn">reject</span>(error);
  }
);`, 'Token Refresh Pattern')}
</div>

<div style="text-align:center;padding:20px">
  <button class="btn btn-primary" onclick="markComplete('jwt-basics');navigate('jwt-lab')">Continue to JWT Lab ‚Üí</button>
</div>
`;

pageInit['jwt-basics'] = () => {
  setTimeout(() => {
    animateFlow('jwtFlow');
  }, 500);
};

// ============================================================
// JWT LAB
// ============================================================
pages['jwt-lab'] = () => `
<div class="module-header animate-in">
  <h1>üî¨ JWT Interactive Lab</h1>
  <p>Build, decode, and verify JWTs in real-time using the Web Crypto API</p>
</div>

<div class="card animate-in">
  <h2>üîß JWT Builder</h2>
  <p>Create a real JWT right here in your browser! Modify the header, payload, and secret to see how the token changes.</p>
  
  <div class="demo-area">
    <h3>‚ö° Live JWT Generator</h3>
    <div class="demo-row">
      <div>
        <div class="demo-label">Header</div>
        <textarea class="demo-input" id="jwtHeader" oninput="buildJWT()">{\n  "alg": "HS256",\n  "typ": "JWT"\n}</textarea>
      </div>
      <div>
        <div class="demo-label">Payload</div>
        <textarea class="demo-input" id="jwtPayload" oninput="buildJWT()">{\n  "sub": "1234567890",\n  "name": "John Doe",\n  "role": "admin",\n  "iat": ${Math.floor(Date.now()/1000)},\n  "exp": ${Math.floor(Date.now()/1000) + 3600}\n}</textarea>
      </div>
    </div>
    <div class="demo-label">Secret Key</div>
    <input type="text" class="demo-input" id="jwtSecret" value="my-super-secret-key-123" oninput="buildJWT()">
    
    <div class="demo-label" style="margin-top:16px">Generated JWT</div>
    <div class="demo-output" id="jwtOutput" style="cursor:pointer" onclick="copyJWT()">
      <span style="color:var(--text2)">Generating...</span>
    </div>
    
    <div style="margin-top:12px">
      <div class="demo-label">Decoded Parts</div>
      <div id="jwtParts"></div>
    </div>
  </div>
</div>

<div class="card animate-in">
  <h2>üîç JWT Decoder</h2>
  <p>Paste any JWT to decode and inspect its contents:</p>
  
  <div class="demo-area">
    <h3>‚ö° JWT Inspector</h3>
    <textarea class="demo-input" id="jwtDecodeInput" placeholder="Paste a JWT here..." oninput="decodeJWT()"></textarea>
    <div id="jwtDecodeOutput"></div>
  </div>
</div>

<div class="card animate-in">
  <h2>üéØ Exercise: Spot the Vulnerability</h2>
  <div class="exercise">
    <h3>üèãÔ∏è Challenge: What's wrong with this JWT implementation?</h3>
    <p>Look at this code and identify ALL the security issues:</p>
    ${codeBlock(`<span class="kw">const</span> jwt = <span class="fn">require</span>(<span class="str">'jsonwebtoken'</span>);

<span class="cm">// Login handler</span>
app.<span class="fn">post</span>(<span class="str">'/login'</span>, (req, res) => {
  <span class="kw">const</span> user = db.<span class="fn">findUser</span>(req.body.email);
  
  <span class="kw">if</span> (user.password === req.body.password) {
    <span class="kw">const</span> token = jwt.<span class="fn">sign</span>({
      sub: user.id,
      password: user.password,
      role: user.role,
      isAdmin: <span class="kw">true</span>
    }, <span class="str">'secret123'</span>);
    
    res.<span class="fn">json</span>({ token });
  }
});

<span class="cm">// Verify middleware</span>
<span class="kw">function</span> <span class="fn">verify</span>(req, res, next) {
  <span class="kw">const</span> token = req.headers.authorization;
  <span class="kw">const</span> decoded = jwt.<span class="fn">decode</span>(token);
  req.user = decoded;
  <span class="fn">next</span>();
}`, 'Buggy Code')}
    
    <div id="vulnAnswers" style="display:none">
      <div class="pitfall">
        <h4>üö´ Issues Found:</h4>
        <ol>
          <li><strong>Plain-text password comparison</strong> ‚Äî Should use bcrypt.compare()</li>
          <li><strong>Password in JWT payload</strong> ‚Äî NEVER put sensitive data in tokens!</li>
          <li><strong>Hardcoded secret</strong> ‚Äî 'secret123' is too weak and hardcoded</li>
          <li><strong>No expiration</strong> ‚Äî Token never expires, valid forever</li>
          <li><strong>Hardcoded isAdmin: true</strong> ‚Äî Should come from the database</li>
          <li><strong>jwt.decode() instead of jwt.verify()</strong> ‚Äî decode() doesn't validate the signature!</li>
          <li><strong>No algorithm specified</strong> ‚Äî Vulnerable to algorithm confusion attack</li>
          <li><strong>No "Bearer " prefix handling</strong> ‚Äî Authorization header includes "Bearer " prefix</li>
        </ol>
      </div>
    </div>
    
    <div class="btn-group">
      <button class="btn btn-primary" onclick="document.getElementById('vulnAnswers').style.display='block';if(!state.exercisesDone.has('jwt-vuln')){state.exercisesDone.add('jwt-vuln');addXP(30,'Vulnerability exercise completed!')}">Reveal Answers</button>
    </div>
  </div>
</div>

<div style="text-align:center;padding:20px">
  <button class="btn btn-primary" onclick="markComplete('jwt-lab');navigate('jwt-pitfalls')">Continue to JWT Pitfalls ‚Üí</button>
</div>
`;

pageInit['jwt-lab'] = () => {
  buildJWT();
};

// ============================================================
// JWT PITFALLS
// ============================================================
pages['jwt-pitfalls'] = () => `
<div class="module-header animate-in">
  <h1>‚ö†Ô∏è JWT Pitfalls & Security</h1>
  <p>Critical mistakes that could compromise your entire application</p>
</div>

<div class="card animate-in">
  <h2>üö® The 10 Deadly JWT Mistakes</h2>
  
  <div class="pitfall">
    <h4>üö´ 1. Using jwt.decode() Instead of jwt.verify()</h4>
    <p><code>jwt.decode()</code> does NOT validate the signature. ALWAYS use <code>jwt.verify()</code>. An attacker can modify the payload and you'd never know.</p>
  </div>

  <div class="pitfall">
    <h4>üö´ 2. Storing Sensitive Data in the Payload</h4>
    <p>JWT payloads are only base64-encoded, NOT encrypted. Never include passwords, credit cards, or PII. Use encryption (JWE) if you must include sensitive data.</p>
  </div>

  <div class="pitfall">
    <h4>üö´ 3. Not Setting Token Expiration</h4>
    <p>Tokens without <code>exp</code> claim are valid forever. Always set short expiration times (5-15 min for access tokens).</p>
  </div>

  <div class="pitfall">
    <h4>üö´ 4. Weak or Hardcoded Secrets</h4>
    <p>Using secrets like "secret", "password123", or any value shorter than 256 bits. Use <code>crypto.randomBytes(64).toString('hex')</code> for HMAC secrets.</p>
  </div>

  <div class="pitfall">
    <h4>üö´ 5. Algorithm Confusion Attack</h4>
    <p>Not specifying the algorithm in <code>verify()</code>. An attacker could switch from RS256 to HS256, using the public key as the HMAC secret!</p>
    ${codeBlock(`<span class="cm">// ‚ùå VULNERABLE ‚Äî accepts any algorithm</span>
jwt.<span class="fn">verify</span>(token, publicKey);

<span class="cm">// ‚úÖ SAFE ‚Äî explicitly specify algorithm</span>
jwt.<span class="fn">verify</span>(token, publicKey, { algorithms: [<span class="str">'RS256'</span>] });`, 'Fix')}
  </div>

  <div class="pitfall">
    <h4>üö´ 6. Storing JWTs in localStorage</h4>
    <p>localStorage is accessible by any JavaScript on the page ‚Äî vulnerable to XSS attacks. Use httpOnly cookies or in-memory storage for SPAs.</p>
  </div>

  <div class="pitfall">
    <h4>üö´ 7. Not Implementing Token Revocation</h4>
    <p>JWTs are stateless ‚Äî you can't invalidate them before expiry. Implement: short-lived tokens + refresh tokens, or a token blacklist for critical operations.</p>
  </div>

  <div class="pitfall">
    <h4>üö´ 8. Accepting the "none" Algorithm</h4>
    <p>Some JWT libraries accept <code>"alg": "none"</code> which means no signature verification. Always reject unsigned tokens.</p>
  </div>

  <div class="pitfall">
    <h4>üö´ 9. Not Validating All Claims</h4>
    <p>Always validate: <code>exp</code> (expiration), <code>iss</code> (issuer), <code>aud</code> (audience). Don't just check the signature.</p>
  </div>

  <div class="pitfall">
    <h4>üö´ 10. Using JWT for Sessions Without Understanding Tradeoffs</h4>
    <p>JWTs aren't always better than sessions. They can't be easily revoked, they increase request size, and they add complexity. Choose based on your architecture.</p>
  </div>
</div>

<div class="card animate-in">
  <h2>‚úÖ JWT Security Checklist</h2>
  <ul class="checklist" id="securityChecklist">
    <li onclick="this.classList.toggle('checked')"><span class="check-box"></span> Use jwt.verify(), never jwt.decode() for auth</li>
    <li onclick="this.classList.toggle('checked')"><span class="check-box"></span> Always specify algorithms in verify options</li>
    <li onclick="this.classList.toggle('checked')"><span class="check-box"></span> Set short expiration (exp) on access tokens</li>
    <li onclick="this.classList.toggle('checked')"><span class="check-box"></span> Use strong secrets (256+ bits for HMAC)</li>
    <li onclick="this.classList.toggle('checked')"><span class="check-box"></span> Store tokens in httpOnly cookies or memory</li>
    <li onclick="this.classList.toggle('checked')"><span class="check-box"></span> Implement refresh token rotation</li>
    <li onclick="this.classList.toggle('checked')"><span class="check-box"></span> Validate iss, aud, and exp claims</li>
    <li onclick="this.classList.toggle('checked')"><span class="check-box"></span> Never store sensitive data in the payload</li>
    <li onclick="this.classList.toggle('checked')"><span class="check-box"></span> Use HTTPS for all token transmission</li>
    <li onclick="this.classList.toggle('checked')"><span class="check-box"></span> Implement token blacklisting for logout</li>
  </ul>
</div>

<div class="card animate-in">
  <h2>üÜö JWT Storage Comparison</h2>
  <table class="compare-table">
    <tr><th>Storage</th><th>XSS Safe?</th><th>CSRF Safe?</th><th>Best For</th></tr>
    <tr><td><code>localStorage</code></td><td style="color:var(--error)">‚ùå No</td><td style="color:var(--success)">‚úÖ Yes</td><td>Never for auth tokens</td></tr>
    <tr><td><code>sessionStorage</code></td><td style="color:var(--error)">‚ùå No</td><td style="color:var(--success)">‚úÖ Yes</td><td>Temporary non-sensitive data</td></tr>
    <tr><td>httpOnly Cookie</td><td style="color:var(--success)">‚úÖ Yes</td><td style="color:var(--error)">‚ùå Needs CSRF token</td><td>Refresh tokens ‚≠ê</td></tr>
    <tr><td>In-Memory (variable)</td><td style="color:var(--success)">‚úÖ Yes</td><td style="color:var(--success)">‚úÖ Yes</td><td>Access tokens in SPAs ‚≠ê</td></tr>
  </table>
  
  <div class="tip">
    <h4>üí° Best Practice Pattern</h4>
    <p>Store access tokens in memory (JS variable/closure). Store refresh tokens in httpOnly, Secure, SameSite=Strict cookies. This gives you the best of both worlds.</p>
  </div>
</div>

<div style="text-align:center;padding:20px">
  <button class="btn btn-primary" onclick="markComplete('jwt-pitfalls');navigate('jwt-quiz')">Take the JWT Quiz ‚Üí</button>
</div>
`;

// ============================================================
// JWT QUIZ
// ============================================================
pages['jwt-quiz'] = () => `
<div class="module-header animate-in">
  <h1>‚ùì JWT Knowledge Check</h1>
  <p>Test your understanding of JSON Web Tokens</p>
</div>

<div class="quiz-container" id="jwtQuiz">
  ${generateQuiz('jwt', [
    {
      q: 'What are the three parts of a JWT?',
      options: ['Username, Password, Token', 'Header, Payload, Signature', 'Key, Value, Hash', 'Public Key, Private Key, Certificate'],
      correct: 1,
      explain: 'A JWT consists of Header (algorithm & type), Payload (claims/data), and Signature (verification hash), separated by dots.'
    },
    {
      q: 'Which method should you use to validate a JWT on the server?',
      options: ['jwt.decode()', 'jwt.parse()', 'jwt.verify()', 'JSON.parse()'],
      correct: 2,
      explain: 'jwt.verify() validates the signature and checks claims. jwt.decode() only reads the payload WITHOUT checking the signature ‚Äî never use it for authentication!'
    },
    {
      q: 'Why is storing JWTs in localStorage considered insecure?',
      options: ['It\'s too slow', 'Vulnerable to XSS ‚Äî any JS on the page can read it', 'It can\'t store strings', 'The data expires automatically'],
      correct: 1,
      explain: 'localStorage is accessible by any JavaScript running on the page. If an attacker injects a script (XSS), they can steal the token. Use httpOnly cookies or in-memory storage instead.'
    },
    {
      q: 'What is the "algorithm confusion" attack?',
      options: ['Using too many algorithms', 'Switching from RS256 to HS256, using the public key as the HMAC secret', 'Encrypting instead of signing', 'Using SHA-1 instead of SHA-256'],
      correct: 1,
      explain: 'If you don\'t specify the expected algorithm in verify(), an attacker can change the header to HS256 and sign with the known public key. Always specify {algorithms: ["RS256"]} in verify options.'
    },
    {
      q: 'What is the recommended expiration time for an access token?',
      options: ['1 year', '30 days', '5-15 minutes', 'Never expires'],
      correct: 2,
      explain: 'Access tokens should be short-lived (5-15 minutes) to minimize the window of attack. Use refresh tokens (stored securely) to get new access tokens.'
    },
    {
      q: 'Can the payload of a JWT be read without the secret key?',
      options: ['No, it\'s fully encrypted', 'Yes, it\'s only base64-encoded', 'Only if you have the public key', 'Only on the server'],
      correct: 1,
      explain: 'JWT payloads are base64url-encoded, NOT encrypted. Anyone can decode and read them. The signature only prevents tampering, not reading. Never put secrets in the payload!'
    },
    {
      q: 'What is the purpose of a refresh token?',
      options: ['To refresh the page', 'To get a new access token without re-authenticating', 'To update user profile', 'To clear the session'],
      correct: 1,
      explain: 'Refresh tokens are long-lived tokens used to obtain new access tokens when they expire, without requiring the user to log in again. They should be stored in httpOnly cookies and rotated on use.'
    },
    {
      q: 'Which JWT claim indicates when the token expires?',
      options: ['iss', 'sub', 'exp', 'aud'],
      correct: 2,
      explain: 'exp (expiration time) is a registered claim indicating when the token should no longer be accepted. iss = issuer, sub = subject, aud = audience.'
    }
  ])}
</div>

<div id="jwtQuizResult"></div>

<div style="text-align:center;padding:20px">
  <button class="btn btn-primary" id="jwtQuizSubmit" onclick="submitQuiz('jwt', 8)">Submit Quiz</button>
  <button class="btn btn-secondary" onclick="navigate('oauth-basics')" style="display:none" id="jwtQuizNext">Continue to OAuth ‚Üí</button>
</div>
`;

// ============================================================
// OAUTH BASICS
// ============================================================
pages['oauth-basics'] = () => `
<div class="module-header animate-in">
  <h1>üîÑ OAuth 2.0 Fundamentals</h1>
  <p>Delegated authorization ‚Äî letting users grant limited access without sharing passwords</p>
</div>

<div class="card animate-in">
  <h2>üìñ What is OAuth 2.0?</h2>
  <p>OAuth 2.0 is an <strong>authorization framework</strong> that allows third-party applications to access a user's resources <strong>without knowing their password</strong>.</p>
  
  <div class="warn">
    <h4>‚ö° Important Distinction</h4>
    <p><strong>OAuth is for Authorization, NOT Authentication.</strong> OAuth tells you what a user is allowed to do, not who they are. OpenID Connect (OIDC) adds an identity layer on top of OAuth for authentication.</p>
  </div>

  <h3>Real-World Analogy</h3>
  <p>Think of OAuth like a <strong>valet key</strong> for your car. Instead of giving someone your master key (password), you give them a limited key that can only drive the car but can't open the trunk or glove box.</p>

  <h3>The Four Roles</h3>
  <div class="flow-actors">
    <div class="flow-actor"><div class="actor-icon">üë§</div>Resource Owner<br><small>(User)</small></div>
    <div class="flow-actor"><div class="actor-icon">üì±</div>Client<br><small>(Your App)</small></div>
    <div class="flow-actor"><div class="actor-icon">üèõÔ∏è</div>Auth Server<br><small>(Google, GitHub)</small></div>
    <div class="flow-actor"><div class="actor-icon">üì¶</div>Resource Server<br><small>(API)</small></div>
  </div>
</div>

<div class="card animate-in">
  <h2>üîê OAuth 2.0 Grant Types</h2>
  
  <div class="tabs">
    <div class="tab active" onclick="switchTab(this, 'auth-code-tab')">Authorization Code + PKCE ‚≠ê</div>
    <div class="tab" onclick="switchTab(this, 'client-cred-tab')">Client Credentials</div>
    <div class="tab" onclick="switchTab(this, 'implicit-tab')">Implicit (Deprecated)</div>
    <div class="tab" onclick="switchTab(this, 'device-tab')">Device Code</div>
  </div>

  <div class="tab-content active" id="auth-code-tab">
    <h3>Authorization Code + PKCE <span class="badge badge-new">Recommended</span></h3>
    <p>The most secure flow for web and mobile apps. PKCE (Proof Key for Code Exchange) prevents authorization code interception attacks.</p>
    
    <div class="flow-diagram" id="authCodeFlow">
      <div class="flow-step active">
        <div class="flow-step-num">1</div>
        <div class="flow-step-content">
          <h4>Generate PKCE codes</h4>
          <p>Client creates code_verifier (random string) and code_challenge (SHA-256 hash)</p>
        </div>
      </div>
      <div class="flow-step">
        <div class="flow-step-num">2</div>
        <div class="flow-step-content">
          <h4>Redirect to Auth Server</h4>
          <p>User is sent to /authorize with client_id, redirect_uri, scope, code_challenge</p>
        </div>
      </div>
      <div class="flow-step">
        <div class="flow-step-num">3</div>
        <div class="flow-step-content">
          <h4>User authenticates & consents</h4>
          <p>User logs in and approves the requested permissions</p>
        </div>
      </div>
      <div class="flow-step">
        <div class="flow-step-num">4</div>
        <div class="flow-step-content">
          <h4>Auth Server redirects with code</h4>
          <p>User is redirected back to your app with a temporary authorization code</p>
        </div>
      </div>
      <div class="flow-step">
        <div class="flow-step-num">5</div>
        <div class="flow-step-content">
          <h4>Exchange code for tokens</h4>
          <p>Your backend sends code + code_verifier to /token endpoint</p>
        </div>
      </div>
      <div class="flow-step">
        <div class="flow-step-num">6</div>
        <div class="flow-step-content">
          <h4>Receive tokens</h4>
          <p>Auth Server returns access_token, refresh_token, and id_token (OIDC)</p>
        </div>
      </div>
    </div>
    <div class="btn-group">
      <button class="btn btn-primary" onclick="animateFlow('authCodeFlow')">‚ñ∂ Play Flow</button>
      <button class="btn btn-secondary" onclick="resetFlow('authCodeFlow')">‚Ü∫ Reset</button>
    </div>

    ${codeBlock(`<span class="cm">// Step 1: Generate PKCE codes</span>
<span class="kw">function</span> <span class="fn">generateCodeVerifier</span>() {
  <span class="kw">const</span> array = <span class="kw">new</span> Uint8Array(<span class="num">32</span>);
  crypto.<span class="fn">getRandomValues</span>(array);
  <span class="kw">return</span> btoa(String.<span class="fn">fromCharCode</span>(...array))
    .<span class="fn">replace</span>(<span class="str">/\\+/g</span>, <span class="str">'-'</span>).<span class="fn">replace</span>(<span class="str">/\\//g</span>, <span class="str">'_'</span>).<span class="fn">replace</span>(<span class="str">/=+$/</span>, <span class="str">''</span>);
}

<span class="kw">async function</span> <span class="fn">generateCodeChallenge</span>(verifier) {
  <span class="kw">const</span> digest = <span class="kw">await</span> crypto.subtle.<span class="fn">digest</span>(
    <span class="str">'SHA-256'</span>, <span class="kw">new</span> TextEncoder().<span class="fn">encode</span>(verifier)
  );
  <span class="kw">return</span> btoa(String.<span class="fn">fromCharCode</span>(...<span class="kw">new</span> Uint8Array(digest)))
    .<span class="fn">replace</span>(<span class="str">/\\+/g</span>, <span class="str">'-'</span>).<span class="fn">replace</span>(<span class="str">/\\//g</span>, <span class="str">'_'</span>).<span class="fn">replace</span>(<span class="str">/=+$/</span>, <span class="str">''</span>);
}

<span class="cm">// Step 2: Redirect to auth server</span>
<span class="kw">async function</span> <span class="fn">startOAuthFlow</span>() {
  <span class="kw">const</span> codeVerifier = <span class="fn">generateCodeVerifier</span>();
  <span class="kw">const</span> codeChallenge = <span class="kw">await</span> <span class="fn">generateCodeChallenge</span>(codeVerifier);
  <span class="kw">const</span> state = crypto.<span class="fn">randomUUID</span>(); <span class="cm">// CSRF protection</span>
  
  <span class="cm">// Store for later verification</span>
  sessionStorage.<span class="fn">setItem</span>(<span class="str">'code_verifier'</span>, codeVerifier);
  sessionStorage.<span class="fn">setItem</span>(<span class="str">'oauth_state'</span>, state);
  
  <span class="kw">const</span> params = <span class="kw">new</span> URLSearchParams({
    response_type: <span class="str">'code'</span>,
    client_id: <span class="str">'YOUR_CLIENT_ID'</span>,
    redirect_uri: <span class="str">'https://yourapp.com/callback'</span>,
    scope: <span class="str">'openid profile email'</span>,
    state: state,
    code_challenge: codeChallenge,
    code_challenge_method: <span class="str">'S256'</span>
  });
  
  window.location.href = 
    <span class="str">\`https://auth.provider.com/authorize?\${params}\`</span>;
}

<span class="cm">// Step 5: Exchange code for tokens (on callback page)</span>
<span class="kw">async function</span> <span class="fn">handleCallback</span>() {
  <span class="kw">const</span> params = <span class="kw">new</span> URLSearchParams(window.location.search);
  <span class="kw">const</span> code = params.<span class="fn">get</span>(<span class="str">'code'</span>);
  <span class="kw">const</span> returnedState = params.<span class="fn">get</span>(<span class="str">'state'</span>);
  
  <span class="cm">// Verify state to prevent CSRF</span>
  <span class="kw">if</span> (returnedState !== sessionStorage.<span class="fn">getItem</span>(<span class="str">'oauth_state'</span>)) {
    <span class="kw">throw new</span> Error(<span class="str">'State mismatch! Possible CSRF attack.'</span>);
  }
  
  <span class="cm">// Exchange code for tokens (via your backend)</span>
  <span class="kw">const</span> res = <span class="kw">await</span> <span class="fn">fetch</span>(<span class="str">'/api/oauth/token'</span>, {
    method: <span class="str">'POST'</span>,
    headers: { <span class="str">'Content-Type'</span>: <span class="str">'application/json'</span> },
    body: <span class="fn">JSON.stringify</span>({
      code,
      code_verifier: sessionStorage.<span class="fn">getItem</span>(<span class="str">'code_verifier'</span>)
    })
  });
  
  <span class="kw">const</span> tokens = <span class="kw">await</span> res.<span class="fn">json</span>();
  <span class="cm">// Store and use tokens...</span>
}`, 'Complete PKCE Flow Implementation')}
  </div>

  <div class="tab-content" id="client-cred-tab">
    <h3>Client Credentials Flow</h3>
    <p>Used for <strong>machine-to-machine</strong> (M2M) communication where no user is involved. The application authenticates itself.</p>
    ${codeBlock(`<span class="cm">// Server-to-server authentication</span>
<span class="kw">async function</span> <span class="fn">getM2MToken</span>() {
  <span class="kw">const</span> res = <span class="kw">await</span> <span class="fn">fetch</span>(<span class="str">'https://auth.provider.com/token'</span>, {
    method: <span class="str">'POST'</span>,
    headers: { <span class="str">'Content-Type'</span>: <span class="str">'application/x-www-form-urlencoded'</span> },
    body: <span class="kw">new</span> URLSearchParams({
      grant_type: <span class="str">'client_credentials'</span>,
      client_id: process.env.CLIENT_ID,
      client_secret: process.env.CLIENT_SECRET,
      scope: <span class="str">'read:data write:data'</span>
    })
  });
  <span class="kw">return</span> res.<span class="fn">json</span>(); <span class="cm">// { access_token, token_type, expires_in }</span>
}`, 'Client Credentials')}
  </div>

  <div class="tab-content" id="implicit-tab">
    <div class="pitfall">
      <h4>üö´ DEPRECATED ‚Äî Do Not Use</h4>
      <p>The Implicit flow returns tokens directly in the URL fragment, making them vulnerable to interception. Use Authorization Code + PKCE instead, even for SPAs.</p>
    </div>
  </div>

  <div class="tab-content" id="device-tab">
    <h3>Device Code Flow</h3>
    <p>Used for devices with limited input (smart TVs, CLI tools). User authorizes on a separate device.</p>
    ${codeBlock(`<span class="cm">// Step 1: Request device code</span>
<span class="kw">const</span> { device_code, user_code, verification_uri } = 
  <span class="kw">await</span> <span class="fn">requestDeviceCode</span>();

<span class="cm">// Step 2: Display to user</span>
console.<span class="fn">log</span>(<span class="str">\`Visit \${verification_uri} and enter: \${user_code}\`</span>);

<span class="cm">// Step 3: Poll for completion</span>
<span class="kw">const</span> tokens = <span class="kw">await</span> <span class="fn">pollForToken</span>(device_code);`, 'Device Code Flow')}
  </div>
</div>

<div class="card animate-in">
  <h2>üÜö OAuth vs JWT vs Sessions</h2>
  <table class="compare-table">
    <tr><th>Concept</th><th>What It Is</th><th>Purpose</th></tr>
    <tr><td><strong>OAuth 2.0</strong></td><td>Authorization framework/protocol</td><td>Delegate access to resources</td></tr>
    <tr><td><strong>JWT</strong></td><td>Token format (data structure)</td><td>Compact, signed data container</td></tr>
    <tr><td><strong>Sessions</strong></td><td>Server-side state management</td><td>Track authenticated users</td></tr>
    <tr><td><strong>OpenID Connect</strong></td><td>Identity layer on OAuth</td><td>Authentication (who you are)</td></tr>
  </table>
  <div class="tip">
    <h4>üí° How They Relate</h4>
    <p>OAuth uses JWTs as the token format. Sessions can store OAuth tokens server-side. OIDC extends OAuth with identity verification. They're layers, not competitors.</p>
  </div>
</div>

<div style="text-align:center;padding:20px">
  <button class="btn btn-primary" onclick="markComplete('oauth-basics');navigate('oauth-flows')">Continue to OAuth Flow Simulator ‚Üí</button>
</div>
`;

// ============================================================
// OAUTH FLOWS SIMULATOR
// ============================================================
pages['oauth-flows'] = () => `
<div class="module-header animate-in">
  <h1>üîÑ OAuth Flow Simulator</h1>
  <p>Step through the Authorization Code + PKCE flow interactively</p>
</div>

<div class="card animate-in">
  <h2>‚ö° Interactive PKCE Generator</h2>
  <div class="demo-area">
    <h3>üîë Generate PKCE Codes</h3>
    <p>Click the button to generate a real PKCE code verifier and challenge pair:</p>
    <button class="btn btn-primary" onclick="generatePKCE()" style="margin:12px 0">Generate PKCE Pair</button>
    
    <div id="pkceOutput" style="display:none">
      <div class="demo-label" style="margin-top:12px">Code Verifier (random 32 bytes, base64url)</div>
      <div class="demo-output" id="pkceVerifier" style="color:var(--success);font-size:.8rem"></div>
      
      <div class="demo-label" style="margin-top:12px">Code Challenge (SHA-256 of verifier, base64url)</div>
      <div class="demo-output" id="pkceChallenge" style="color:var(--accent);font-size:.8rem"></div>
      
      <div class="demo-label" style="margin-top:12px">Authorization URL Preview</div>
      <div class="demo-output" id="pkceUrl" style="color:var(--text2);font-size:.75rem;word-break:break-all"></div>
    </div>
  </div>
</div>

<div class="card animate-in">
  <h2>üé≠ OAuth Attack Scenarios</h2>
  
  <div class="pitfall">
    <h4>üö´ Without PKCE ‚Äî Authorization Code Interception</h4>
    <p>A malicious app on the same device intercepts the authorization code from the redirect URI. Without PKCE, they can exchange this code for tokens because there's no proof the app that started the flow is the same one completing it.</p>
  </div>

  <div class="tip">
    <h4>‚úÖ With PKCE ‚Äî Attack Prevented</h4>
    <p>Even if the attacker intercepts the code, they can't exchange it because they don't have the <code>code_verifier</code> (it was only stored in the legitimate app's memory). The auth server rejects the token request.</p>
  </div>

  <h3>State Parameter ‚Äî CSRF Protection</h3>
  ${codeBlock(`<span class="cm">// ALWAYS use the state parameter</span>
<span class="kw">const</span> state = crypto.<span class="fn">randomUUID</span>();
sessionStorage.<span class="fn">setItem</span>(<span class="str">'oauth_state'</span>, state);

<span class="cm">// Include in authorization request</span>
<span class="kw">const</span> authUrl = <span class="str">\`\${authEndpoint}?state=\${state}&...\`</span>;

<span class="cm">// Verify on callback</span>
<span class="kw">const</span> returnedState = <span class="kw">new</span> URLSearchParams(location.search).<span class="fn">get</span>(<span class="str">'state'</span>);
<span class="kw">if</span> (returnedState !== sessionStorage.<span class="fn">getItem</span>(<span class="str">'oauth_state'</span>)) {
  <span class="kw">throw new</span> Error(<span class="str">'CSRF attack detected!'</span>);
}`, 'CSRF Protection with State')}
</div>

<div class="card animate-in">
  <h2>üìã OAuth Scopes ‚Äî Principle of Least Privilege</h2>
  <p>Scopes limit what the application can do with the user's data:</p>
  ${codeBlock(`<span class="cm">// ‚ùå Too broad ‚Äî requesting everything</span>
scope: <span class="str">'read write admin delete'</span>

<span class="cm">// ‚úÖ Minimal ‚Äî only what you need</span>
scope: <span class="str">'read:profile read:email'</span>

<span class="cm">// Common OAuth scopes</span>
<span class="str">'openid'</span>       <span class="cm">// OIDC: get user identifier</span>
<span class="str">'profile'</span>      <span class="cm">// OIDC: name, picture, etc.</span>
<span class="str">'email'</span>        <span class="cm">// OIDC: email address</span>
<span class="str">'offline_access'</span> <span class="cm">// Get a refresh token</span>`, 'Scopes')}
</div>

<div style="text-align:center;padding:20px">
  <button class="btn btn-primary" onclick="markComplete('oauth-flows');navigate('oauth-quiz')">Take OAuth Quiz ‚Üí</button>
</div>
`;

// ============================================================
// OAUTH QUIZ
// ============================================================
pages['oauth-quiz'] = () => `
<div class="module-header animate-in">
  <h1>‚ùì OAuth Knowledge Check</h1>
  <p>Test your understanding of OAuth 2.0</p>
</div>

<div class="quiz-container" id="oauthQuiz">
  ${generateQuiz('oauth', [
    {
      q: 'What is the primary purpose of OAuth 2.0?',
      options: ['Authentication (verify identity)', 'Authorization (delegate access)', 'Encryption', 'Password management'],
      correct: 1,
      explain: 'OAuth 2.0 is an authorization framework. It allows users to grant third-party apps limited access to their resources without sharing passwords. OpenID Connect adds authentication on top.'
    },
    {
      q: 'What does PKCE protect against?',
      options: ['SQL injection', 'Authorization code interception', 'Password brute force', 'DDoS attacks'],
      correct: 1,
      explain: 'PKCE (Proof Key for Code Exchange) prevents attackers from exchanging a stolen authorization code for tokens. The code_verifier proves the app that requests the token is the same one that started the flow.'
    },
    {
      q: 'Why is the Implicit flow deprecated?',
      options: ['It\'s too slow', 'Tokens are exposed in the URL fragment', 'It requires a backend', 'It doesn\'t support refresh tokens'],
      correct: 1,
      explain: 'The Implicit flow returns tokens directly in the URL fragment (#access_token=...), making them visible in browser history and vulnerable to interception. Use Auth Code + PKCE instead.'
    },
    {
      q: 'What is the purpose of the "state" parameter in OAuth?',
      options: ['Store user location', 'CSRF protection', 'Indicate the US state', 'Store session data'],
      correct: 1,
      explain: 'The state parameter is a random value that must be verified on the callback to prevent Cross-Site Request Forgery attacks. Always use it!'
    },
    {
      q: 'Which grant type is best for machine-to-machine communication?',
      options: ['Authorization Code', 'Implicit', 'Client Credentials', 'Device Code'],
      correct: 2,
      explain: 'Client Credentials is designed for M2M communication where no user is involved. The application authenticates with its own credentials (client_id + client_secret).'
    },
    {
      q: 'Where should you exchange the authorization code for tokens?',
      options: ['In the browser (client-side)', 'On your backend server', 'In localStorage', 'In the URL'],
      correct: 1,
      explain: 'The token exchange should happen on your backend to keep the client_secret secure. Never expose your client_secret in client-side code.'
    }
  ])}
</div>

<div id="oauthQuizResult"></div>

<div style="text-align:center;padding:20px">
  <button class="btn btn-primary" id="oauthQuizSubmit" onclick="submitQuiz('oauth', 6)">Submit Quiz</button>
  <button class="btn btn-secondary" onclick="navigate('password-basics')" style="display:none" id="oauthQuizNext">Continue to Password Security ‚Üí</button>
</div>
`;

// ============================================================
// PASSWORD BASICS
// ============================================================
pages['password-basics'] = () => `
<div class="module-header animate-in">
  <h1>üõ°Ô∏è Password Security Fundamentals</h1>
  <p>Why hashing matters and how to do it right</p>
</div>

<div class="card animate-in">
  <h2>üíÄ The Password Storage Horror Scale</h2>
  <p>From worst to best, here's how passwords can be stored:</p>
  
  <div style="display:grid;gap:12px;margin:16px 0">
    <div style="background:rgba(239,68,68,.15);border:1px solid rgba(239,68,68,.3);border-radius:10px;padding:16px">
      <strong style="color:var(--error)">Level 0: Plain Text üíÄüíÄüíÄ</strong>
      <p style="font-size:.85rem;color:var(--text2);margin-top:4px"><code>password: "MyPassword123"</code> ‚Äî If the DB leaks, everyone's passwords are immediately visible.</p>
    </div>
    <div style="background:rgba(239,68,68,.1);border:1px solid rgba(239,68,68,.2);border-radius:10px;padding:16px">
      <strong style="color:var(--error)">Level 1: Simple Encryption üíÄüíÄ</strong>
      <p style="font-size:.85rem;color:var(--text2);margin-top:4px"><code>encrypted: AES("MyPassword123", key)</code> ‚Äî Reversible! If the key leaks, all passwords are exposed at once.</p>
    </div>
    <div style="background:rgba(245,158,11,.1);border:1px solid rgba(245,158,11,.2);border-radius:10px;padding:16px">
      <strong style="color:var(--warn)">Level 2: Simple Hash (MD5/SHA) üíÄ</strong>
      <p style="font-size:.85rem;color:var(--text2);margin-top:4px"><code>hash: SHA256("MyPassword123")</code> ‚Äî One-way, but vulnerable to rainbow tables and too fast to brute-force.</p>
    </div>
    <div style="background:rgba(245,158,11,.05);border:1px solid rgba(245,158,11,.15);border-radius:10px;padding:16px">
      <strong style="color:var(--warn)">Level 3: Hash + Salt ‚ö†Ô∏è</strong>
      <p style="font-size:.85rem;color:var(--text2);margin-top:4px"><code>hash: SHA256(salt + "MyPassword123")</code> ‚Äî Better! But SHA is still too fast for password hashing.</p>
    </div>
    <div style="background:rgba(16,185,129,.1);border:1px solid rgba(16,185,129,.3);border-radius:10px;padding:16px">
      <strong style="color:var(--success)">Level 4: bcrypt / scrypt ‚úÖ</strong>
      <p style="font-size:.85rem;color:var(--text2);margin-top:4px"><code>hash: bcrypt("MyPassword123", 12)</code> ‚Äî Intentionally slow, includes salt, resistant to GPU attacks.</p>
    </div>
    <div style="background:rgba(16,185,129,.15);border:1px solid rgba(16,185,129,.4);border-radius:10px;padding:16px">
      <strong style="color:var(--success)">Level 5: Argon2id ‚úÖ‚úÖ ‚≠ê</strong>
      <p style="font-size:.85rem;color:var(--text2);margin-top:4px"><code>hash: argon2id("MyPassword123", {memory, time, parallelism})</code> ‚Äî Current gold standard. Memory-hard, resistant to GPU/ASIC attacks.</p>
    </div>
  </div>
</div>

<div class="card animate-in">
  <h2>üßÇ What is Salting?</h2>
  <p>A <strong>salt</strong> is a random value added to each password before hashing. It ensures that identical passwords produce different hashes.</p>

  ${codeBlock(`<span class="cm">// Without salt ‚Äî identical passwords = identical hashes</span>
SHA256(<span class="str">"password123"</span>) ‚Üí <span class="str">"ef92b778..."</span>  <span class="cm">// User A</span>
SHA256(<span class="str">"password123"</span>) ‚Üí <span class="str">"ef92b778..."</span>  <span class="cm">// User B ‚Äî SAME!</span>

<span class="cm">// With salt ‚Äî identical passwords = DIFFERENT hashes</span>
SHA256(<span class="str">"x8k2m9"</span> + <span class="str">"password123"</span>) ‚Üí <span class="str">"a3f8c1d2..."</span>  <span class="cm">// User A</span>
SHA256(<span class="str">"p4n7q1"</span> + <span class="str">"password123"</span>) ‚Üí <span class="str">"7b2e9f4a..."</span>  <span class="cm">// User B ‚Äî DIFFERENT!</span>`, 'Salting Explained')}

  <div class="tip">
    <h4>üí° Key Points About Salts</h4>
    <ul>
      <li>Each user gets a <strong>unique, random</strong> salt</li>
      <li>Salts are stored alongside the hash (they're NOT secret)</li>
      <li>Salts defeat precomputed rainbow tables</li>
      <li>bcrypt and Argon2 generate and embed salts automatically</li>
    </ul>
  </div>
</div>

<div class="card animate-in">
  <h2>üíª Implementation ‚Äî The Right Way</h2>
  
  <h3>Using bcrypt (Node.js)</h3>
  ${codeBlock(`<span class="kw">const</span> bcrypt = <span class="fn">require</span>(<span class="str">'bcrypt'</span>);
<span class="kw">const</span> SALT_ROUNDS = <span class="num">12</span>; <span class="cm">// Cost factor (10-12 recommended)</span>

<span class="cm">// Registration ‚Äî hash the password</span>
<span class="kw">async function</span> <span class="fn">registerUser</span>(email, password) {
  <span class="cm">// bcrypt generates salt automatically</span>
  <span class="kw">const</span> passwordHash = <span class="kw">await</span> bcrypt.<span class="fn">hash</span>(password, SALT_ROUNDS);
  
  <span class="cm">// Store hash in database (NOT the password!)</span>
  <span class="kw">await</span> db.<span class="fn">query</span>(
    <span class="str">'INSERT INTO users (email, password_hash) VALUES ($1, $2)'</span>,
    [email, passwordHash]
  );
  <span class="cm">// passwordHash looks like:</span>
  <span class="cm">// "$2b$12$LJ3m4ys3Lg7Gy2a/kQ0wO.v5eBNq3l5Kj8jX3eZ0YH1n7k6KqW"</span>
  <span class="cm">//  ^^^^ ^^  ^^^^^^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^^^^^^^^^^</span>
  <span class="cm">//  algo cost      salt (22 chars)         hash</span>
}

<span class="cm">// Login ‚Äî verify the password</span>
<span class="kw">async function</span> <span class="fn">loginUser</span>(email, password) {
  <span class="kw">const</span> user = <span class="kw">await</span> db.<span class="fn">query</span>(
    <span class="str">'SELECT * FROM users WHERE email = $1'</span>, [email]
  );
  
  <span class="kw">if</span> (!user) {
    <span class="cm">// Don't reveal whether email exists!</span>
    <span class="kw">throw new</span> Error(<span class="str">'Invalid credentials'</span>);
  }
  
  <span class="cm">// bcrypt.compare extracts the salt from the hash</span>
  <span class="kw">const</span> isValid = <span class="kw">await</span> bcrypt.<span class="fn">compare</span>(password, user.password_hash);
  
  <span class="kw">if</span> (!isValid) {
    <span class="kw">throw new</span> Error(<span class="str">'Invalid credentials'</span>);
  }
  
  <span class="kw">return</span> user;
}`, 'bcrypt ‚Äî Complete Example')}

  <h3>Using Argon2 (Node.js) ‚Äî Gold Standard</h3>
  ${codeBlock(`<span class="kw">const</span> argon2 = <span class="fn">require</span>(<span class="str">'argon2'</span>);

<span class="cm">// Hash with Argon2id (recommended variant)</span>
<span class="kw">const</span> hash = <span class="kw">await</span> argon2.<span class="fn">hash</span>(password, {
  type: argon2.argon2id,  <span class="cm">// Hybrid: resistant to side-channel + GPU</span>
  memoryCost: <span class="num">65536</span>,     <span class="cm">// 64 MB memory</span>
  timeCost: <span class="num">3</span>,            <span class="cm">// 3 iterations</span>
  parallelism: <span class="num">4</span>         <span class="cm">// 4 threads</span>
});

<span class="cm">// Verify</span>
<span class="kw">const</span> isValid = <span class="kw">await</span> argon2.<span class="fn">verify</span>(hash, password);`, 'Argon2 ‚Äî Gold Standard')}

  <div class="pitfall">
    <h4>üö´ Never Do These</h4>
    <ul>
      <li>Never use MD5 or SHA-1/SHA-256 alone for passwords (too fast!)</li>
      <li>Never create your own hashing algorithm</li>
      <li>Never store passwords in plain text or reversible encryption</li>
      <li>Never use the same salt for all users</li>
      <li>Never log passwords (even in error logs!)</li>
      <li>Never compare passwords with === (use timing-safe comparison)</li>
    </ul>
  </div>
</div>

<div style="text-align:center;padding:20px">
  <button class="btn btn-primary" onclick="markComplete('password-basics');navigate('password-lab')">Continue to Hashing Lab ‚Üí</button>
</div>
`;

// ============================================================
// PASSWORD LAB
// ============================================================
pages['password-lab'] = () => `
<div class="module-header animate-in">
  <h1>üî¨ Password Hashing Lab</h1>
  <p>See hashing in action with real SHA-256 using the Web Crypto API</p>
</div>

<div class="card animate-in">
  <h2>‚ö° Live SHA-256 Hash Demo</h2>
  <div class="demo-area">
    <h3>üîë Hash Any Input</h3>
    <p>Type anything below and watch the SHA-256 hash change. Notice how even a tiny change completely alters the hash (avalanche effect).</p>
    <input type="text" class="demo-input" id="hashInput" placeholder="Type something to hash..." oninput="liveHash()">
    
    <div class="demo-label">SHA-256 Hash</div>
    <div class="demo-output" id="hashOutput" style="font-size:.8rem;letter-spacing:1px"></div>
    
    <div class="demo-label" style="margin-top:12px">Hash Visualization</div>
    <div class="hash-grid" id="hashGrid"></div>
    
    <div class="demo-label" style="margin-top:12px">Key Properties</div>
    <div id="hashProperties" style="font-size:.85rem;color:var(--text2)"></div>
  </div>
</div>

<div class="card animate-in">
  <h2>üßÇ Salt Demonstration</h2>
  <div class="demo-area">
    <h3>See How Salting Works</h3>
    <p>Same password, different salts = completely different hashes:</p>
    <input type="text" class="demo-input" id="saltPassword" placeholder="Enter a password..." value="password123" oninput="showSalting()">
    <button class="btn btn-primary btn-sm" onclick="showSalting()" style="margin-bottom:12px">Generate 3 Salted Hashes</button>
    <div id="saltOutput"></div>
  </div>
</div>

<div class="card animate-in">
  <h2>‚ö° Brute Force Speed Comparison</h2>
  <p>Why bcrypt/Argon2 are better than SHA-256 for passwords:</p>
  
  <table class="compare-table">
    <tr><th>Algorithm</th><th>Hashes/Second (GPU)</th><th>Time to crack "password123"</th></tr>
    <tr><td>MD5</td><td style="color:var(--error)">~25 billion/s</td><td style="color:var(--error)">Instant</td></tr>
    <tr><td>SHA-256</td><td style="color:var(--error)">~5 billion/s</td><td style="color:var(--error)">Milliseconds</td></tr>
    <tr><td>bcrypt (cost 12)</td><td style="color:var(--success)">~10,000/s</td><td style="color:var(--success)">Hours to days</td></tr>
    <tr><td>Argon2id</td><td style="color:var(--success)">~1,000/s</td><td style="color:var(--success)">Days to weeks</td></tr>
  </table>
  
  <div class="tip">
    <h4>üí° Why Slowness is Good</h4>
    <p>For normal login (1 attempt), waiting 100ms is fine. But an attacker trying billions of passwords needs each attempt to be slow. bcrypt with cost factor 12 takes ~250ms per hash ‚Äî fast enough for login, impossibly slow for brute force.</p>
  </div>
</div>

<div class="card animate-in">
  <h2>üèãÔ∏è Exercise: Password Validation</h2>
  <div class="exercise">
    <h3>üí™ Implement a Password Strength Checker</h3>
    <p>Determine the strength based on: length, uppercase, lowercase, numbers, special characters.</p>
    
    <input type="text" class="demo-input" id="strengthInput" placeholder="Enter a password to check..." oninput="checkPasswordStrength()">
    
    <div id="strengthResult" style="margin-top:12px"></div>
    
    <div style="margin-top:16px">
      <div class="demo-label">Strength Requirements</div>
      <ul class="checklist" id="strengthChecklist">
        <li id="req-length"><span class="check-box"></span> At least 12 characters</li>
        <li id="req-upper"><span class="check-box"></span> Contains uppercase letter</li>
        <li id="req-lower"><span class="check-box"></span> Contains lowercase letter</li>
        <li id="req-number"><span class="check-box"></span> Contains number</li>
        <li id="req-special"><span class="check-box"></span> Contains special character</li>
        <li id="req-nocommon"><span class="check-box"></span> Not a common password</li>
      </ul>
    </div>
  </div>
</div>

<div style="text-align:center;padding:20px">
  <button class="btn btn-primary" onclick="markComplete('password-lab');navigate('password-quiz')">Take Password Quiz ‚Üí</button>
</div>
`;

pageInit['password-lab'] = () => {
  liveHash();
  showSalting();
};

// ============================================================
// PASSWORD QUIZ
// ============================================================
pages['password-quiz'] = () => `
<div class="module-header animate-in">
  <h1>‚ùì Password Security Check</h1>
  <p>Test your password security knowledge</p>
</div>

<div class="quiz-container" id="passwordQuiz">
  ${generateQuiz('password', [
    {
      q: 'Why is SHA-256 alone NOT suitable for password hashing?',
      options: ['It produces too long a hash', 'It\'s too fast ‚Äî makes brute force easy', 'It\'s broken/insecure', 'It requires too much memory'],
      correct: 1,
      explain: 'SHA-256 is designed to be fast (5 billion hashes/sec on GPU). For passwords, you want slowness. bcrypt/Argon2 are intentionally slow to make brute force impractical.'
    },
    {
      q: 'What is the purpose of a salt in password hashing?',
      options: ['Encrypt the password', 'Make identical passwords produce different hashes', 'Speed up the hashing process', 'Replace the need for a strong password'],
      correct: 1,
      explain: 'A salt is a random value unique to each user. It ensures that two users with the same password have completely different hashes, defeating rainbow table attacks.'
    },
    {
      q: 'Which is currently considered the gold standard for password hashing?',
      options: ['MD5', 'SHA-256 with salt', 'bcrypt', 'Argon2id'],
      correct: 3,
      explain: 'Argon2id (winner of the Password Hashing Competition 2015) is memory-hard and GPU/ASIC-resistant. bcrypt is also excellent and widely supported. Both are good choices.'
    },
    {
      q: 'What should the error message say when login fails?',
      options: ['"Password is incorrect"', '"User not found"', '"Invalid credentials"', '"Your password is wrong for user X"'],
      correct: 2,
      explain: 'Always use a generic message like "Invalid credentials." Specific messages like "user not found" or "wrong password" help attackers enumerate valid usernames.'
    },
    {
      q: 'Is the salt value a secret?',
      options: ['Yes, it must be encrypted', 'No, it\'s stored alongside the hash', 'Yes, it should be in an env variable', 'It depends on the algorithm'],
      correct: 1,
      explain: 'Salts are NOT secret. They\'re stored in the database alongside the hash. Their purpose is to ensure uniqueness, not secrecy. bcrypt even embeds the salt directly in the hash string.'
    },
    {
      q: 'What is the difference between hashing and encryption?',
      options: ['They\'re the same thing', 'Hashing is reversible, encryption is not', 'Hashing is one-way, encryption is two-way (reversible)', 'Encryption is faster'],
      correct: 2,
      explain: 'Hashing is a one-way function ‚Äî you cannot recover the original input. Encryption is two-way ‚Äî with the key, you can decrypt and get the original data back. Passwords should be HASHED, never encrypted.'
    }
  ])}
</div>

<div id="passwordQuizResult"></div>

<div style="text-align:center;padding:20px">
  <button class="btn btn-primary" id="passwordQuizSubmit" onclick="submitQuiz('password', 6)">Submit Quiz</button>
  <button class="btn btn-secondary" onclick="navigate('session-basics')" style="display:none" id="passwordQuizNext">Continue to Session Management ‚Üí</button>
</div>
`;

// ============================================================
// SESSION BASICS
// ============================================================
pages['session-basics'] = () => `
<div class="module-header animate-in">
  <h1>üç™ Session Management</h1>
  <p>Cookies, sessions, and keeping track of authenticated users</p>
</div>

<div class="card animate-in">
  <h2>üìñ What is a Session?</h2>
  <p>A <strong>session</strong> is a server-side record that associates a user with their requests. Since HTTP is stateless, sessions provide the mechanism to "remember" users across requests.</p>
  
  <h3>Session-Based vs Token-Based Auth</h3>
  <div class="demo-row">
    <div style="background:var(--surface);border:1px solid var(--border);border-radius:10px;padding:16px">
      <h4 style="color:var(--accent)">üç™ Session-Based (Stateful)</h4>
      <ol style="font-size:.85rem;color:var(--text2)">
        <li>User logs in</li>
        <li>Server creates session in DB/memory</li>
        <li>Server sends session ID via cookie</li>
        <li>Browser auto-sends cookie with each request</li>
        <li>Server looks up session to identify user</li>
      </ol>
    </div>
    <div style="background:var(--surface);border:1px solid var(--border);border-radius:10px;padding:16px">
      <h4 style="color:var(--accent2)">üîë Token-Based (Stateless)</h4>
      <ol style="font-size:.85rem;color:var(--text2)">
        <li>User logs in</li>
        <li>Server creates signed JWT</li>
        <li>Server sends token to client</li>
        <li>Client sends token in Authorization header</li>
        <li>Server verifies token signature</li>
      </ol>
    </div>
  </div>
</div>

<div class="card animate-in">
  <h2>üç™ Cookie Security Attributes</h2>
  <p>Cookies have critical security flags that MUST be set correctly:</p>
  
  ${codeBlock(`<span class="cm">// Setting a secure session cookie (Node.js/Express)</span>
res.<span class="fn">cookie</span>(<span class="str">'sessionId'</span>, sessionId, {
  <span class="prop">httpOnly</span>: <span class="kw">true</span>,     <span class="cm">// Can't be accessed by JavaScript (XSS protection)</span>
  <span class="prop">secure</span>: <span class="kw">true</span>,       <span class="cm">// Only sent over HTTPS</span>
  <span class="prop">sameSite</span>: <span class="str">'strict'</span>, <span class="cm">// CSRF protection (not sent cross-origin)</span>
  <span class="prop">maxAge</span>: <span class="num">3600000</span>,    <span class="cm">// 1 hour in milliseconds</span>
  <span class="prop">path</span>: <span class="str">'/'</span>,          <span class="cm">// Available on all routes</span>
  <span class="prop">domain</span>: <span class="str">'.myapp.com'</span> <span class="cm">// Accessible on subdomains</span>
});`, 'Secure Cookie Configuration')}

  <table class="compare-table">
    <tr><th>Attribute</th><th>Purpose</th><th>Risk if Missing</th></tr>
    <tr><td><code>HttpOnly</code></td><td>Blocks JavaScript access to cookie</td><td style="color:var(--error)">XSS can steal session</td></tr>
    <tr><td><code>Secure</code></td><td>Cookie only sent over HTTPS</td><td style="color:var(--error)">Cookie leaked over HTTP</td></tr>
    <tr><td><code>SameSite=Strict</code></td><td>Cookie not sent in cross-origin requests</td><td style="color:var(--error)">Vulnerable to CSRF</td></tr>
    <tr><td><code>Max-Age / Expires</code></td><td>Cookie expiration</td><td style="color:var(--warn)">Session lasts forever</td></tr>
    <tr><td><code>Path</code></td><td>URL scope for the cookie</td><td style="color:var(--warn)">Cookie sent unnecessarily</td></tr>
  </table>
</div>

<div class="card animate-in">
  <h2>üîê Session Implementation (Express.js)</h2>
  ${codeBlock(`<span class="kw">const</span> session = <span class="fn">require</span>(<span class="str">'express-session'</span>);
<span class="kw">const</span> RedisStore = <span class="fn">require</span>(<span class="str">'connect-redis'</span>)(session);
<span class="kw">const</span> redis = <span class="fn">require</span>(<span class="str">'redis'</span>);

<span class="kw">const</span> redisClient = redis.<span class="fn">createClient</span>();

app.<span class="fn">use</span>(<span class="fn">session</span>({
  store: <span class="kw">new</span> <span class="fn">RedisStore</span>({ client: redisClient }),
  secret: process.env.SESSION_SECRET,  <span class="cm">// Use a strong secret</span>
  name: <span class="str">'__session'</span>,      <span class="cm">// Custom name (not 'connect.sid')</span>
  resave: <span class="kw">false</span>,
  saveUninitialized: <span class="kw">false</span>,
  cookie: {
    httpOnly: <span class="kw">true</span>,
    secure: process.env.NODE_ENV === <span class="str">'production'</span>,
    sameSite: <span class="str">'strict'</span>,
    maxAge: <span class="num">1800000</span> <span class="cm">// 30 minutes</span>
  }
}));

<span class="cm">// Login</span>
app.<span class="fn">post</span>(<span class="str">'/login'</span>, <span class="kw">async</span> (req, res) => {
  <span class="kw">const</span> user = <span class="kw">await</span> <span class="fn">authenticateUser</span>(req.body);
  
  <span class="cm">// Regenerate session ID to prevent session fixation</span>
  req.session.<span class="fn">regenerate</span>((err) => {
    req.session.userId = user.id;
    req.session.role = user.role;
    res.<span class="fn">json</span>({ success: <span class="kw">true</span> });
  });
});

<span class="cm">// Logout</span>
app.<span class="fn">post</span>(<span class="str">'/logout'</span>, (req, res) => {
  req.session.<span class="fn">destroy</span>((err) => {
    res.<span class="fn">clearCookie</span>(<span class="str">'__session'</span>);
    res.<span class="fn">json</span>({ success: <span class="kw">true</span> });
  });
});

<span class="cm">// Auth middleware</span>
<span class="kw">function</span> <span class="fn">requireAuth</span>(req, res, next) {
  <span class="kw">if</span> (!req.session.userId) {
    <span class="kw">return</span> res.<span class="fn">status</span>(<span class="num">401</span>).<span class="fn">json</span>({ error: <span class="str">'Not authenticated'</span> });
  }
  <span class="fn">next</span>();
}`, 'Production Session Setup')}
</div>

<div class="card animate-in">
  <h2>‚öîÔ∏è Session Security Attacks</h2>
  
  <div class="pitfall">
    <h4>üö´ Session Fixation</h4>
    <p>Attacker sets a known session ID before the user logs in. After login, the attacker uses that session ID. <strong>Fix:</strong> Always regenerate the session ID after login (<code>req.session.regenerate()</code>).</p>
  </div>

  <div class="pitfall">
    <h4>üö´ Session Hijacking (XSS)</h4>
    <p>Attacker steals the session cookie through a cross-site scripting attack. <strong>Fix:</strong> Use <code>HttpOnly</code> cookies (JavaScript can't access them).</p>
  </div>

  <div class="pitfall">
    <h4>üö´ CSRF (Cross-Site Request Forgery)</h4>
    <p>Attacker tricks user's browser into making authenticated requests to your server. <strong>Fix:</strong> Use <code>SameSite=Strict</code> cookies + CSRF tokens.</p>
    ${codeBlock(`<span class="cm">// CSRF Protection with csurf middleware</span>
<span class="kw">const</span> csrf = <span class="fn">require</span>(<span class="str">'csurf'</span>);
app.<span class="fn">use</span>(<span class="fn">csrf</span>({ cookie: <span class="kw">true</span> }));

<span class="cm">// Send CSRF token to client</span>
app.<span class="fn">get</span>(<span class="str">'/csrf-token'</span>, (req, res) => {
  res.<span class="fn">json</span>({ csrfToken: req.<span class="fn">csrfToken</span>() });
});

<span class="cm">// Client includes in requests</span>
<span class="fn">fetch</span>(<span class="str">'/api/transfer'</span>, {
  method: <span class="str">'POST'</span>,
  headers: {
    <span class="str">'CSRF-Token'</span>: csrfToken,
    <span class="str">'Content-Type'</span>: <span class="str">'application/json'</span>
  },
  body: <span class="fn">JSON.stringify</span>(data)
});`, 'CSRF Protection')}
  </div>
</div>

<div class="card animate-in">
  <h2>üÜö When to Use Sessions vs JWTs</h2>
  <table class="compare-table">
    <tr><th>Factor</th><th>Sessions</th><th>JWTs</th></tr>
    <tr><td>Architecture</td><td>Monolith, server-rendered apps</td><td>Microservices, SPAs, mobile</td></tr>
    <tr><td>Scalability</td><td>Requires shared session store</td><td>Stateless, easy to scale</td></tr>
    <tr><td>Revocation</td><td>‚úÖ Easy (delete from store)</td><td>‚ùå Hard (need blacklist)</td></tr>
    <tr><td>Payload size</td><td>Small (just session ID)</td><td>Larger (contains claims)</td></tr>
    <tr><td>Cross-domain</td><td>‚ùå Difficult with cookies</td><td>‚úÖ Easy with headers</td></tr>
    <tr><td>Security</td><td>XSS-safe with HttpOnly</td><td>Must manage storage carefully</td></tr>
  </table>
</div>

<div style="text-align:center;padding:20px">
  <button class="btn btn-primary" onclick="markComplete('session-basics');navigate('session-lab')">Continue to Session Lab ‚Üí</button>
</div>
`;

// ============================================================
// SESSION LAB
// ============================================================
pages['session-lab'] = () => `
<div class="module-header animate-in">
  <h1>üî¨ Session Lab</h1>
  <p>Explore browser storage and cookie mechanics hands-on</p>
</div>

<div class="card animate-in">
  <h2>üç™ Cookie Inspector</h2>
  <div class="demo-area">
    <h3>‚ö° Set & Read Cookies</h3>
    <div class="demo-row">
      <div>
        <div class="demo-label">Cookie Name</div>
        <input type="text" class="demo-input" id="cookieName" value="demo_session">
      </div>
      <div>
        <div class="demo-label">Cookie Value</div>
        <input type="text" class="demo-input" id="cookieValue" value="abc123xyz">
      </div>
    </div>
    <div class="btn-group">
      <button class="btn btn-primary btn-sm" onclick="setCookie()">Set Cookie</button>
      <button class="btn btn-secondary btn-sm" onclick="readCookies()">Read All Cookies</button>
      <button class="btn btn-danger btn-sm" onclick="clearAllCookies()">Clear All</button>
    </div>
    <div class="demo-output" id="cookieOutput" style="min-height:60px"></div>
    
    <div class="warn" style="margin-top:12px">
      <h4>‚ö° Note</h4>
      <p>These are regular cookies (not HttpOnly). In production, auth cookies should be HttpOnly so JavaScript can't access them ‚Äî that's the whole point!</p>
    </div>
  </div>
</div>

<div class="card animate-in">
  <h2>üíæ Storage Comparison Demo</h2>
  <div class="demo-area">
    <h3>‚ö° localStorage vs sessionStorage</h3>
    <input type="text" class="demo-input" id="storageKey" placeholder="Key" value="authToken">
    <input type="text" class="demo-input" id="storageValue" placeholder="Value" value="eyJhbGciOiJIUzI1NiJ9...">
    <div class="btn-group">
      <button class="btn btn-primary btn-sm" onclick="setStorage('local')">Set localStorage</button>
      <button class="btn btn-primary btn-sm" onclick="setStorage('session')">Set sessionStorage</button>
      <button class="btn btn-secondary btn-sm" onclick="readStorage()">Read Both</button>
      <button class="btn btn-danger btn-sm" onclick="clearStorage()">Clear Both</button>
    </div>
    <div class="demo-row" style="margin-top:12px">
      <div>
        <div class="demo-label">localStorage</div>
        <div class="demo-output" id="localStorageOutput" style="min-height:60px;font-size:.8rem"></div>
      </div>
      <div>
        <div class="demo-label">sessionStorage</div>
        <div class="demo-output" id="sessionStorageOutput" style="min-height:60px;font-size:.8rem"></div>
      </div>
    </div>
    
    <div class="pitfall" style="margin-top:12px">
      <h4>üö´ Security Warning</h4>
      <p>Both localStorage and sessionStorage are accessible by ANY JavaScript on the page. If an attacker injects a script (XSS), they can steal anything stored here. <strong>Never store auth tokens in localStorage!</strong></p>
    </div>
  </div>
</div>

<div class="card animate-in">
  <h2>üé≠ XSS Attack Simulation</h2>
  <div class="attack-demo">
    <h4>‚ö†Ô∏è See Why HttpOnly Matters</h4>
    <p style="color:var(--text2);font-size:.85rem;margin-bottom:12px">This demonstrates how XSS can steal tokens from localStorage but NOT from HttpOnly cookies:</p>
    
    <button class="btn btn-danger btn-sm" onclick="simulateXSS()" style="margin-bottom:12px">Simulate XSS Attack</button>
    <div class="attack-output" id="xssOutput"></div>
    
    <div class="tip" style="margin-top:12px">
      <h4>‚úÖ Defense</h4>
      <p>Store tokens in HttpOnly cookies (JavaScript can't access them). Always sanitize user input. Use Content Security Policy (CSP) headers.</p>
    </div>
  </div>
</div>

<div class="card animate-in">
  <h2>‚úÖ Session Security Checklist</h2>
  <ul class="checklist">
    <li onclick="this.classList.toggle('checked')"><span class="check-box"></span> Use HttpOnly + Secure + SameSite cookies</li>
    <li onclick="this.classList.toggle('checked')"><span class="check-box"></span> Regenerate session ID after login</li>
    <li onclick="this.classList.toggle('checked')"><span class="check-box"></span> Set appropriate session timeout</li>
    <li onclick="this.classList.toggle('checked')"><span class="check-box"></span> Destroy session completely on logout</li>
    <li onclick="this.classList.toggle('checked')"><span class="check-box"></span> Use CSRF tokens for state-changing operations</li>
    <li onclick="this.classList.toggle('checked')"><span class="check-box"></span> Use a dedicated session store (Redis) in production</li>
    <li onclick="this.classList.toggle('checked')"><span class="check-box"></span> Rename default session cookie name</li>
    <li onclick="this.classList.toggle('checked')"><span class="check-box"></span> Implement absolute session timeout</li>
    <li onclick="this.classList.toggle('checked')"><span class="check-box"></span> Log session events for security monitoring</li>
  </ul>
</div>

<div style="text-align:center;padding:20px">
  <button class="btn btn-primary" onclick="markComplete('session-lab');navigate('session-quiz')">Take Session Quiz ‚Üí</button>
</div>
`;

pageInit['session-lab'] = () => {
  readCookies();
  readStorage();
};

// ============================================================
// SESSION QUIZ
// ============================================================
pages['session-quiz'] = () => `
<div class="module-header animate-in">
  <h1>‚ùì Session Management Check</h1>
  <p>Test your knowledge of sessions, cookies, and security</p>
</div>

<div class="quiz-container" id="sessionQuiz">
  ${generateQuiz('session', [
    {
      q: 'What does the HttpOnly cookie flag do?',
      options: ['Makes the cookie HTTP-only (not HTTPS)', 'Prevents JavaScript from accessing the cookie', 'Makes the cookie expire after the browser closes', 'Encrypts the cookie value'],
      correct: 1,
      explain: 'HttpOnly prevents client-side JavaScript (document.cookie) from reading the cookie. This protects session tokens from XSS attacks.'
    },
    {
      q: 'What is session fixation?',
      options: ['When a session expires', 'Attacker sets a known session ID before user logs in', 'When the server runs out of memory', 'Using fixed session timeouts'],
      correct: 1,
      explain: 'In session fixation, the attacker sets a session ID (e.g., via URL parameter) before the victim logs in. After login, the attacker uses that same session ID. Fix: regenerate session ID after authentication.'
    },
    {
      q: 'What SameSite cookie value provides the best CSRF protection?',
      options: ['None', 'Lax', 'Strict', 'Secure'],
      correct: 2,
      explain: 'SameSite=Strict never sends the cookie in cross-origin requests. SameSite=Lax allows it on top-level navigations (clicking links). For auth cookies, Strict is safest.'
    },
    {
      q: 'Why should you regenerate the session ID after login?',
      options: ['To improve performance', 'To prevent session fixation attacks', 'Because the old one expires', 'To change the cookie name'],
      correct: 1,
      explain: 'Regenerating the session ID after login ensures that any pre-authentication session ID (potentially set by an attacker) is replaced with a new, secure one.'
    },
    {
      q: 'For a SPA with a separate API, what\'s the best token storage strategy?',
      options: ['localStorage for all tokens', 'Access token in memory, refresh token in httpOnly cookie', 'Both tokens in sessionStorage', 'Tokens in URL parameters'],
      correct: 1,
      explain: 'Access tokens in memory (JS variable) are safe from XSS. Refresh tokens in httpOnly cookies are safe from both XSS and CSRF (with SameSite). This is the current best practice for SPAs.'
    },
    {
      q: 'What is CSRF (Cross-Site Request Forgery)?',
      options: ['Injecting scripts into a page', 'Tricking a user\'s browser into making authenticated requests to another site', 'Guessing session IDs', 'Man-in-the-middle attack'],
      correct: 1,
      explain: 'CSRF tricks the user\'s browser into sending an authenticated request to your server (e.g., via a hidden form on a malicious page). The browser automatically includes cookies, so the server thinks it\'s a legitimate request.'
    }
  ])}
</div>

<div id="sessionQuizResult"></div>

<div style="text-align:center;padding:20px">
  <button class="btn btn-primary" id="sessionQuizSubmit" onclick="submitQuiz('session', 6)">Submit Quiz</button>
  <button class="btn btn-secondary" onclick="navigate('final-challenge')" style="display:none" id="sessionQuizNext">Take Final Challenge ‚Üí</button>
</div>
`;

// ============================================================
// FINAL CHALLENGE
// ============================================================
pages['final-challenge'] = () => `
<div class="module-header animate-in">
  <h1>üèÜ Final Challenge</h1>
  <p>Put everything together ‚Äî identify issues and apply best practices</p>
</div>

<div class="card animate-in">
  <h2>üî• Code Review Challenge</h2>
  <p>You're reviewing the authentication system for a startup. Find ALL the security issues in this code:</p>
  
  ${codeBlock(`<span class="kw">const</span> express = <span class="fn">require</span>(<span class="str">'express'</span>);
<span class="kw">const</span> jwt = <span class="fn">require</span>(<span class="str">'jsonwebtoken'</span>);
<span class="kw">const</span> crypto = <span class="fn">require</span>(<span class="str">'crypto'</span>);
<span class="kw">const</span> app = <span class="fn">express</span>();

<span class="kw">const</span> SECRET = <span class="str">"mysecret"</span>;
<span class="kw">const</span> users = [];

<span class="cm">// 1. Registration</span>
app.<span class="fn">post</span>(<span class="str">'/register'</span>, (req, res) => {
  <span class="kw">const</span> { email, password } = req.body;
  <span class="kw">const</span> hash = crypto.<span class="fn">createHash</span>(<span class="str">'md5'</span>)
    .<span class="fn">update</span>(password).<span class="fn">digest</span>(<span class="str">'hex'</span>);
  users.<span class="fn">push</span>({ email, password: hash });
  res.<span class="fn">json</span>({ message: <span class="str">'Registered!'</span> });
});

<span class="cm">// 2. Login</span>
app.<span class="fn">post</span>(<span class="str">'/login'</span>, (req, res) => {
  <span class="kw">const</span> { email, password } = req.body;
  <span class="kw">const</span> hash = crypto.<span class="fn">createHash</span>(<span class="str">'md5'</span>)
    .<span class="fn">update</span>(password).<span class="fn">digest</span>(<span class="str">'hex'</span>);
  <span class="kw">const</span> user = users.<span class="fn">find</span>(
    u => u.email === email && u.password === hash
  );
  <span class="kw">if</span> (!user) {
    <span class="kw">return</span> res.<span class="fn">status</span>(<span class="num">401</span>)
      .<span class="fn">json</span>({ error: <span class="str">'User not found'</span> });
  }
  <span class="kw">const</span> token = jwt.<span class="fn">sign</span>(
    { email, password: hash, isAdmin: <span class="kw">true</span> },
    SECRET
  );
  res.<span class="fn">json</span>({ token });
});

<span class="cm">// 3. Protected route</span>
app.<span class="fn">get</span>(<span class="str">'/admin'</span>, (req, res) => {
  <span class="kw">const</span> token = req.query.token;
  <span class="kw">const</span> user = jwt.<span class="fn">decode</span>(token);
  <span class="kw">if</span> (user.isAdmin) {
    res.<span class="fn">json</span>({ data: <span class="str">'secret admin data'</span> });
  }
});

<span class="cm">// 4. OAuth callback</span>
app.<span class="fn">get</span>(<span class="str">'/callback'</span>, (req, res) => {
  <span class="kw">const</span> { code } = req.query;
  <span class="cm">// Exchange code for token directly from client</span>
  <span class="fn">fetch</span>(<span class="str">'https://oauth.provider/token'</span>, {
    body: <span class="fn">JSON.stringify</span>({
      code,
      client_secret: <span class="str">'EXPOSED_SECRET_123'</span>
    })
  });
});`, 'Review This Code')}
  
  <div class="exercise">
    <h3>üèãÔ∏è How many issues can you find?</h3>
    <p>Write your answers in the box below, then reveal the solution:</p>
    <div class="exercise-editor">
      <textarea id="finalExercise" placeholder="List all the security issues you can find...&#10;&#10;1. ...&#10;2. ...&#10;3. ..."></textarea>
    </div>
    
    <div id="finalAnswers" style="display:none;margin-top:20px">
      <div class="pitfall">
        <h4>üö® All Issues Found (15 total!):</h4>
        <ol style="font-size:.88rem">
          <li><strong>Weak secret</strong> ‚Äî "mysecret" is trivially guessable. Use 256+ bit random secret from env vars.</li>
          <li><strong>MD5 for password hashing</strong> ‚Äî MD5 is broken and too fast. Use bcrypt or Argon2.</li>
          <li><strong>No salt</strong> ‚Äî Even if using a proper hash, no salt is added.</li>
          <li><strong>In-memory user storage</strong> ‚Äî Data lost on restart. Use a database.</li>
          <li><strong>No input validation</strong> ‚Äî No email/password format validation.</li>
          <li><strong>No rate limiting</strong> ‚Äî Vulnerable to brute force attacks.</li>
          <li><strong>Specific error message</strong> ‚Äî "User not found" reveals if email exists. Use "Invalid credentials".</li>
          <li><strong>Password hash in JWT</strong> ‚Äî Sensitive data exposed in the token payload.</li>
          <li><strong>Hardcoded isAdmin: true</strong> ‚Äî Everyone becomes admin! Should come from database.</li>
          <li><strong>No token expiration</strong> ‚Äî JWT valid forever without exp claim.</li>
          <li><strong>jwt.decode() instead of jwt.verify()</strong> ‚Äî No signature verification = anyone can forge tokens!</li>
          <li><strong>Token in URL query parameter</strong> ‚Äî Visible in logs, browser history, referrer headers.</li>
          <li><strong>No algorithm specified</strong> ‚Äî Vulnerable to algorithm confusion attack.</li>
          <li><strong>Client secret in client-side code</strong> ‚Äî OAuth client_secret exposed to users.</li>
          <li><strong>No state parameter in OAuth</strong> ‚Äî Vulnerable to CSRF attacks.</li>
        </ol>
      </div>
    </div>
    
    <div class="btn-group">
      <button class="btn btn-primary" onclick="document.getElementById('finalAnswers').style.display='block';if(!state.exercisesDone.has('final')){state.exercisesDone.add('final');addXP(50,'Final challenge completed! üèÜ')}">Reveal All Issues</button>
    </div>
  </div>
</div>

<div class="card animate-in">
  <h2>üìã Master Quiz ‚Äî 10 Questions</h2>
  <div class="quiz-container" id="finalQuiz">
    ${generateQuiz('final', [
      {
        q: 'You need to build auth for a React SPA with a Node.js API. What\'s the best approach?',
        options: ['Store JWT in localStorage, send in Authorization header', 'Access token in memory + refresh token in httpOnly cookie', 'Session cookie with express-session only', 'Store everything in sessionStorage'],
        correct: 1,
        explain: 'For SPAs: access token in memory (safe from XSS), refresh token in httpOnly cookie (safe from XSS+CSRF). This is the current best practice pattern.'
      },
      {
        q: 'An attacker intercepts the OAuth authorization code. What prevents them from using it?',
        options: ['The code expires after 1 hour', 'PKCE ‚Äî they don\'t have the code_verifier', 'The code is encrypted', 'Nothing, they can use it freely'],
        correct: 1,
        explain: 'PKCE requires the code_verifier (only known to the original client) when exchanging the code for tokens. Without it, the authorization server rejects the request.'
      },
      {
        q: 'What\'s wrong with: if (password === storedPassword) { ... }',
        options: ['=== should be ==', 'Comparing plain text passwords ‚Äî should compare hashes', 'Nothing, this is correct', 'Should use .equals() method'],
        correct: 1,
        explain: 'This compares plain text passwords, meaning passwords are stored in plain text. Should be: await bcrypt.compare(password, storedHash)'
      },
      {
        q: 'A JWT has exp set to 30 days. What\'s the problem?',
        options: ['30 days is too short', 'If the token is stolen, attacker has access for 30 days', 'JWTs can\'t have exp over 24 hours', 'Nothing, this is fine'],
        correct: 1,
        explain: 'JWTs are hard to revoke. A 30-day access token means a stolen token provides unauthorized access for up to 30 days. Use 5-15 minute access tokens with refresh token rotation.'
      },
      {
        q: 'Which header protects against clickjacking?',
        options: ['Content-Security-Policy', 'X-Frame-Options', 'Strict-Transport-Security', 'X-Content-Type-Options'],
        correct: 1,
        explain: 'X-Frame-Options: DENY (or SAMEORIGIN) prevents your page from being embedded in an iframe, which is how clickjacking attacks work. CSP frame-ancestors also helps.'
      },
      {
        q: 'When should you use the Client Credentials OAuth flow?',
        options: ['Single Page Applications', 'Mobile apps', 'Machine-to-machine (no user involved)', 'Traditional web apps'],
        correct: 2,
        explain: 'Client Credentials is for M2M communication (microservices, cron jobs, backend-to-backend). There\'s no user to authenticate ‚Äî the application itself is the "user".'
      },
      {
        q: 'What is the "alg: none" attack on JWT?',
        options: ['Setting algorithm to "none" bypasses signature verification', 'It encrypts the JWT', 'It compresses the token', 'It\'s a valid way to create unsigned tokens'],
        correct: 0,
        explain: 'Some JWT libraries accept alg:"none" which means no signature is required. An attacker can modify the payload and set alg to none, bypassing all security. Always reject unsigned tokens and specify allowed algorithms.'
      },
      {
        q: 'What bcrypt cost factor should you use in production?',
        options: ['1 (fastest)', '4-6', '10-12', '30+ (maximum security)'],
        correct: 2,
        explain: 'Cost factor 10-12 provides good security (each increment doubles the time). Too low is insecure, too high (30+) would take minutes per hash and block the event loop.'
      },
      {
        q: 'You see: Set-Cookie: session=abc; HttpOnly; Secure. What\'s missing?',
        options: ['Nothing, this is perfect', 'SameSite attribute for CSRF protection', 'The Encrypted flag', 'The HttpsOnly flag'],
        correct: 1,
        explain: 'The SameSite attribute is missing. Without it, the cookie can be sent in cross-origin requests, making it vulnerable to CSRF attacks. Add SameSite=Strict or SameSite=Lax.'
      },
      {
        q: 'What is refresh token rotation?',
        options: ['Changing the refresh token format', 'Issuing a new refresh token each time one is used (old one is invalidated)', 'Sending refresh tokens to multiple servers', 'Using multiple refresh tokens simultaneously'],
        correct: 1,
        explain: 'Each time a refresh token is used, a new one is issued and the old one is invalidated. If an attacker steals and uses a refresh token, the legitimate user\'s next attempt reveals the breach.'
      }
    ])}
  </div>

  <div id="finalQuizResult"></div>

  <div style="text-align:center;padding:20px">
    <button class="btn btn-primary" id="finalQuizSubmit" onclick="submitQuiz('final', 10)">Submit Final Quiz</button>
  </div>
</div>

<div class="card animate-in" id="completionCard" style="display:none;text-align:center">
  <h2>üéä Congratulations!</h2>
  <div style="font-size:4rem;margin:20px 0">üèÜ</div>
  <p style="font-size:1.2rem">You've completed the Authentication & Authorization Mastery course!</p>
  <div style="margin:20px 0">
    <div style="font-size:2rem;font-weight:800;background:var(--gradient);-webkit-background-clip:text;-webkit-text-fill-color:transparent">${state.xp} XP Earned</div>
  </div>
  <p style="color:var(--text2)">You now understand JWT, OAuth 2.0, password hashing, and session management at a level ready for competitive interviews. Keep practicing!</p>
</div>
`;

// ============================================================
// QUIZ GENERATOR
// ============================================================
function generateQuiz(quizId, questions) {
  return questions.map((q, i) => `
    <div class="quiz-q" id="${quizId}_q${i}">
      <h4><span class="q-num">Q${i + 1}.</span> ${q.q}</h4>
      ${q.options.map((opt, j) => `
        <label class="quiz-option" id="${quizId}_q${i}_o${j}" onclick="selectQuizOption('${quizId}', ${i}, ${j})">
          <input type="radio" name="${quizId}_q${i}" value="${j}">
          ${escapeHtml(opt)}
        </label>
      `).join('')}
      <div class="quiz-explain" id="${quizId}_q${i}_explain">${q.explain}</div>
    </div>
  `).join('');
}

function selectQuizOption(quizId, qIdx, optIdx) {
  // Deselect all options in this question
  document.querySelectorAll(`[id^="${quizId}_q${qIdx}_o"]`).forEach(el => {
    el.classList.remove('selected');
  });
  document.getElementById(`${quizId}_q${qIdx}_o${optIdx}`).classList.add('selected');
  
  if (!state.quizAnswers[quizId]) state.quizAnswers[quizId] = {};
  state.quizAnswers[quizId][qIdx] = optIdx;
}

function submitQuiz(quizId, totalQs) {
  const answers = state.quizAnswers[quizId] || {};
  const quizData = getQuizData(quizId);
  let correct = 0;
  
  for (let i = 0; i < totalQs; i++) {
    const userAnswer = answers[i];
    const correctAnswer = quizData[i].correct;
    
    document.querySelectorAll(`[id^="${quizId}_q${i}_o"]`).forEach(el => {
      el.style.pointerEvents = 'none';
    });
    
    if (userAnswer !== undefined) {
      if (userAnswer === correctAnswer) {
        document.getElementById(`${quizId}_q${i}_o${userAnswer}`).classList.add('correct');
        correct++;
      } else {
        document.getElementById(`${quizId}_q${i}_o${userAnswer}`).classList.add('wrong');
        document.getElementById(`${quizId}_q${i}_o${correctAnswer}`).classList.add('correct');
      }
    } else {
      document.getElementById(`${quizId}_q${i}_o${correctAnswer}`).classList.add('correct');
    }
    
    document.getElementById(`${quizId}_q${i}_explain`).classList.add('show');
  }
  
  const pct = Math.round((correct / totalQs) * 100);
  const resultEl = document.getElementById(`${quizId}QuizResult`);
  resultEl.innerHTML = `
    <div class="quiz-score">
      <div class="score-num">${correct}/${totalQs}</div>
      <p>${pct >= 80 ? 'üéâ Excellent!' : pct >= 60 ? 'üëç Good job!' : 'üìö Review the material and try again'} ‚Äî ${pct}% correct</p>
    </div>
  `;
  
  document.getElementById(`${quizId}QuizSubmit`).style.display = 'none';
  const nextBtn = document.getElementById(`${quizId}QuizNext`);
  if (nextBtn) nextBtn.style.display = 'inline-flex';
  
  if (pct >= 60) {
    markComplete(`${quizId}-quiz`);
  }
  
  if (quizId === 'final' && pct >= 60) {
    markComplete('final-challenge');
    const card = document.getElementById('completionCard');
    if (card) card.style.display = 'block';
  }
}

function getQuizData(quizId) {
  const data = {
        jwt: [
      {
        q: 'What are the three parts of a JWT?',
        options: ['Username, Password, Token', 'Header, Payload, Signature', 'Key, Value, Hash', 'Public Key, Private Key, Certificate'],
        correct: 1,
        explain: 'A JWT consists of Header (algorithm & type), Payload (claims/data), and Signature (verification hash), separated by dots.'
      },
      {
        q: 'Which method should you use to validate a JWT on the server?',
        options: ['jwt.decode()', 'jwt.parse()', 'jwt.verify()', 'JSON.parse()'],
        correct: 2,
        explain: 'jwt.verify() validates the signature and checks claims. jwt.decode() only reads the payload WITHOUT checking the signature ‚Äî never use it for authentication!'
      },
      {
        q: 'Why is storing JWTs in localStorage considered insecure?',
        options: ['It\'s too slow', 'Vulnerable to XSS ‚Äî any JS on the page can read it', 'It can\'t store strings', 'The data expires automatically'],
        correct: 1,
        explain: 'localStorage is accessible by any JavaScript running on the page. If an attacker injects a script (XSS), they can steal the token. Use httpOnly cookies or in-memory storage instead.'
      },
      {
        q: 'What is the "algorithm confusion" attack?',
        options: ['Using too many algorithms', 'Switching from RS256 to HS256, using the public key as the HMAC secret', 'Encrypting instead of signing', 'Using SHA-1 instead of SHA-256'],
        correct: 1,
        explain: 'If you don\'t specify the expected algorithm in verify(), an attacker can change the header to HS256 and sign with the known public key. Always specify {algorithms: ["RS256"]} in verify options.'
      },
      {
        q: 'What is the recommended expiration time for an access token?',
        options: ['1 year', '30 days', '5-15 minutes', 'Never expires'],
        correct: 2,
        explain: 'Access tokens should be short-lived (5-15 minutes) to minimize the window of attack. Use refresh tokens (stored securely) to get new access tokens.'
      },
      {
        q: 'Can the payload of a JWT be read without the secret key?',
        options: ['No, it\'s fully encrypted', 'Yes, it\'s only base64-encoded', 'Only if you have the public key', 'Only on the server'],
        correct: 1,
        explain: 'JWT payloads are base64url-encoded, NOT encrypted. Anyone can decode and read them. The signature only prevents tampering, not reading. Never put secrets in the payload!'
      },
      {
        q: 'What is the purpose of a refresh token?',
        options: ['To refresh the page', 'To get a new access token without re-authenticating', 'To update user profile', 'To clear the session'],
        correct: 1,
        explain: 'Refresh tokens are long-lived tokens used to obtain new access tokens when they expire, without requiring the user to log in again. They should be stored in httpOnly cookies and rotated on use.'
      },
      {
        q: 'Which JWT claim indicates when the token expires?',
        options: ['iss', 'sub', 'exp', 'aud'],
        correct: 2,
        explain: 'exp (expiration time) is a registered claim indicating when the token should no longer be accepted. iss = issuer, sub = subject, aud = audience.'
      }
    ],
    oauth: [
      {
        q: 'What is the primary purpose of OAuth 2.0?',
        options: ['Authentication (verify identity)', 'Authorization (delegate access)', 'Encryption', 'Password management'],
        correct: 1,
        explain: 'OAuth 2.0 is an authorization framework. It allows users to grant third-party apps limited access to their resources without sharing passwords. OpenID Connect adds authentication on top.'
      },
      {
        q: 'What does PKCE protect against?',
        options: ['SQL injection', 'Authorization code interception', 'Password brute force', 'DDoS attacks'],
        correct: 1,
        explain: 'PKCE (Proof Key for Code Exchange) prevents attackers from exchanging a stolen authorization code for tokens. The code_verifier proves the app that requests the token is the same one that started the flow.'
      },
      {
        q: 'Why is the Implicit flow deprecated?',
        options: ['It\'s too slow', 'Tokens are exposed in the URL fragment', 'It requires a backend', 'It doesn\'t support refresh tokens'],
        correct: 1,
        explain: 'The Implicit flow returns tokens directly in the URL fragment (#access_token=...), making them visible in browser history and vulnerable to interception. Use Auth Code + PKCE instead.'
      },
      {
        q: 'What is the purpose of the "state" parameter in OAuth?',
        options: ['Store user location', 'CSRF protection', 'Indicate the US state', 'Store session data'],
        correct: 1,
        explain: 'The state parameter is a random value that must be verified on the callback to prevent Cross-Site Request Forgery attacks. Always use it!'
      },
      {
        q: 'Which grant type is best for machine-to-machine communication?',
        options: ['Authorization Code', 'Implicit', 'Client Credentials', 'Device Code'],
        correct: 2,
        explain: 'Client Credentials is designed for M2M communication where no user is involved. The application authenticates with its own credentials (client_id + client_secret).'
      },
      {
        q: 'Where should you exchange the authorization code for tokens?',
        options: ['In the browser (client-side)', 'On your backend server', 'In localStorage', 'In the URL'],
        correct: 1,
        explain: 'The token exchange should happen on your backend to keep the client_secret secure. Never expose your client_secret in client-side code.'
      }
    ],
    password: [
      {
        q: 'Why is SHA-256 alone NOT suitable for password hashing?',
        options: ['It produces too long a hash', 'It\'s too fast ‚Äî makes brute force easy', 'It\'s broken/insecure', 'It requires too much memory'],
        correct: 1,
        explain: 'SHA-256 is designed to be fast (5 billion hashes/sec on GPU). For passwords, you want slowness. bcrypt/Argon2 are intentionally slow to make brute force impractical.'
      },
      {
        q: 'What is the purpose of a salt in password hashing?',
        options: ['Encrypt the password', 'Make identical passwords produce different hashes', 'Speed up the hashing process', 'Replace the need for a strong password'],
        correct: 1,
        explain: 'A salt is a random value unique to each user. It ensures that two users with the same password have completely different hashes, defeating rainbow table attacks.'
      },
      {
        q: 'Which is currently considered the gold standard for password hashing?',
        options: ['MD5', 'SHA-256 with salt', 'bcrypt', 'Argon2id'],
        correct: 3,
        explain: 'Argon2id (winner of the Password Hashing Competition 2015) is memory-hard and GPU/ASIC-resistant. bcrypt is also excellent and widely supported. Both are good choices.'
      },
      {
        q: 'What should the error message say when login fails?',
        options: ['"Password is incorrect"', '"User not found"', '"Invalid credentials"', '"Your password is wrong for user X"'],
        correct: 2,
        explain: 'Always use a generic message like "Invalid credentials." Specific messages like "user not found" or "wrong password" help attackers enumerate valid usernames.'
      },
      {
        q: 'Is the salt value a secret?',
        options: ['Yes, it must be encrypted', 'No, it\'s stored alongside the hash', 'Yes, it should be in an env variable', 'It depends on the algorithm'],
        correct: 1,
        explain: 'Salts are NOT secret. They\'re stored in the database alongside the hash. Their purpose is to ensure uniqueness, not secrecy. bcrypt even embeds the salt directly in the hash string.'
      },
      {
        q: 'What is the difference between hashing and encryption?',
        options: ['They\'re the same thing', 'Hashing is reversible, encryption is not', 'Hashing is one-way, encryption is two-way (reversible)', 'Encryption is faster'],
        correct: 2,
        explain: 'Hashing is a one-way function ‚Äî you cannot recover the original input. Encryption is two-way ‚Äî with the key, you can decrypt and get the original data back. Passwords should be HASHED, never encrypted.'
      }
    ],
    session: [
      {
        q: 'What does the HttpOnly cookie flag do?',
        options: ['Makes the cookie HTTP-only (not HTTPS)', 'Prevents JavaScript from accessing the cookie', 'Makes the cookie expire after the browser closes', 'Encrypts the cookie value'],
        correct: 1,
        explain: 'HttpOnly prevents client-side JavaScript (document.cookie) from reading the cookie. This protects session tokens from XSS attacks.'
      },
      {
        q: 'What is session fixation?',
        options: ['When a session expires', 'Attacker sets a known session ID before user logs in', 'When the server runs out of memory', 'Using fixed session timeouts'],
        correct: 1,
        explain: 'In session fixation, the attacker sets a session ID (e.g., via URL parameter) before the victim logs in. After login, the attacker uses that same session ID. Fix: regenerate session ID after authentication.'
      },
      {
        q: 'What SameSite cookie value provides the best CSRF protection?',
        options: ['None', 'Lax', 'Strict', 'Secure'],
        correct: 2,
        explain: 'SameSite=Strict never sends the cookie in cross-origin requests. SameSite=Lax allows it on top-level navigations (clicking links). For auth cookies, Strict is safest.'
      },
      {
        q: 'Why should you regenerate the session ID after login?',
        options: ['To improve performance', 'To prevent session fixation attacks', 'Because the old one expires', 'To change the cookie name'],
        correct: 1,
        explain: 'Regenerating the session ID after login ensures that any pre-authentication session ID (potentially set by an attacker) is replaced with a new, secure one.'
      },
      {
        q: 'For a SPA with a separate API, what\'s the best token storage strategy?',
        options: ['localStorage for all tokens', 'Access token in memory, refresh token in httpOnly cookie', 'Both tokens in sessionStorage', 'Tokens in URL parameters'],
        correct: 1,
        explain: 'Access tokens in memory (JS variable) are safe from XSS. Refresh tokens in httpOnly cookies are safe from both XSS and CSRF (with SameSite). This is the current best practice for SPAs.'
      },
      {
        q: 'What is CSRF (Cross-Site Request Forgery)?',
        options: ['Injecting scripts into a page', 'Tricking a user\'s browser into making authenticated requests to another site', 'Guessing session IDs', 'Man-in-the-middle attack'],
        correct: 1,
        explain: 'CSRF tricks the user\'s browser into sending an authenticated request to your server (e.g., via a hidden form on a malicious page). The browser automatically includes cookies, so the server thinks it\'s a legitimate request.'
      }
    ],
    final: [
      {
        q: 'You need to build auth for a React SPA with a Node.js API. What\'s the best approach?',
        options: ['Store JWT in localStorage, send in Authorization header', 'Access token in memory + refresh token in httpOnly cookie', 'Session cookie with express-session only', 'Store everything in sessionStorage'],
        correct: 1,
        explain: 'For SPAs: access token in memory (safe from XSS), refresh token in httpOnly cookie (safe from XSS+CSRF). This is the current best practice pattern.'
      },
      {
        q: 'An attacker intercepts the OAuth authorization code. What prevents them from using it?',
        options: ['The code expires after 1 hour', 'PKCE ‚Äî they don\'t have the code_verifier', 'The code is encrypted', 'Nothing, they can use it freely'],
        correct: 1,
        explain: 'PKCE requires the code_verifier (only known to the original client) when exchanging the code for tokens. Without it, the authorization server rejects the request.'
      },
      {
        q: 'What\'s wrong with: if (password === storedPassword) { ... }',
        options: ['=== should be ==', 'Comparing plain text passwords ‚Äî should compare hashes', 'Nothing, this is correct', 'Should use .equals() method'],
        correct: 1,
        explain: 'This compares plain text passwords, meaning passwords are stored in plain text. Should be: await bcrypt.compare(password, storedHash)'
      },
      {
        q: 'A JWT has exp set to 30 days. What\'s the problem?',
        options: ['30 days is too short', 'If the token is stolen, attacker has access for 30 days', 'JWTs can\'t have exp over 24 hours', 'Nothing, this is fine'],
        correct: 1,
        explain: 'JWTs are hard to revoke. A 30-day access token means a stolen token provides unauthorized access for up to 30 days. Use 5-15 minute access tokens with refresh token rotation.'
      },
      {
        q: 'Which header protects against clickjacking?',
        options: ['Content-Security-Policy', 'X-Frame-Options', 'Strict-Transport-Security', 'X-Content-Type-Options'],
        correct: 1,
        explain: 'X-Frame-Options: DENY (or SAMEORIGIN) prevents your page from being embedded in an iframe, which is how clickjacking attacks work. CSP frame-ancestors also helps.'
      },
      {
        q: 'When should you use the Client Credentials OAuth flow?',
        options: ['Single Page Applications', 'Mobile apps', 'Machine-to-machine (no user involved)', 'Traditional web apps'],
        correct: 2,
        explain: 'Client Credentials is for M2M communication (microservices, cron jobs, backend-to-backend). There\'s no user to authenticate ‚Äî the application itself is the "user".'
      },
      {
        q: 'What is the "alg: none" attack on JWT?',
        options: ['Setting algorithm to "none" bypasses signature verification', 'It encrypts the JWT', 'It compresses the token', 'It\'s a valid way to create unsigned tokens'],
        correct: 0,
        explain: 'Some JWT libraries accept alg:"none" which means no signature is required. An attacker can modify the payload and set alg to none, bypassing all security. Always reject unsigned tokens and specify allowed algorithms.'
      },
      {
        q: 'What bcrypt cost factor should you use in production?',
        options: ['1 (fastest)', '4-6', '10-12', '30+ (maximum security)'],
        correct: 2,
        explain: 'Cost factor 10-12 provides good security (each increment doubles the time). Too low is insecure, too high (30+) would take minutes per hash and block the event loop.'
      },
      {
        q: 'You see: Set-Cookie: session=abc; HttpOnly; Secure. What\'s missing?',
        options: ['Nothing, this is perfect', 'SameSite attribute for CSRF protection', 'The Encrypted flag', 'The HttpsOnly flag'],
        correct: 1,
        explain: 'The SameSite attribute is missing. Without it, the cookie can be sent in cross-origin requests, making it vulnerable to CSRF attacks. Add SameSite=Strict or SameSite=Lax.'
      },
      {
        q: 'What is refresh token rotation?',
        options: ['Changing the refresh token format', 'Issuing a new refresh token each time one is used (old one is invalidated)', 'Sending refresh tokens to multiple servers', 'Using multiple refresh tokens simultaneously'],
        correct: 1,
        explain: 'Each time a refresh token is used, a new one is issued and the old one is invalidated. If an attacker steals and uses a refresh token, the legitimate user\'s next attempt reveals the breach.'
      }
    ]
  };
  return data[quizId] || [];
}

// ============================================================
// UI & INTERACTIVE FUNCTIONS
// ============================================================

function toggleSidebar() {
  document.getElementById('sidebar').classList.toggle('open');
}

function animateFlow(flowId) {
  const flow = document.getElementById(flowId);
  if (!flow) return;
  const steps = flow.querySelectorAll('.flow-step');
  let i = 0;
  steps.forEach(step => step.classList.remove('active', 'done'));
  const interval = setInterval(() => {
    if (i >= steps.length) {
      clearInterval(interval);
      return;
    }
    if (i > 0) steps[i-1].classList.remove('active');
    steps[i].classList.add('active');
    i++;
  }, 800);
}

function resetFlow(flowId) {
  const flow = document.getElementById(flowId);
  if (!flow) return;
  flow.querySelectorAll('.flow-step').forEach(step => {
    step.classList.remove('active', 'done');
  });
  const first = flow.querySelector('.flow-step:first-child');
  if (first) first.classList.add('active');
}

function switchTab(tabEl, contentId) {
  // Remove active from all tabs in the same container
  const tabs = tabEl.parentElement.querySelectorAll('.tab');
  tabs.forEach(t => t.classList.remove('active'));
  tabEl.classList.add('active');
  
  // Hide all tab contents in the same container
  const contents = tabEl.parentElement.parentElement.querySelectorAll('.tab-content');
  contents.forEach(c => c.classList.remove('active'));
  document.getElementById(contentId).classList.add('active');
}

// ============================================================
// JWT LAB FUNCTIONS
// ============================================================
let currentJWT = '';

async function buildJWT() {
  const headerInput = document.getElementById('jwtHeader')?.value;
  const payloadInput = document.getElementById('jwtPayload')?.value;
  const secret = document.getElementById('jwtSecret')?.value || '';
  
  if (!headerInput || !payloadInput) return;
  
  try {
    const header = JSON.parse(headerInput);
    const payload = JSON.parse(payloadInput);
    const encHeader = b64urlEncode(JSON.stringify(header));
    const encPayload = b64urlEncode(JSON.stringify(payload));
    const message = encHeader + '.' + encPayload;
    
    let signature = '';
    if (header.alg === 'HS256' && secret) {
      const key = await crypto.subtle.importKey(
        'raw',
        new TextEncoder().encode(secret),
        { name: 'HMAC', hash: 'SHA-256' },
        false,
        ['sign']
      );
      const sigBuffer = await crypto.subtle.sign('HMAC', key, new TextEncoder().encode(message));
      signature = b64urlEncode(new Uint8Array(sigBuffer));
    } else {
      signature = '[signature not generated]';
    }
    
    currentJWT = message + '.' + signature;
    const output = document.getElementById('jwtOutput');
    if (output) output.innerHTML = `<span class="jwt-header">${encHeader}</span><span class="jwt-dot">.</span><span class="jwt-payload">${encPayload}</span><span class="jwt-dot">.</span><span class="jwt-signature">${signature}</span>`;
    
    // Show decoded parts
    const partsDiv = document.getElementById('jwtParts');
    if (partsDiv) {
      partsDiv.innerHTML = `
        <div class="demo-row">
          <div><span class="demo-label">Header decoded:</span><pre style="font-size:.75rem;background:var(--bg);padding:8px;border-radius:6px">${escapeHtml(JSON.stringify(header, null, 2))}</pre></div>
          <div><span class="demo-label">Payload decoded:</span><pre style="font-size:.75rem;background:var(--bg);padding:8px;border-radius:6px">${escapeHtml(JSON.stringify(payload, null, 2))}</pre></div>
        </div>
      `;
    }
  } catch (e) {
    document.getElementById('jwtOutput').innerHTML = `<span style="color:var(--error)">Invalid JSON: ${e.message}</span>`;
  }
}

function copyJWT() {
  if (currentJWT) {
    navigator.clipboard.writeText(currentJWT).then(() => {
      showNotification('JWT copied to clipboard!', '');
    });
  }
}

function decodeJWT() {
  const input = document.getElementById('jwtDecodeInput')?.value;
  const output = document.getElementById('jwtDecodeOutput');
  if (!input || !output) return;
  
  const parts = input.split('.');
  if (parts.length !== 3) {
    output.innerHTML = '<span style="color:var(--error)">Invalid JWT format (must have 3 parts separated by dots)</span>';
    return;
  }
  
  try {
    const headerJson = b64urlDecode(parts[0]);
    const payloadJson = b64urlDecode(parts[1]);
    const header = JSON.parse(headerJson);
    const payload = JSON.parse(payloadJson);
    output.innerHTML = `
      <div class="demo-row">
        <div>
          <span class="demo-label">Header:</span>
          <pre style="font-size:.75rem;background:var(--bg);padding:8px;border-radius:6px">${escapeHtml(JSON.stringify(header, null, 2))}</pre>
        </div>
        <div>
          <span class="demo-label">Payload:</span>
          <pre style="font-size:.75rem;background:var(--bg);padding:8px;border-radius:6px">${escapeHtml(JSON.stringify(payload, null, 2))}</pre>
        </div>
      </div>
      <div class="demo-label">Signature (base64url):</div>
      <div class="demo-output" style="font-size:.7rem;word-break:break-all">${escapeHtml(parts[2])}</div>
    `;
  } catch (e) {
    output.innerHTML = `<span style="color:var(--error)">Decoding error: ${e.message}</span>`;
  }
}

// ============================================================
// PKCE GENERATOR
// ============================================================
async function generatePKCE() {
  const verifier = generateCodeVerifier();
  const challenge = await generateCodeChallenge(verifier);
  
  document.getElementById('pkceOutput').style.display = 'block';
  document.getElementById('pkceVerifier').textContent = verifier;
  document.getElementById('pkceChallenge').textContent = challenge;
  
  const urlParams = new URLSearchParams({
    response_type: 'code',
    client_id: 'YOUR_CLIENT_ID',
    redirect_uri: 'https://yourapp.com/callback',
    scope: 'openid profile email',
    code_challenge: challenge,
    code_challenge_method: 'S256',
    state: crypto.randomUUID()
  });
  document.getElementById('pkceUrl').textContent = `https://auth.provider.com/authorize?${urlParams}`;
}

function generateCodeVerifier() {
  const array = new Uint8Array(32);
  crypto.getRandomValues(array);
  return b64urlEncode(array);
}

async function generateCodeChallenge(verifier) {
  const enc = new TextEncoder();
  const digest = await crypto.subtle.digest('SHA-256', enc.encode(verifier));
  return b64urlEncode(new Uint8Array(digest));
}

// ============================================================
// PASSWORD LAB FUNCTIONS
// ============================================================
async function liveHash() {
  const input = document.getElementById('hashInput')?.value || '';
  const hashOutput = document.getElementById('hashOutput');
  const grid = document.getElementById('hashGrid');
  const props = document.getElementById('hashProperties');
  
  if (!hashOutput || !grid || !props) return;
  
  const hash = await sha256(input);
  hashOutput.textContent = hash;
  
  // Visual grid: first 16 bytes as color cells
  const bytes = hash.match(/.{2}/g).slice(0,16).map(h => parseInt(h,16));
  grid.innerHTML = bytes.map(b => {
    const hue = (b / 255) * 360;
    return `<div class="hash-cell" style="background:hsl(${hue},80%,50%)" title="${b}"></div>`;
  }).join('');
  
  props.innerHTML = `
    <span class="badge" style="background:rgba(0,212,255,.1)">Length: ${hash.length} characters / ${hash.length/2} bytes</span>
    <span class="badge" style="background:rgba(0,212,255,.1)">Avalanche effect: changing 1 bit changes ~50% of output</span>
  `;
}

async function showSalting() {
  const password = document.getElementById('saltPassword')?.value || 'password123';
  const output = document.getElementById('saltOutput');
  if (!output) return;
  
  const salts = [];
  for (let i = 0; i < 3; i++) {
    const salt = Array.from(crypto.getRandomValues(new Uint8Array(8))).map(b => b.toString(16).padStart(2,'0')).join('');
    const hash = await sha256(salt + password);
    salts.push({salt, hash});
  }
  
  output.innerHTML = salts.map((s, i) => `
    <div style="margin-bottom:16px;background:var(--surface);padding:12px;border-radius:8px">
      <div><span class="demo-label">Salt ${i+1}:</span> <span style="color:var(--accent)">${s.salt}</span></div>
      <div><span class="demo-label">Hash ${i+1}:</span> <span style="font-family:monospace;font-size:.8rem;word-break:break-all">${s.hash}</span></div>
    </div>
  `).join('');
}

// ============================================================
// COOKIE & STORAGE FUNCTIONS
// ============================================================
function setCookie() {
  const name = document.getElementById('cookieName')?.value;
  const value = document.getElementById('cookieValue')?.value;
  if (name && value) {
    document.cookie = `${encodeURIComponent(name)}=${encodeURIComponent(value)}; path=/; max-age=3600`;
    readCookies();
  }
}

function readCookies() {
  const output = document.getElementById('cookieOutput');
  if (!output) return;
  const cookies = document.cookie.split(';').map(c => c.trim()).filter(c => c);
  if (cookies.length === 0) {
    output.innerHTML = '<span style="color:var(--text2)">No cookies set</span>';
  } else {
    output.innerHTML = cookies.map(c => {
      const [name, ...rest] = c.split('=');
      const val = rest.join('=');
      return `<div><span style="color:var(--accent)">${escapeHtml(name)}</span>=<span style="color:var(--success)">${escapeHtml(val)}</span></div>`;
    }).join('');
  }
}

function clearAllCookies() {
  document.cookie.split(';').forEach(c => {
    const eqPos = c.indexOf('=');
    const name = eqPos > -1 ? c.substr(0, eqPos).trim() : c.trim();
    document.cookie = name + '=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/';
  });
  readCookies();
}

function setStorage(type) {
  const key = document.getElementById('storageKey')?.value;
  const value = document.getElementById('storageValue')?.value;
  if (!key) return;
  if (type === 'local') {
    localStorage.setItem(key, value);
  } else {
    sessionStorage.setItem(key, value);
  }
  readStorage();
}

function readStorage() {
  const localOut = document.getElementById('localStorageOutput');
  const sessionOut = document.getElementById('sessionStorageOutput');
  if (localOut) {
    const items = [];
    for (let i = 0; i < localStorage.length; i++) {
      const k = localStorage.key(i);
      items.push(`<div><span style="color:var(--accent)">${escapeHtml(k)}</span>=<span style="color:var(--success)">${escapeHtml(localStorage.getItem(k).substring(0,30))}${localStorage.getItem(k).length > 30 ? '‚Ä¶' : ''}</span></div>`);
    }
    localOut.innerHTML = items.length ? items.join('') : '<span style="color:var(--text2)">Empty</span>';
  }
  if (sessionOut) {
    const items = [];
    for (let i = 0; i < sessionStorage.length; i++) {
      const k = sessionStorage.key(i);
      items.push(`<div><span style="color:var(--accent)">${escapeHtml(k)}</span>=<span style="color:var(--success)">${escapeHtml(sessionStorage.getItem(k).substring(0,30))}${sessionStorage.getItem(k).length > 30 ? '‚Ä¶' : ''}</span></div>`);
    }
    sessionOut.innerHTML = items.length ? items.join('') : '<span style="color:var(--text2)">Empty</span>';
  }
}

function clearStorage() {
  localStorage.clear();
  sessionStorage.clear();
  readStorage();
}

function simulateXSS() {
  const output = document.getElementById('xssOutput');
  if (!output) return;
  
  // Simulate stealing tokens from localStorage
  const localData = [];
  for (let i = 0; i < localStorage.length; i++) {
    localData.push(`${localStorage.key(i)}: ${localStorage.getItem(localStorage.key(i))}`);
  }
  const sessionData = [];
  for (let i = 0; i < sessionStorage.length; i++) {
    sessionData.push(`${sessionStorage.key(i)}: ${sessionStorage.getItem(sessionStorage.key(i))}`);
  }
  
  output.innerHTML = `
    <div style="margin-bottom:10px"><strong style="color:var(--error)">‚ùå XSS Attack Simulation</strong></div>
    <div style="background:rgba(239,68,68,.1);padding:10px;border-radius:6px">
      <div><span style="color:var(--warn)">localStorage stolen:</span> ${localData.length ? localData.join('<br>') : 'None (safe)'}</div>
      <div><span style="color:var(--warn)">sessionStorage stolen:</span> ${sessionData.length ? sessionData.join('<br>') : 'None (safe)'}</div>
      <div><span style="color:var(--success)">HttpOnly cookies are safe from JavaScript (can't be accessed)</span></div>
    </div>
  `;
}

// ============================================================
// PASSWORD STRENGTH CHECKER
// ============================================================
function checkPasswordStrength() {
  const pwd = document.getElementById('strengthInput')?.value || '';
  const reqLength = document.getElementById('req-length');
  const reqUpper = document.getElementById('req-upper');
  const reqLower = document.getElementById('req-lower');
  const reqNumber = document.getElementById('req-number');
  const reqSpecial = document.getElementById('req-special');
  const reqNoCommon = document.getElementById('req-nocommon');
  
  const lengthOk = pwd.length >= 12;
  const upperOk = /[A-Z]/.test(pwd);
  const lowerOk = /[a-z]/.test(pwd);
  const numberOk = /[0-9]/.test(pwd);
  const specialOk = /[!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?]/.test(pwd);
  const commonPasswords = ['password', '123456', 'qwerty', 'abc123', 'letmein', 'monkey', 'dragon', '111111', 'password123'];
  const noCommonOk = !commonPasswords.includes(pwd.toLowerCase());
  
  updateChecklistItem(reqLength, lengthOk);
  updateChecklistItem(reqUpper, upperOk);
  updateChecklistItem(reqLower, lowerOk);
  updateChecklistItem(reqNumber, numberOk);
  updateChecklistItem(reqSpecial, specialOk);
  updateChecklistItem(reqNoCommon, noCommonOk);
  
  const strengthEl = document.getElementById('strengthResult');
  if (!strengthEl) return;
  
  const totalOk = [lengthOk, upperOk, lowerOk, numberOk, specialOk, noCommonOk].filter(Boolean).length;
  if (totalOk >= 6) {
    strengthEl.innerHTML = '<div class="tip"><h4>‚úÖ Strong Password</h4><p>Meets all requirements.</p></div>';
  } else if (totalOk >= 4) {
    strengthEl.innerHTML = '<div class="warn"><h4>‚ö†Ô∏è Medium Password</h4><p>Could be stronger. Aim for all criteria.</p></div>';
  } else {
    strengthEl.innerHTML = '<div class="pitfall"><h4>üö´ Weak Password</h4><p>Add length, uppercase, numbers, and special characters.</p></div>';
  }
}

function updateChecklistItem(el, condition) {
  if (!el) return;
  if (condition) {
    el.classList.add('checked');
    const box = el.querySelector('.check-box');
    if (box) box.textContent = '‚úì';
  } else {
    el.classList.remove('checked');
    const box = el.querySelector('.check-box');
    if (box) box.textContent = '';
  }
}

// ============================================================
// INITIALIZATION
// ============================================================
window.onload = function() {
  loadState();
  navigate(state.currentPage); // start on dashboard
  // Setup global event listeners if needed
  // For checklist items, ensure they reflect completion state
  // For flow animations, start any if on page
};

// ============================================================
// CLOSE SCRIPT TAG AND HTML
// ============================================================
</script>
</body>
</html>