<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>WebAssembly Mastery - Interactive Learning</title>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg-primary: #0a0e1a;
  --bg-secondary: #111827;
  --bg-card: #1a2236;
  --bg-code: #0d1117;
  --accent: #654ff0;
  --accent-light: #8b7bf7;
  --accent-glow: rgba(101, 79, 240, 0.3);
  --green: #10b981;
  --green-glow: rgba(16, 185, 129, 0.3);
  --red: #ef4444;
  --red-glow: rgba(239, 68, 68, 0.3);
  --yellow: #f59e0b;
  --yellow-glow: rgba(245, 158, 11, 0.3);
  --blue: #3b82f6;
  --text-primary: #e2e8f0;
  --text-secondary: #94a3b8;
  --text-muted: #64748b;
  --border: #1e293b;
  --border-light: #334155;
}

body {
  font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
  background: var(--bg-primary);
  color: var(--text-primary);
  line-height: 1.7;
  min-height: 100vh;
}

/* Scrollbar */
::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: var(--bg-secondary); }
::-webkit-scrollbar-thumb { background: var(--accent); border-radius: 3px; }

/* Header */
.header {
  background: linear-gradient(135deg, var(--bg-secondary), var(--bg-card));
  border-bottom: 1px solid var(--border);
  padding: 1rem 2rem;
  position: sticky;
  top: 0;
  z-index: 100;
  backdrop-filter: blur(10px);
}

.header-inner {
  max-width: 1400px;
  margin: 0 auto;
  display: flex;
  align-items: center;
  justify-content: space-between;
  flex-wrap: wrap;
  gap: 1rem;
}

.logo {
  display: flex;
  align-items: center;
  gap: 0.75rem;
}

.logo-icon {
  width: 40px;
  height: 40px;
  background: linear-gradient(135deg, var(--accent), #8b5cf6);
  border-radius: 10px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.2rem;
  font-weight: 900;
  color: white;
}

.logo h1 {
  font-size: 1.3rem;
  background: linear-gradient(135deg, var(--accent-light), #c084fc);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

.progress-bar-container {
  flex: 1;
  max-width: 400px;
  min-width: 200px;
}

.progress-label {
  font-size: 0.75rem;
  color: var(--text-muted);
  margin-bottom: 4px;
  display: flex;
  justify-content: space-between;
}

.progress-bar {
  height: 8px;
  background: var(--bg-primary);
  border-radius: 4px;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  background: linear-gradient(90deg, var(--accent), var(--green));
  border-radius: 4px;
  transition: width 0.5s ease;
  width: 0%;
}

.stats {
  display: flex;
  gap: 1.5rem;
}

.stat {
  text-align: center;
}

.stat-value {
  font-size: 1.2rem;
  font-weight: 700;
  color: var(--accent-light);
}

.stat-label {
  font-size: 0.65rem;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

/* Navigation */
.nav {
  background: var(--bg-secondary);
  border-bottom: 1px solid var(--border);
  padding: 0 2rem;
  overflow-x: auto;
}

.nav-inner {
  max-width: 1400px;
  margin: 0 auto;
  display: flex;
  gap: 0;
}

.nav-tab {
  padding: 0.875rem 1.25rem;
  background: none;
  border: none;
  color: var(--text-muted);
  cursor: pointer;
  font-size: 0.85rem;
  font-weight: 500;
  white-space: nowrap;
  border-bottom: 2px solid transparent;
  transition: all 0.3s;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.nav-tab:hover {
  color: var(--text-primary);
  background: rgba(101, 79, 240, 0.05);
}

.nav-tab.active {
  color: var(--accent-light);
  border-bottom-color: var(--accent);
  background: rgba(101, 79, 240, 0.1);
}

.nav-tab .tab-icon { font-size: 1rem; }

.nav-tab .tab-badge {
  background: var(--accent);
  color: white;
  font-size: 0.65rem;
  padding: 1px 6px;
  border-radius: 10px;
  font-weight: 700;
}

/* Main Content */
.main {
  max-width: 1400px;
  margin: 0 auto;
  padding: 2rem;
}

.section { display: none; }
.section.active { display: block; }

/* Cards */
.card {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 1.75rem;
  margin-bottom: 1.5rem;
  transition: border-color 0.3s;
}

.card:hover { border-color: var(--border-light); }

.card-header {
  display: flex;
  align-items: center;
  gap: 0.75rem;
  margin-bottom: 1.25rem;
}

.card-icon {
  width: 36px;
  height: 36px;
  border-radius: 8px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.1rem;
  flex-shrink: 0;
}

.card-icon.purple { background: rgba(101, 79, 240, 0.2); }
.card-icon.green { background: rgba(16, 185, 129, 0.2); }
.card-icon.yellow { background: rgba(245, 158, 11, 0.2); }
.card-icon.red { background: rgba(239, 68, 68, 0.2); }
.card-icon.blue { background: rgba(59, 130, 246, 0.2); }

.card h2 {
  font-size: 1.25rem;
  font-weight: 700;
}

.card h3 {
  font-size: 1.05rem;
  font-weight: 600;
  color: var(--accent-light);
  margin: 1.25rem 0 0.75rem;
}

.card p { color: var(--text-secondary); margin-bottom: 0.75rem; }

/* Code Blocks */
.code-block {
  background: var(--bg-code);
  border: 1px solid var(--border);
  border-radius: 8px;
  margin: 1rem 0;
  overflow: hidden;
}

.code-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.5rem 1rem;
  background: rgba(255,255,255,0.03);
  border-bottom: 1px solid var(--border);
}

.code-lang {
  font-size: 0.7rem;
  color: var(--accent-light);
  text-transform: uppercase;
  font-weight: 600;
  letter-spacing: 1px;
}

.code-copy {
  background: none;
  border: 1px solid var(--border);
  color: var(--text-muted);
  padding: 2px 10px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.7rem;
  transition: all 0.2s;
}

.code-copy:hover {
  color: var(--text-primary);
  border-color: var(--accent);
}

.code-block pre {
  padding: 1rem;
  overflow-x: auto;
  font-family: 'Cascadia Code', 'Fira Code', 'JetBrains Mono', monospace;
  font-size: 0.82rem;
  line-height: 1.8;
  color: var(--text-primary);
}

.code-block .keyword { color: #c084fc; }
.code-block .string { color: #34d399; }
.code-block .comment { color: var(--text-muted); font-style: italic; }
.code-block .function { color: #60a5fa; }
.code-block .number { color: #f59e0b; }
.code-block .type { color: #f472b6; }
.code-block .operator { color: #67e8f9; }
.code-block .property { color: #a78bfa; }

code {
  background: var(--bg-code);
  padding: 2px 6px;
  border-radius: 4px;
  font-family: 'Cascadia Code', monospace;
  font-size: 0.85em;
  color: var(--accent-light);
  border: 1px solid var(--border);
}

/* Lessons Navigation */
.lesson-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
  gap: 1rem;
  margin-bottom: 2rem;
}

.lesson-card {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 10px;
  padding: 1.25rem;
  cursor: pointer;
  transition: all 0.3s;
  position: relative;
  overflow: hidden;
}

.lesson-card::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 4px;
  height: 100%;
  background: var(--accent);
  opacity: 0;
  transition: opacity 0.3s;
}

.lesson-card:hover {
  border-color: var(--accent);
  transform: translateY(-2px);
  box-shadow: 0 8px 25px rgba(0,0,0,0.3);
}

.lesson-card:hover::before { opacity: 1; }

.lesson-card.completed { border-color: var(--green); }
.lesson-card.completed::before { background: var(--green); opacity: 1; }

.lesson-card .lesson-num {
  font-size: 0.7rem;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 1px;
  margin-bottom: 0.5rem;
}

.lesson-card h3 {
  font-size: 1rem;
  margin-bottom: 0.5rem;
  color: var(--text-primary);
}

.lesson-card p {
  font-size: 0.8rem;
  color: var(--text-muted);
}

.lesson-card .lesson-status {
  position: absolute;
  top: 1rem;
  right: 1rem;
  font-size: 1.1rem;
}

/* Lesson Detail */
.lesson-detail { display: none; }
.lesson-detail.active { display: block; }

.back-btn {
  background: none;
  border: 1px solid var(--border);
  color: var(--text-secondary);
  padding: 0.5rem 1rem;
  border-radius: 6px;
  cursor: pointer;
  font-size: 0.85rem;
  margin-bottom: 1.5rem;
  transition: all 0.2s;
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
}

.back-btn:hover {
  border-color: var(--accent);
  color: var(--accent-light);
}

.complete-btn {
  background: linear-gradient(135deg, var(--green), #059669);
  border: none;
  color: white;
  padding: 0.75rem 2rem;
  border-radius: 8px;
  cursor: pointer;
  font-size: 0.9rem;
  font-weight: 600;
  margin-top: 1.5rem;
  transition: all 0.3s;
  display: inline-flex;
  align-items: center;
  gap: 0.5rem;
}

.complete-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 5px 20px var(--green-glow);
}

.complete-btn.completed {
  background: var(--bg-card);
  border: 1px solid var(--green);
  color: var(--green);
}

/* Analogy Box */
.analogy {
  background: linear-gradient(135deg, rgba(101, 79, 240, 0.1), rgba(139, 92, 246, 0.05));
  border: 1px solid rgba(101, 79, 240, 0.3);
  border-radius: 10px;
  padding: 1.25rem;
  margin: 1rem 0;
}

.analogy-title {
  font-size: 0.8rem;
  color: var(--accent-light);
  text-transform: uppercase;
  letter-spacing: 1px;
  font-weight: 700;
  margin-bottom: 0.5rem;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.analogy p { color: var(--text-secondary); font-size: 0.9rem; }

/* Key Point */
.key-point {
  background: rgba(16, 185, 129, 0.08);
  border-left: 3px solid var(--green);
  padding: 1rem 1.25rem;
  margin: 1rem 0;
  border-radius: 0 8px 8px 0;
}

.key-point strong { color: var(--green); }

/* Warning */
.warning {
  background: rgba(245, 158, 11, 0.08);
  border-left: 3px solid var(--yellow);
  padding: 1rem 1.25rem;
  margin: 1rem 0;
  border-radius: 0 8px 8px 0;
}

.warning strong { color: var(--yellow); }

/* Danger */
.danger {
  background: rgba(239, 68, 68, 0.08);
  border-left: 3px solid var(--red);
  padding: 1rem 1.25rem;
  margin: 1rem 0;
  border-radius: 0 8px 8px 0;
}

.danger strong { color: var(--red); }

/* Quiz Styles */
.quiz-container { margin: 1rem 0; }

.quiz-question {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 10px;
  padding: 1.5rem;
  margin-bottom: 1rem;
}

.quiz-question h4 {
  font-size: 0.95rem;
  margin-bottom: 1rem;
  display: flex;
  gap: 0.75rem;
}

.q-num {
  background: var(--accent);
  color: white;
  width: 24px;
  height: 24px;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.75rem;
  flex-shrink: 0;
  margin-top: 1px;
}

.quiz-options { display: flex; flex-direction: column; gap: 0.5rem; }

.quiz-option {
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 0.75rem 1rem;
  cursor: pointer;
  transition: all 0.2s;
  font-size: 0.88rem;
  color: var(--text-secondary);
  text-align: left;
  display: flex;
  align-items: center;
  gap: 0.75rem;
}

.quiz-option:hover:not(.selected) {
  border-color: var(--accent);
  color: var(--text-primary);
}

.quiz-option .opt-letter {
  width: 24px;
  height: 24px;
  border-radius: 50%;
  border: 1px solid var(--border-light);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 0.75rem;
  font-weight: 600;
  flex-shrink: 0;
}

.quiz-option.selected.correct {
  border-color: var(--green);
  background: rgba(16, 185, 129, 0.1);
  color: var(--green);
}

.quiz-option.selected.correct .opt-letter {
  background: var(--green);
  border-color: var(--green);
  color: white;
}

.quiz-option.selected.incorrect {
  border-color: var(--red);
  background: rgba(239, 68, 68, 0.1);
  color: var(--red);
}

.quiz-option.selected.incorrect .opt-letter {
  background: var(--red);
  border-color: var(--red);
  color: white;
}

.quiz-option.show-correct {
  border-color: var(--green);
  background: rgba(16, 185, 129, 0.05);
}

.quiz-explanation {
  margin-top: 0.75rem;
  padding: 0.75rem;
  background: rgba(101, 79, 240, 0.08);
  border-radius: 6px;
  font-size: 0.82rem;
  color: var(--text-secondary);
  display: none;
}

.quiz-explanation.show { display: block; }

.quiz-score-card {
  background: linear-gradient(135deg, var(--bg-card), var(--bg-secondary));
  border: 1px solid var(--accent);
  border-radius: 12px;
  padding: 2rem;
  text-align: center;
  margin: 2rem 0;
}

.quiz-score-card .score-big {
  font-size: 3rem;
  font-weight: 900;
  background: linear-gradient(135deg, var(--accent-light), var(--green));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

.quiz-submit {
  background: linear-gradient(135deg, var(--accent), #7c3aed);
  border: none;
  color: white;
  padding: 0.75rem 2rem;
  border-radius: 8px;
  cursor: pointer;
  font-size: 0.9rem;
  font-weight: 600;
  margin-top: 1rem;
  transition: all 0.3s;
}

.quiz-submit:hover {
  transform: translateY(-2px);
  box-shadow: 0 5px 20px var(--accent-glow);
}

.quiz-submit:disabled {
  opacity: 0.5;
  cursor: not-allowed;
  transform: none;
}

/* Exercise Styles */
.exercise-box {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 12px;
  margin-bottom: 1.5rem;
  overflow: hidden;
}

.exercise-header {
  padding: 1rem 1.5rem;
  background: rgba(101, 79, 240, 0.08);
  border-bottom: 1px solid var(--border);
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.exercise-header h3 {
  font-size: 1rem;
  color: var(--text-primary);
  margin: 0;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.difficulty {
  font-size: 0.7rem;
  padding: 2px 8px;
  border-radius: 4px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.difficulty.easy { background: rgba(16, 185, 129, 0.2); color: var(--green); }
.difficulty.medium { background: rgba(245, 158, 11, 0.2); color: var(--yellow); }
.difficulty.hard { background: rgba(239, 68, 68, 0.2); color: var(--red); }

.exercise-body { padding: 1.5rem; }

.exercise-body p {
  color: var(--text-secondary);
  margin-bottom: 1rem;
  font-size: 0.9rem;
}

.exercise-editor {
  width: 100%;
  min-height: 150px;
  background: var(--bg-code);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 1rem;
  color: var(--text-primary);
  font-family: 'Cascadia Code', 'Fira Code', monospace;
  font-size: 0.85rem;
  resize: vertical;
  line-height: 1.7;
}

.exercise-editor:focus {
  outline: none;
  border-color: var(--accent);
}

.exercise-actions {
  display: flex;
  gap: 0.75rem;
  margin-top: 1rem;
  flex-wrap: wrap;
}

.btn {
  padding: 0.6rem 1.25rem;
  border-radius: 6px;
  font-size: 0.85rem;
  font-weight: 600;
  cursor: pointer;
  border: none;
  transition: all 0.2s;
  display: inline-flex;
  align-items: center;
  gap: 0.4rem;
}

.btn-primary {
  background: var(--accent);
  color: white;
}

.btn-primary:hover {
  background: var(--accent-light);
  box-shadow: 0 3px 15px var(--accent-glow);
}

.btn-secondary {
  background: var(--bg-secondary);
  color: var(--text-secondary);
  border: 1px solid var(--border);
}

.btn-secondary:hover {
  border-color: var(--accent);
  color: var(--text-primary);
}

.exercise-result {
  margin-top: 1rem;
  padding: 0.75rem 1rem;
  border-radius: 6px;
  font-size: 0.85rem;
  display: none;
}

.exercise-result.show { display: block; }
.exercise-result.success { background: rgba(16,185,129,0.1); border: 1px solid var(--green); color: var(--green); }
.exercise-result.error { background: rgba(239,68,68,0.1); border: 1px solid var(--red); color: var(--red); }

/* Pitfall Cards */
.pitfall {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 12px;
  margin-bottom: 1.5rem;
  overflow: hidden;
}

.pitfall-header {
  padding: 1rem 1.5rem;
  display: flex;
  align-items: center;
  gap: 0.75rem;
  cursor: pointer;
  transition: background 0.2s;
}

.pitfall-header:hover { background: rgba(255,255,255,0.02); }

.pitfall-header .pitfall-icon { font-size: 1.3rem; }

.pitfall-header h3 {
  flex: 1;
  font-size: 0.95rem;
  color: var(--text-primary);
  margin: 0;
}

.pitfall-toggle {
  color: var(--text-muted);
  transition: transform 0.3s;
  font-size: 0.8rem;
}

.pitfall.open .pitfall-toggle { transform: rotate(180deg); }

.pitfall-body {
  padding: 0 1.5rem;
  max-height: 0;
  overflow: hidden;
  transition: all 0.3s ease;
}

.pitfall.open .pitfall-body {
  max-height: 2000px;
  padding: 0 1.5rem 1.5rem;
}

.vs-container {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 1rem;
  margin: 1rem 0;
}

.vs-box { border-radius: 8px; overflow: hidden; }
.vs-label {
  padding: 0.4rem 0.75rem;
  font-size: 0.7rem;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 1px;
}
.vs-bad .vs-label { background: rgba(239,68,68,0.2); color: var(--red); }
.vs-good .vs-label { background: rgba(16,185,129,0.2); color: var(--green); }

/* Cheat Sheet */
.cheat-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
  gap: 1rem;
}

.cheat-card {
  background: var(--bg-card);
  border: 1px solid var(--border);
  border-radius: 10px;
  padding: 1.25rem;
}

.cheat-card h4 {
  font-size: 0.9rem;
  color: var(--accent-light);
  margin-bottom: 0.75rem;
  display: flex;
  align-items: center;
  gap: 0.5rem;
}

.cheat-card .code-block { margin: 0.5rem 0; }

/* Comparison Table */
.compare-table {
  width: 100%;
  border-collapse: collapse;
  margin: 1rem 0;
  font-size: 0.85rem;
}

.compare-table th {
  background: rgba(101, 79, 240, 0.15);
  color: var(--accent-light);
  padding: 0.75rem 1rem;
  text-align: left;
  font-weight: 600;
  border: 1px solid var(--border);
}

.compare-table td {
  padding: 0.75rem 1rem;
  border: 1px solid var(--border);
  color: var(--text-secondary);
}

.compare-table tr:nth-child(even) { background: rgba(255,255,255,0.02); }

/* Diagram / Flow */
.flow-diagram {
  display: flex;
  align-items: center;
  justify-content: center;
  flex-wrap: wrap;
  gap: 0.5rem;
  margin: 1.5rem 0;
  padding: 1.5rem;
  background: rgba(101,79,240,0.05);
  border-radius: 10px;
  border: 1px solid var(--border);
}

.flow-step {
  background: var(--bg-card);
  border: 1px solid var(--accent);
  border-radius: 8px;
  padding: 0.75rem 1.25rem;
  text-align: center;
  min-width: 120px;
}

.flow-step .step-label {
  font-size: 0.65rem;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 1px;
}

.flow-step .step-value {
  font-weight: 700;
  color: var(--accent-light);
  font-size: 0.85rem;
}

.flow-arrow {
  font-size: 1.2rem;
  color: var(--accent);
}

/* Interactive Demo */
.demo-box {
  background: var(--bg-code);
  border: 1px solid var(--border);
  border-radius: 10px;
  padding: 1.5rem;
  margin: 1rem 0;
}

.demo-box h4 {
  color: var(--accent-light);
  margin-bottom: 1rem;
  font-size: 0.9rem;
}

.demo-output {
  background: var(--bg-primary);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 1rem;
  margin-top: 0.75rem;
  font-family: monospace;
  font-size: 0.85rem;
  min-height: 40px;
  color: var(--green);
}

/* Tags */
.tag {
  display: inline-block;
  padding: 2px 8px;
  border-radius: 4px;
  font-size: 0.7rem;
  font-weight: 600;
  margin: 0 2px;
}

.tag-wasm { background: rgba(101,79,240,0.2); color: var(--accent-light); }
.tag-js { background: rgba(245,158,11,0.2); color: var(--yellow); }
.tag-perf { background: rgba(16,185,129,0.2); color: var(--green); }

/* Lists */
ul.styled-list {
  list-style: none;
  margin: 0.75rem 0;
}

ul.styled-list li {
  padding: 0.4rem 0;
  color: var(--text-secondary);
  display: flex;
  align-items: flex-start;
  gap: 0.5rem;
  font-size: 0.9rem;
}

ul.styled-list li::before {
  content: '‚ñ∏';
  color: var(--accent-light);
  font-weight: bold;
  flex-shrink: 0;
  margin-top: 1px;
}

/* Tabs within content */
.inner-tabs {
  display: flex;
  gap: 0;
  margin-bottom: -1px;
  position: relative;
  z-index: 1;
}

.inner-tab {
  padding: 0.5rem 1rem;
  background: var(--bg-secondary);
  border: 1px solid var(--border);
  border-bottom: none;
  color: var(--text-muted);
  cursor: pointer;
  font-size: 0.8rem;
  border-radius: 6px 6px 0 0;
  transition: all 0.2s;
}

.inner-tab.active {
  background: var(--bg-code);
  color: var(--accent-light);
  border-color: var(--border);
}

.inner-content {
  border: 1px solid var(--border);
  border-radius: 0 8px 8px 8px;
}

/* Responsive */
@media (max-width: 768px) {
  .header { padding: 1rem; }
  .main { padding: 1rem; }
  .nav { padding: 0 1rem; }
  .stats { display: none; }
  .vs-container { grid-template-columns: 1fr; }
  .cheat-grid { grid-template-columns: 1fr; }
  .flow-diagram { flex-direction: column; }
  .flow-arrow { transform: rotate(90deg); }
  .lesson-grid { grid-template-columns: 1fr; }
}

/* Animation */
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

.fade-in { animation: fadeIn 0.4s ease; }

/* Highlight animation */
@keyframes pulse-green {
  0%, 100% { box-shadow: 0 0 0 0 var(--green-glow); }
  50% { box-shadow: 0 0 0 8px transparent; }
}

.pulse { animation: pulse-green 1s; }

/* Interactive WASM Simulator */
.sim-container {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 1rem;
  margin: 1rem 0;
}

.sim-panel {
  background: var(--bg-code);
  border: 1px solid var(--border);
  border-radius: 8px;
  overflow: hidden;
}

.sim-panel-header {
  padding: 0.5rem 1rem;
  background: rgba(255,255,255,0.03);
  border-bottom: 1px solid var(--border);
  font-size: 0.75rem;
  font-weight: 600;
  color: var(--text-muted);
  text-transform: uppercase;
  letter-spacing: 1px;
}

.sim-panel-body { padding: 1rem; }

@media (max-width: 700px) {
  .sim-container { grid-template-columns: 1fr; }
}
</style>
</head>
<body>

<!-- HEADER -->
<header class="header">
  <div class="header-inner">
    <div class="logo">
      <div class="logo-icon">W</div>
      <h1>WebAssembly Mastery</h1>
    </div>
    <div class="progress-bar-container">
      <div class="progress-label">
        <span>Overall Progress</span>
        <span id="progressPercent">0%</span>
      </div>
      <div class="progress-bar">
        <div class="progress-fill" id="progressFill"></div>
      </div>
    </div>
    <div class="stats">
      <div class="stat">
        <div class="stat-value" id="lessonsComplete">0</div>
        <div class="stat-label">Lessons</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="quizScore">0</div>
        <div class="stat-label">Quiz Score</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="exercisesDone">0</div>
        <div class="stat-label">Exercises</div>
      </div>
    </div>
  </div>
</header>

<!-- NAVIGATION -->
<nav class="nav">
  <div class="nav-inner">
    <button class="nav-tab active" data-tab="lessons">
      <span class="tab-icon">üìö</span> Lessons
      <span class="tab-badge" id="lessonBadge">8</span>
    </button>
    <button class="nav-tab" data-tab="quizzes">
      <span class="tab-icon">üß†</span> Quizzes
      <span class="tab-badge">25</span>
    </button>
    <button class="nav-tab" data-tab="exercises">
      <span class="tab-icon">üíª</span> Exercises
      <span class="tab-badge">10</span>
    </button>
    <button class="nav-tab" data-tab="pitfalls">
      <span class="tab-icon">‚ö†Ô∏è</span> Pitfalls
      <span class="tab-badge">12</span>
    </button>
    <button class="nav-tab" data-tab="cheatsheet">
      <span class="tab-icon">üìã</span> Cheat Sheet
    </button>
  </div>
</nav>

<!-- MAIN CONTENT -->
<main class="main">

<!-- ==================== LESSONS SECTION ==================== -->
<div class="section active" id="section-lessons">
  <div id="lessonList">
    <h2 style="margin-bottom:1.5rem; font-size:1.5rem;">üìö Learning Path</h2>
    <div class="lesson-grid" id="lessonGrid"></div>
  </div>
  <div id="lessonContent" class="lesson-detail"></div>
</div>

<!-- ==================== QUIZZES SECTION ==================== -->
<div class="section" id="section-quizzes">
  <h2 style="margin-bottom:1.5rem; font-size:1.5rem;">üß† Knowledge Check</h2>
  <p style="color:var(--text-muted); margin-bottom:1.5rem;">Test your understanding. Select the best answer for each question.</p>
  <div id="quizContainer"></div>
  <div style="text-align:center; margin-top:1.5rem;">
    <button class="quiz-submit" id="submitQuiz" onclick="submitQuiz()">Submit All Answers</button>
    <button class="btn btn-secondary" id="resetQuiz" onclick="resetQuiz()" style="display:none; margin-left:0.5rem;">Try Again</button>
  </div>
  <div id="quizScoreCard" class="quiz-score-card" style="display:none;"></div>
</div>

<!-- ==================== EXERCISES SECTION ==================== -->
<div class="section" id="section-exercises">
  <h2 style="margin-bottom:1.5rem; font-size:1.5rem;">üíª Practice Exercises</h2>
  <p style="color:var(--text-muted); margin-bottom:1.5rem;">Write code, check your answers, and build real understanding.</p>
  <div id="exerciseContainer"></div>
</div>

<!-- ==================== PITFALLS SECTION ==================== -->
<div class="section" id="section-pitfalls">
  <h2 style="margin-bottom:1.5rem; font-size:1.5rem;">‚ö†Ô∏è Common Mistakes & Pitfalls</h2>
  <p style="color:var(--text-muted); margin-bottom:1.5rem;">These trip up even experienced developers. Learn them now to ace interviews.</p>
  <div id="pitfallContainer"></div>
</div>

<!-- ==================== CHEAT SHEET SECTION ==================== -->
<div class="section" id="section-cheatsheet">
  <h2 style="margin-bottom:1.5rem; font-size:1.5rem;">üìã WebAssembly Cheat Sheet</h2>
  <p style="color:var(--text-muted); margin-bottom:1.5rem;">Quick reference for interviews and daily work.</p>
  <div class="cheat-grid" id="cheatGrid"></div>
</div>

</main>

<script>
// ====================== APP STATE ======================
const state = {
  completedLessons: new Set(JSON.parse(localStorage.getItem('wasm_lessons') || '[]')),
  quizAnswers: {},
  quizSubmitted: false,
  exercisesCompleted: new Set(JSON.parse(localStorage.getItem('wasm_exercises') || '[]')),
  bestQuizScore: parseInt(localStorage.getItem('wasm_quiz_score') || '0')
};

function saveState() {
  localStorage.setItem('wasm_lessons', JSON.stringify([...state.completedLessons]));
  localStorage.setItem('wasm_exercises', JSON.stringify([...state.exercisesCompleted]));
  localStorage.setItem('wasm_quiz_score', state.bestQuizScore.toString());
}

// ====================== LESSONS DATA ======================
const lessons = [
  {
    id: 1,
    title: "What is WebAssembly?",
    desc: "The big picture ‚Äî what WASM is and why it matters",
    icon: "üåç",
    content: `
      <h2>What is WebAssembly (WASM)?</h2>

      <div class="analogy">
        <div class="analogy-title">üí° Simple Analogy</div>
        <p>Imagine JavaScript is like giving a chef handwritten recipe instructions in English ‚Äî the chef has to read, interpret, and follow them step by step. <strong>WebAssembly is like giving the chef a pre-measured, pre-cut meal kit</strong> ‚Äî most of the hard work is already done, so cooking is much faster.</p>
      </div>

      <h3>The Official Definition</h3>
      <p>WebAssembly (WASM) is a <strong>low-level binary instruction format</strong> that runs in web browsers at near-native speed. It's a compilation target for languages like C, C++, Rust, Go, and others.</p>

      <div class="key-point">
        <strong>Key Insight:</strong> WASM doesn't replace JavaScript ‚Äî it <em>complements</em> it. Think of it as a turbo engine you can plug into specific parts of your JS application.
      </div>

      <h3>What Problem Does It Solve?</h3>
      <p>JavaScript was designed in 10 days in 1995 for simple web interactivity. It was never designed for:</p>
      <ul class="styled-list">
        <li>Heavy computation (video editing, 3D games, physics simulations)</li>
        <li>Running existing C/C++/Rust codebases in the browser</li>
        <li>Predictable, near-native performance</li>
        <li>Large-scale applications like AutoCAD or Photoshop in-browser</li>
      </ul>

      <h3>The WASM Pipeline</h3>
      <div class="flow-diagram">
        <div class="flow-step">
          <div class="step-label">Source</div>
          <div class="step-value">C / C++ / Rust</div>
        </div>
        <div class="flow-arrow">‚Üí</div>
        <div class="flow-step">
          <div class="step-label">Compiler</div>
          <div class="step-value">Emscripten / wasm-pack</div>
        </div>
        <div class="flow-arrow">‚Üí</div>
        <div class="flow-step">
          <div class="step-label">Output</div>
          <div class="step-value">.wasm binary</div>
        </div>
        <div class="flow-arrow">‚Üí</div>
        <div class="flow-step">
          <div class="step-label">Runtime</div>
          <div class="step-value">Browser VM</div>
        </div>
      </div>

      <h3>Key Characteristics</h3>
      <table class="compare-table">
        <tr><th>Feature</th><th>Description</th></tr>
        <tr><td>Binary Format</td><td>Compact binary, not human-readable text like JS</td></tr>
        <tr><td>Stack-based VM</td><td>Uses a virtual stack machine architecture</td></tr>
        <tr><td>Sandboxed</td><td>Runs in same security sandbox as JavaScript</td></tr>
        <tr><td>Portable</td><td>Works on all major browsers and platforms</td></tr>
        <tr><td>Fast</td><td>Near-native execution speed (within 10-20% of C++)</td></tr>
        <tr><td>Language-agnostic</td><td>Any language can compile to WASM</td></tr>
      </table>

      <h3>Browser Support</h3>
      <p>WebAssembly is supported in <strong>all major browsers</strong> since 2017:</p>
      <ul class="styled-list">
        <li>Chrome 57+ ‚úÖ</li>
        <li>Firefox 52+ ‚úÖ</li>
        <li>Safari 11+ ‚úÖ</li>
        <li>Edge 16+ ‚úÖ</li>
        <li>Node.js 8+ ‚úÖ</li>
      </ul>

      <div class="warning">
        <strong>Interview Note:</strong> "WASM replaces JavaScript" is <em>wrong</em>. WASM is designed to work alongside JS, not replace it. WASM can't directly access the DOM ‚Äî it needs JS to bridge that gap.
      </div>
    `
  },
  {
    id: 2,
    title: "WASM Binary Format & Text Format",
    desc: "Understanding .wasm files, WAT text format, and module structure",
    icon: "üì¶",
    content: `
      <h2>WASM Binary & Text Format</h2>

      <h3>Two Representations</h3>
      <p>WebAssembly has two formats:</p>
      <table class="compare-table">
        <tr><th>Format</th><th>Extension</th><th>Purpose</th></tr>
        <tr><td><strong>Binary</strong></td><td>.wasm</td><td>What browsers execute ‚Äî compact, fast to parse</td></tr>
        <tr><td><strong>Text (WAT)</strong></td><td>.wat</td><td>Human-readable S-expression syntax for debugging</td></tr>
      </table>

      <h3>WAT ‚Äî WebAssembly Text Format</h3>
      <p>WAT uses S-expressions (like Lisp). Here's the simplest possible WASM module:</p>

      <div class="code-block">
        <div class="code-header">
          <span class="code-lang">WAT</span>
          <button class="code-copy" onclick="copyCode(this)">Copy</button>
        </div>
        <pre><span class="comment">;; A simple add function in WAT</span>
(<span class="keyword">module</span>
  (<span class="keyword">func</span> <span class="function">$add</span> (<span class="keyword">param</span> <span class="type">$a</span> <span class="type">i32</span>) (<span class="keyword">param</span> <span class="type">$b</span> <span class="type">i32</span>) (<span class="keyword">result</span> <span class="type">i32</span>)
    <span class="property">local.get</span> <span class="type">$a</span>
    <span class="property">local.get</span> <span class="type">$b</span>
    <span class="property">i32.add</span>
  )
  (<span class="keyword">export</span> <span class="string">"add"</span> (<span class="keyword">func</span> <span class="function">$add</span>))
)</pre>
      </div>

      <div class="analogy">
        <div class="analogy-title">üí° Think of it like this</div>
        <p>WAT is to WASM what Assembly language is to machine code. You rarely write WAT directly, but understanding it helps you debug and understand what's happening under the hood.</p>
      </div>

      <h3>WASM Module Structure</h3>
      <p>A WASM module is organized into sections:</p>
      <ul class="styled-list">
        <li><strong>Type Section</strong> ‚Äî Function signatures (parameter and return types)</li>
        <li><strong>Import Section</strong> ‚Äî Functions/memory imported from JavaScript</li>
        <li><strong>Function Section</strong> ‚Äî Function declarations</li>
        <li><strong>Memory Section</strong> ‚Äî Linear memory definition</li>
        <li><strong>Export Section</strong> ‚Äî What JS can access</li>
        <li><strong>Code Section</strong> ‚Äî Function bodies (actual instructions)</li>
      </ul>

      <h3>WASM Types</h3>
      <p>WASM has only <strong>4 value types</strong>:</p>
      <div class="code-block">
        <div class="code-header"><span class="code-lang">WASM Types</span></div>
        <pre><span class="type">i32</span>  ‚Äî 32-bit integer
<span class="type">i64</span>  ‚Äî 64-bit integer
<span class="type">f32</span>  ‚Äî 32-bit float
<span class="type">f64</span>  ‚Äî 64-bit float</pre>
      </div>

      <div class="warning">
        <strong>No Strings!</strong> WASM has no string type. Strings must be passed as bytes in linear memory and decoded on the JS side. This is a major source of complexity in JS‚ÜîWASM interop.
      </div>

      <h3>The Magic Number</h3>
      <p>Every .wasm file starts with the bytes <code>\\0asm</code> (hex: <code>00 61 73 6D</code>) followed by version <code>01 00 00 00</code>. This is how the browser knows it's a valid WASM module.</p>

      <div class="key-point">
        <strong>Key Takeaway:</strong> You almost never write WAT by hand. You write C/Rust/Go, compile to .wasm, and load it via JavaScript APIs. But knowing the structure helps you debug and understand performance.
      </div>
    `
  },
  {
    id: 3,
    title: "Loading WASM in JavaScript",
    desc: "The JavaScript APIs: instantiate, compile, Module, Instance",
    icon: "üîå",
    content: `
      <h2>Loading WASM in JavaScript</h2>

      <div class="analogy">
        <div class="analogy-title">üí° Simple Analogy</div>
        <p>Loading a WASM module is like installing a plugin into your JS app. You download the plugin file (.wasm), install it (compile + instantiate), and then call its functions.</p>
      </div>

      <h3>Method 1: WebAssembly.instantiateStreaming() ‚Äî THE BEST WAY</h3>
      <p>This is the <strong>recommended</strong> approach. It compiles and instantiates while downloading:</p>

      <div class="code-block">
        <div class="code-header">
          <span class="code-lang">JavaScript</span>
          <button class="code-copy" onclick="copyCode(this)">Copy</button>
        </div>
        <pre><span class="comment">// ‚úÖ Best practice ‚Äî streaming compilation</span>
<span class="keyword">async function</span> <span class="function">loadWasm</span>() {
  <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="function">fetch</span>(<span class="string">'module.wasm'</span>);

  <span class="keyword">const</span> { instance, module } = <span class="keyword">await</span> WebAssembly.<span class="function">instantiateStreaming</span>(
    response,
    importObject  <span class="comment">// optional: things JS provides to WASM</span>
  );

  <span class="comment">// Call exported WASM function</span>
  <span class="keyword">const</span> result = instance.exports.<span class="function">add</span>(<span class="number">5</span>, <span class="number">3</span>);
  console.<span class="function">log</span>(result); <span class="comment">// 8</span>
}

<span class="function">loadWasm</span>();</pre>
      </div>

      <h3>Method 2: WebAssembly.instantiate() with ArrayBuffer</h3>
      <p>Use this when you already have the bytes (e.g., from IndexedDB or bundled):</p>

      <div class="code-block">
        <div class="code-header">
          <span class="code-lang">JavaScript</span>
          <button class="code-copy" onclick="copyCode(this)">Copy</button>
        </div>
        <pre><span class="comment">// When you have raw bytes</span>
<span class="keyword">async function</span> <span class="function">loadFromBytes</span>() {
  <span class="keyword">const</span> response = <span class="keyword">await</span> <span class="function">fetch</span>(<span class="string">'module.wasm'</span>);
  <span class="keyword">const</span> bytes = <span class="keyword">await</span> response.<span class="function">arrayBuffer</span>();

  <span class="keyword">const</span> { instance } = <span class="keyword">await</span> WebAssembly.<span class="function">instantiate</span>(
    bytes,
    importObject
  );

  instance.exports.<span class="function">add</span>(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 5</span>
}</pre>
      </div>

      <h3>Method 3: Separate Compile + Instantiate</h3>
      <p>Useful when you want to cache the compiled module and create multiple instances:</p>

      <div class="code-block">
        <div class="code-header">
          <span class="code-lang">JavaScript</span>
          <button class="code-copy" onclick="copyCode(this)">Copy</button>
        </div>
        <pre><span class="comment">// Compile once, instantiate many times</span>
<span class="keyword">const</span> response = <span class="keyword">await</span> <span class="function">fetch</span>(<span class="string">'module.wasm'</span>);
<span class="keyword">const</span> bytes = <span class="keyword">await</span> response.<span class="function">arrayBuffer</span>();

<span class="comment">// Step 1: Compile</span>
<span class="keyword">const</span> module = <span class="keyword">await</span> WebAssembly.<span class="function">compile</span>(bytes);

<span class="comment">// Step 2: Instantiate (can do multiple times)</span>
<span class="keyword">const</span> instance1 = <span class="keyword">await</span> WebAssembly.<span class="function">instantiate</span>(module, imports1);
<span class="keyword">const</span> instance2 = <span class="keyword">await</span> WebAssembly.<span class="function">instantiate</span>(module, imports2);

<span class="comment">// Cache module in IndexedDB for faster future loads</span></pre>
      </div>

      <h3>The Import Object</h3>
      <p>The import object is how you give WASM access to JavaScript functionality:</p>

      <div class="code-block">
        <div class="code-header">
          <span class="code-lang">JavaScript</span>
          <button class="code-copy" onclick="copyCode(this)">Copy</button>
        </div>
        <pre><span class="keyword">const</span> importObject = {
  env: {
    <span class="comment">// Memory shared between JS and WASM</span>
    memory: <span class="keyword">new</span> WebAssembly.<span class="function">Memory</span>({ initial: <span class="number">1</span> }),  <span class="comment">// 1 page = 64KB</span>

    <span class="comment">// JS functions WASM can call</span>
    <span class="function">log</span>: (value) => console.<span class="function">log</span>(<span class="string">'From WASM:'</span>, value),
    <span class="function">getTimestamp</span>: () => Date.<span class="function">now</span>(),
  },
  js: {
    <span class="comment">// Table for indirect function calls</span>
    table: <span class="keyword">new</span> WebAssembly.<span class="function">Table</span>({ initial: <span class="number">1</span>, element: <span class="string">'anyfunc'</span> })
  }
};</pre>
      </div>

      <h3>Key Objects Summary</h3>
      <table class="compare-table">
        <tr><th>Object</th><th>What It Is</th></tr>
        <tr><td><code>WebAssembly.Module</code></td><td>Compiled WASM code (stateless, cacheable)</td></tr>
        <tr><td><code>WebAssembly.Instance</code></td><td>A running module with its own memory/state</td></tr>
        <tr><td><code>WebAssembly.Memory</code></td><td>A resizable ArrayBuffer shared between JS ‚Üî WASM</td></tr>
        <tr><td><code>WebAssembly.Table</code></td><td>An array of function references (for indirect calls)</td></tr>
        <tr><td><code>WebAssembly.Global</code></td><td>A global variable accessible from JS and WASM</td></tr>
      </table>

      <div class="danger">
        <strong>Common Error:</strong> <code>instantiateStreaming</code> requires the server to send the WASM file with MIME type <code>application/wasm</code>. If your server sends <code>application/octet-stream</code>, it will fail! Use the ArrayBuffer method as fallback.
      </div>
    `
  },
  {
    id: 4,
    title: "JavaScript ‚Üî WASM Interop",
    desc: "Calling WASM from JS and JS from WASM, sharing data",
    icon: "üîÑ",
    content: `
      <h2>JavaScript ‚Üî WASM Interop</h2>

      <div class="analogy">
        <div class="analogy-title">üí° Simple Analogy</div>
        <p>Think of JS and WASM as two people who speak different languages, communicating through a shared whiteboard (linear memory). They can pass simple numbers directly, but for complex data like strings, they write bytes on the whiteboard and tell each other where to look.</p>
      </div>

      <h3>Calling WASM from JavaScript (Easy)</h3>
      <div class="code-block">
        <div class="code-header">
          <span class="code-lang">JavaScript</span>
          <button class="code-copy" onclick="copyCode(this)">Copy</button>
        </div>
        <pre><span class="comment">// After loading module...</span>
<span class="keyword">const</span> { instance } = <span class="keyword">await</span> WebAssembly.<span class="function">instantiateStreaming</span>(
  <span class="function">fetch</span>(<span class="string">'math.wasm'</span>)
);

<span class="comment">// Call exported functions just like regular JS functions!</span>
<span class="keyword">const</span> sum = instance.exports.<span class="function">add</span>(<span class="number">10</span>, <span class="number">20</span>);       <span class="comment">// 30</span>
<span class="keyword">const</span> fact = instance.exports.<span class="function">factorial</span>(<span class="number">5</span>);    <span class="comment">// 120</span>
<span class="keyword">const</span> fib = instance.exports.<span class="function">fibonacci</span>(<span class="number">10</span>);   <span class="comment">// 55</span></pre>
      </div>

      <h3>Calling JavaScript from WASM</h3>
      <p>WASM can call JS functions that you provide through the import object:</p>

      <div class="code-block">
        <div class="code-header">
          <span class="code-lang">JavaScript</span>
          <button class="code-copy" onclick="copyCode(this)">Copy</button>
        </div>
        <pre><span class="keyword">const</span> importObject = {
  env: {
    <span class="comment">// These functions can be called FROM WASM</span>
    <span class="function">jsLog</span>: (value) => console.<span class="function">log</span>(<span class="string">'WASM says:'</span>, value),
    <span class="function">jsAlert</span>: (code) => <span class="function">alert</span>(<span class="string">'Error code: '</span> + code),
    <span class="function">jsRandom</span>: () => Math.<span class="function">random</span>() * <span class="number">1000</span> | <span class="number">0</span>,
    <span class="function">jsGetTime</span>: () => Date.<span class="function">now</span>(),
  }
};

<span class="keyword">const</span> { instance } = <span class="keyword">await</span> WebAssembly.<span class="function">instantiateStreaming</span>(
  <span class="function">fetch</span>(<span class="string">'app.wasm'</span>),
  importObject
);</pre>
      </div>

      <h3>Sharing Memory ‚Äî The Key to Complex Data</h3>
      <p>WASM linear memory is just a big <code>ArrayBuffer</code> that both sides can read/write:</p>

      <div class="code-block">
        <div class="code-header">
          <span class="code-lang">JavaScript</span>
          <button class="code-copy" onclick="copyCode(this)">Copy</button>
        </div>
        <pre><span class="comment">// Create shared memory</span>
<span class="keyword">const</span> memory = <span class="keyword">new</span> WebAssembly.<span class="function">Memory</span>({
  initial: <span class="number">1</span>,     <span class="comment">// 1 page = 64KB</span>
  maximum: <span class="number">10</span>,    <span class="comment">// max 10 pages = 640KB</span>
});

<span class="comment">// JS can read/write WASM memory through typed arrays</span>
<span class="keyword">const</span> buffer = <span class="keyword">new</span> <span class="type">Uint8Array</span>(memory.buffer);

<span class="comment">// Write a string into WASM memory from JS</span>
<span class="keyword">const</span> str = <span class="string">"Hello WASM"</span>;
<span class="keyword">const</span> encoder = <span class="keyword">new</span> <span class="type">TextEncoder</span>();
<span class="keyword">const</span> encoded = encoder.<span class="function">encode</span>(str);
buffer.<span class="function">set</span>(encoded, <span class="number">0</span>);  <span class="comment">// write at offset 0</span>

<span class="comment">// Read a string from WASM memory in JS</span>
<span class="keyword">const</span> decoder = <span class="keyword">new</span> <span class="type">TextDecoder</span>();
<span class="keyword">const</span> result = decoder.<span class="function">decode</span>(
  buffer.<span class="function">slice</span>(offset, offset + length)
);</pre>
      </div>

      <h3>Passing Different Data Types</h3>
      <table class="compare-table">
        <tr><th>Data Type</th><th>How to Pass</th><th>Complexity</th></tr>
        <tr><td>Numbers (i32, f64)</td><td>Direct function params/returns</td><td>üü¢ Easy</td></tr>
        <tr><td>Booleans</td><td>As i32 (0 = false, non-0 = true)</td><td>üü¢ Easy</td></tr>
        <tr><td>Strings</td><td>Write bytes to memory + pass pointer & length</td><td>üî¥ Complex</td></tr>
        <tr><td>Arrays</td><td>Write to memory + pass pointer & length</td><td>üî¥ Complex</td></tr>
        <tr><td>Objects</td><td>Serialize to memory (JSON/custom format)</td><td>üî¥ Very Complex</td></tr>
        <tr><td>Functions</td><td>WebAssembly.Table or import object</td><td>üü° Medium</td></tr>
      </table>

      <h3>Passing an Array Example</h3>
      <div class="code-block">
        <div class="code-header">
          <span class="code-lang">JavaScript</span>
          <button class="code-copy" onclick="copyCode(this)">Copy</button>
        </div>
        <pre><span class="comment">// Write an array of i32 values to WASM memory</span>
<span class="keyword">function</span> <span class="function">passArrayToWasm</span>(instance, arr) {
  <span class="keyword">const</span> memory = instance.exports.memory;
  <span class="keyword">const</span> ptr = instance.exports.<span class="function">allocate</span>(arr.length * <span class="number">4</span>);

  <span class="keyword">const</span> view = <span class="keyword">new</span> <span class="type">Int32Array</span>(memory.buffer, ptr, arr.length);
  view.<span class="function">set</span>(arr);

  <span class="comment">// Tell WASM: "data starts at ptr, length is arr.length"</span>
  <span class="keyword">const</span> result = instance.exports.<span class="function">sumArray</span>(ptr, arr.length);

  instance.exports.<span class="function">deallocate</span>(ptr);  <span class="comment">// free memory!</span>
  <span class="keyword">return</span> result;
}</pre>
      </div>

      <div class="danger">
        <strong>Memory Gotcha:</strong> When WASM memory grows (via <code>memory.grow()</code>), the underlying <code>ArrayBuffer</code> is <strong>detached</strong>. Any typed array views you created become invalid! Always re-create views after potential growth.
      </div>

      <div class="key-point">
        <strong>Interview Answer:</strong> "WASM and JS communicate through exported/imported functions for simple values, and shared linear memory for complex data. The challenge is marshaling data between JS types and WASM's number-only type system."
      </div>
    `
  },
  {
    id: 5,
    title: "Real-World Use Cases",
    desc: "Where WASM shines: games, image processing, crypto, and more",
    icon: "üéØ",
    content: `
      <h2>Real-World Use Cases</h2>

      <p>WebAssembly isn't theoretical ‚Äî it powers massive production apps today.</p>

      <h3>üéÆ Gaming</h3>
      <p><strong>Examples:</strong> Unity WebGL, Unreal Engine, Doom 3</p>
      <p>Game engines compile C++ to WASM, achieving 60fps frame rates in the browser. Unity's entire runtime compiles to WASM.</p>

      <h3>üñºÔ∏è Image/Video Processing</h3>
      <p><strong>Examples:</strong> Figma, Photoshop Web, Squoosh (by Google)</p>
      <div class="code-block">
        <div class="code-header"><span class="code-lang">JavaScript</span></div>
        <pre><span class="comment">// Squoosh.app uses WASM codecs for image compression</span>
<span class="comment">// Example: Loading a WASM image encoder</span>
<span class="keyword">const</span> { instance } = <span class="keyword">await</span> WebAssembly.<span class="function">instantiateStreaming</span>(
  <span class="function">fetch</span>(<span class="string">'mozjpeg_enc.wasm'</span>), importObject
);

<span class="comment">// Encode image pixels to JPEG ‚Äî runs 10x faster than pure JS</span>
<span class="keyword">const</span> jpegData = instance.exports.<span class="function">encode</span>(
  pixelPtr, width, height, quality
);</pre>
      </div>

      <h3>üîê Cryptography</h3>
      <p><strong>Examples:</strong> 1Password, Signal Protocol</p>
      <p>CPU-intensive crypto operations (hashing, encryption) run significantly faster in WASM.</p>

      <h3>üìä Data Visualization & Science</h3>
      <p><strong>Examples:</strong> Observable, Pyodide (Python in browser)</p>
      <p>Statistical computations, ML inference, and large dataset processing.</p>

      <h3>üèóÔ∏è CAD/Engineering</h3>
      <p><strong>Examples:</strong> AutoCAD Web, Google Earth</p>
      <p>Porting millions of lines of existing C++ code to run in browsers.</p>

      <h3>üéµ Audio Processing</h3>
      <p><strong>Examples:</strong> Spotify (audio decoding), Soundtrap</p>
      <p>Real-time audio synthesis and effects processing.</p>

      <h3>Decision Framework: Should You Use WASM?</h3>
      <table class="compare-table">
        <tr><th>Use WASM When</th><th>Stick with JS When</th></tr>
        <tr><td>CPU-intensive computation</td><td>DOM manipulation</td></tr>
        <tr><td>Porting existing C/C++/Rust code</td><td>UI interactions</td></tr>
        <tr><td>Predictable performance needed</td><td>Network requests / APIs</td></tr>
        <tr><td>Working with binary data</td><td>Simple business logic</td></tr>
        <tr><td>Tight loops over numeric data</td><td>String processing</td></tr>
        <tr><td>Real-time processing (audio/video)</td><td>Event handling</td></tr>
      </table>

      <div class="key-point">
        <strong>The Rule of Thumb:</strong> If your code spends most of its time doing math on numbers in tight loops ‚Üí WASM. If it's doing I/O, DOM updates, or string manipulation ‚Üí JavaScript.
      </div>

      <h3>Real Performance Numbers</h3>
      <ul class="styled-list">
        <li><strong>Figma:</strong> 3x faster loading with WASM vs asm.js</li>
        <li><strong>Google Earth:</strong> Ported 1M+ lines of C++ to run in browser</li>
        <li><strong>Doom 3:</strong> 60fps gameplay entirely in-browser</li>
        <li><strong>SQLite:</strong> Full database engine running in WASM</li>
        <li><strong>FFmpeg:</strong> Video transcoding in the browser</li>
      </ul>

      <div class="warning">
        <strong>Not a Silver Bullet:</strong> WASM won't speed up typical web apps. If your bottleneck is DOM rendering, network latency, or simple CRUD logic, WASM adds complexity without benefit.
      </div>
    `
  },
  {
    id: 6,
    title: "Performance Deep Dive",
    desc: "When WASM is faster, when it's not, and how to measure",
    icon: "‚ö°",
    content: `
      <h2>Performance Deep Dive</h2>

      <h3>Why WASM Is Faster</h3>

      <div class="flow-diagram">
        <div class="flow-step">
          <div class="step-label">JavaScript</div>
          <div class="step-value">Parse ‚Üí Compile ‚Üí Optimize ‚Üí Deoptimize ‚Üí Re-optimize</div>
        </div>
      </div>
      <div class="flow-diagram">
        <div class="flow-step">
          <div class="step-label">WebAssembly</div>
          <div class="step-value">Decode ‚Üí Compile ‚Üí Execute</div>
        </div>
      </div>

      <h3>The Performance Pipeline Compared</h3>
      <table class="compare-table">
        <tr><th>Stage</th><th>JavaScript</th><th>WASM</th></tr>
        <tr><td>Download</td><td>Text source (larger)</td><td>Binary (30-50% smaller)</td></tr>
        <tr><td>Parse</td><td>Full text parsing</td><td>Simple binary decoding</td></tr>
        <tr><td>Compile</td><td>JIT (just-in-time)</td><td>AOT-like (ahead-of-time)</td></tr>
        <tr><td>Optimize</td><td>Speculative ‚Üí can deoptimize</td><td>Already optimized by LLVM</td></tr>
        <tr><td>Execute</td><td>Can be fast, but unpredictable</td><td>Consistently fast</td></tr>
        <tr><td>GC Pauses</td><td>Yes (garbage collector)</td><td>No (manual memory)</td></tr>
      </table>

      <h3>When WASM Wins (Benchmarks)</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-lang">Performance Comparison</span></div>
        <pre><span class="comment">// Fibonacci(40) benchmark</span>
JavaScript:    ~1200ms
WebAssembly:   ~350ms   <span class="comment">// ~3.4x faster</span>

<span class="comment">// Matrix multiplication (1000x1000)</span>
JavaScript:    ~4500ms
WebAssembly:   ~800ms   <span class="comment">// ~5.6x faster</span>

<span class="comment">// Image blur (4K image)</span>
JavaScript:    ~2100ms
WebAssembly:   ~420ms   <span class="comment">// ~5x faster</span>

<span class="comment">// String concatenation</span>
JavaScript:    ~15ms
WebAssembly:   ~45ms    <span class="comment">// JS wins! (strings are JS native)</span></pre>
      </div>

      <h3>When JavaScript Wins</h3>
      <ul class="styled-list">
        <li><strong>Small functions called millions of times</strong> ‚Äî JS call overhead to WASM adds up</li>
        <li><strong>String-heavy operations</strong> ‚Äî WASM must marshal strings through memory</li>
        <li><strong>DOM operations</strong> ‚Äî WASM can't access DOM directly</li>
        <li><strong>Highly optimized JS</strong> ‚Äî V8/SpiderMonkey JIT can match WASM for simple code</li>
        <li><strong>Short-lived operations</strong> ‚Äî WASM load time dominates</li>
      </ul>

      <h3>The JS‚ÜîWASM Boundary Cost</h3>
      <div class="danger">
        <strong>Critical Pitfall:</strong> Every call across the JS‚ÜîWASM boundary has overhead. If you call a WASM function 1 million times in a loop, the boundary crossing cost will destroy your performance gains!
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-lang">JavaScript</span></div>
        <pre><span class="comment">// ‚ùå BAD ‚Äî Million boundary crossings</span>
<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i < <span class="number">1000000</span>; i++) {
  result += instance.exports.<span class="function">process</span>(data[i]);  <span class="comment">// slow!</span>
}

<span class="comment">// ‚úÖ GOOD ‚Äî One boundary crossing, loop inside WASM</span>
<span class="comment">// Write all data to WASM memory first</span>
<span class="keyword">const</span> view = <span class="keyword">new</span> <span class="type">Float64Array</span>(memory.buffer, ptr, <span class="number">1000000</span>);
view.<span class="function">set</span>(data);
<span class="keyword">const</span> result = instance.exports.<span class="function">processAll</span>(ptr, <span class="number">1000000</span>);  <span class="comment">// fast!</span></pre>
      </div>

      <h3>How to Benchmark Properly</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-lang">JavaScript</span></div>
        <pre><span class="comment">// Proper benchmarking with warmup</span>
<span class="keyword">function</span> <span class="function">benchmark</span>(fn, label, iterations = <span class="number">100</span>) {
  <span class="comment">// Warmup ‚Äî let JIT optimize JS</span>
  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i < <span class="number">10</span>; i++) <span class="function">fn</span>();

  <span class="keyword">const</span> start = performance.<span class="function">now</span>();
  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i < iterations; i++) {
    <span class="function">fn</span>();
  }
  <span class="keyword">const</span> elapsed = performance.<span class="function">now</span>() - start;
  console.<span class="function">log</span>(<span class="string">\`\${label}: \${(elapsed/iterations).toFixed(2)}ms avg\`</span>);
}

<span class="function">benchmark</span>(() => <span class="function">jsFibonacci</span>(<span class="number">40</span>), <span class="string">'JS Fibonacci'</span>);
<span class="function">benchmark</span>(() => wasmExports.<span class="function">fibonacci</span>(<span class="number">40</span>), <span class="string">'WASM Fibonacci'</span>);</pre>
      </div>

      <h3>Optimization Strategies</h3>
      <ul class="styled-list">
        <li><strong>Batch operations</strong> ‚Äî Move data into WASM memory, process all at once</li>
        <li><strong>Minimize boundary crossings</strong> ‚Äî Do loops inside WASM, not in JS calling WASM</li>
        <li><strong>Use SharedArrayBuffer</strong> ‚Äî For multi-threaded WASM with Web Workers</li>
        <li><strong>Cache compiled modules</strong> ‚Äî Store in IndexedDB for instant subsequent loads</li>
        <li><strong>Use SIMD</strong> ‚Äî WASM SIMD for parallel numeric operations</li>
        <li><strong>Stream compilation</strong> ‚Äî Always use <code>instantiateStreaming</code></li>
      </ul>

      <div class="key-point">
        <strong>Interview Answer:</strong> "WASM gives predictable, near-native performance for compute-heavy tasks because it's pre-compiled, has no GC pauses, and uses static types. But the JS‚ÜîWASM boundary has overhead, so you should batch operations and minimize crossings."
      </div>
    `
  },
  {
    id: 7,
    title: "WASM Memory Model",
    desc: "Linear memory, memory management, SharedArrayBuffer",
    icon: "üßÆ",
    content: `
      <h2>WASM Memory Model</h2>

      <div class="analogy">
        <div class="analogy-title">üí° Simple Analogy</div>
        <p>WASM memory is like a giant array of bytes (a continuous strip of numbered slots). Both JS and WASM can read from and write to any slot. It's like a shared whiteboard ‚Äî simple but you have to manage it yourself.</p>
      </div>

      <h3>Linear Memory</h3>
      <p>WASM uses <strong>linear memory</strong> ‚Äî a contiguous, byte-addressable block:</p>

      <div class="code-block">
        <div class="code-header"><span class="code-lang">JavaScript</span></div>
        <pre><span class="comment">// Create memory: initial 1 page (64KB), max 100 pages (6.4MB)</span>
<span class="keyword">const</span> memory = <span class="keyword">new</span> WebAssembly.<span class="function">Memory</span>({
  initial: <span class="number">1</span>,       <span class="comment">// 1 page = 65,536 bytes (64KB)</span>
  maximum: <span class="number">100</span>,     <span class="comment">// optional maximum</span>
  shared: <span class="keyword">false</span>,    <span class="comment">// true for multi-threading</span>
});

<span class="comment">// Access memory as different typed arrays</span>
<span class="keyword">const</span> bytes  = <span class="keyword">new</span> <span class="type">Uint8Array</span>(memory.buffer);      <span class="comment">// byte view</span>
<span class="keyword">const</span> ints   = <span class="keyword">new</span> <span class="type">Int32Array</span>(memory.buffer);      <span class="comment">// i32 view</span>
<span class="keyword">const</span> floats = <span class="keyword">new</span> <span class="type">Float64Array</span>(memory.buffer);    <span class="comment">// f64 view</span>

<span class="comment">// Memory layout:</span>
<span class="comment">// [0x0000]  [0x0001]  [0x0002]  ...  [0xFFFF]</span>
<span class="comment">// ‚ñ≤ byte 0  ‚ñ≤ byte 1  ‚ñ≤ byte 2       ‚ñ≤ byte 65535</span></pre>
      </div>

      <h3>Growing Memory</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-lang">JavaScript</span></div>
        <pre><span class="comment">// Grow by 2 pages (128KB more)</span>
<span class="keyword">const</span> oldSize = memory.<span class="function">grow</span>(<span class="number">2</span>);  <span class="comment">// returns old page count</span>
console.<span class="function">log</span>(memory.buffer.byteLength); <span class="comment">// now 192KB</span>

<span class="comment">// ‚ö†Ô∏è CRITICAL: After grow(), all typed array views are INVALID!</span>
<span class="comment">// You MUST re-create them:</span>
bytes  = <span class="keyword">new</span> <span class="type">Uint8Array</span>(memory.buffer);   <span class="comment">// re-create!</span>
ints   = <span class="keyword">new</span> <span class="type">Int32Array</span>(memory.buffer);   <span class="comment">// re-create!</span></pre>
      </div>

      <h3>Reading & Writing Complex Data</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-lang">JavaScript</span></div>
        <pre><span class="comment">// Writing a struct-like data to WASM memory</span>
<span class="comment">// C struct: { int x; int y; float velocity; }</span>

<span class="keyword">const</span> dataView = <span class="keyword">new</span> <span class="type">DataView</span>(memory.buffer);

<span class="comment">// Write at offset 0</span>
dataView.<span class="function">setInt32</span>(<span class="number">0</span>, <span class="number">100</span>, <span class="keyword">true</span>);    <span class="comment">// x = 100 (little-endian)</span>
dataView.<span class="function">setInt32</span>(<span class="number">4</span>, <span class="number">200</span>, <span class="keyword">true</span>);    <span class="comment">// y = 200</span>
dataView.<span class="function">setFloat32</span>(<span class="number">8</span>, <span class="number">3.14</span>, <span class="keyword">true</span>); <span class="comment">// velocity = 3.14</span>

<span class="comment">// Read back</span>
<span class="keyword">const</span> x = dataView.<span class="function">getInt32</span>(<span class="number">0</span>, <span class="keyword">true</span>);     <span class="comment">// 100</span>
<span class="keyword">const</span> y = dataView.<span class="function">getInt32</span>(<span class="number">4</span>, <span class="keyword">true</span>);     <span class="comment">// 200</span>
<span class="keyword">const</span> v = dataView.<span class="function">getFloat32</span>(<span class="number">8</span>, <span class="keyword">true</span>);  <span class="comment">// 3.14</span></pre>
      </div>

      <h3>SharedArrayBuffer for Multi-Threading</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-lang">JavaScript</span></div>
        <pre><span class="comment">// Shared memory between main thread and Web Worker</span>
<span class="keyword">const</span> sharedMemory = <span class="keyword">new</span> WebAssembly.<span class="function">Memory</span>({
  initial: <span class="number">1</span>,
  maximum: <span class="number">10</span>,
  shared: <span class="keyword">true</span>    <span class="comment">// enables SharedArrayBuffer</span>
});

<span class="comment">// Requires these response headers:</span>
<span class="comment">// Cross-Origin-Opener-Policy: same-origin</span>
<span class="comment">// Cross-Origin-Embedder-Policy: require-corp</span>

<span class="comment">// Use Atomics for thread-safe operations</span>
<span class="keyword">const</span> shared = <span class="keyword">new</span> <span class="type">Int32Array</span>(sharedMemory.buffer);
Atomics.<span class="function">store</span>(shared, <span class="number">0</span>, <span class="number">42</span>);
Atomics.<span class="function">load</span>(shared, <span class="number">0</span>);  <span class="comment">// 42</span></pre>
      </div>

      <div class="warning">
        <strong>Memory Leak Danger:</strong> Unlike JavaScript, WASM doesn't have automatic garbage collection. If your WASM code allocates memory (via malloc/alloc), you must manually free it. Leaked memory stays leaked until the module is unloaded.
      </div>
    `
  },
  {
    id: 8,
    title: "Tooling & Building WASM",
    desc: "Emscripten, wasm-pack, AssemblyScript, and build pipelines",
    icon: "üõ†Ô∏è",
    content: `
      <h2>Tooling & Building WASM</h2>

      <h3>Major Toolchains</h3>
      <table class="compare-table">
        <tr><th>Tool</th><th>Source Language</th><th>Best For</th></tr>
        <tr><td><strong>Emscripten</strong></td><td>C / C++</td><td>Porting existing C/C++ codebases</td></tr>
        <tr><td><strong>wasm-pack</strong></td><td>Rust</td><td>New WASM modules with great DX</td></tr>
        <tr><td><strong>AssemblyScript</strong></td><td>TypeScript-like</td><td>JS devs who want to write WASM</td></tr>
        <tr><td><strong>TinyGo</strong></td><td>Go</td><td>Go developers targeting WASM</td></tr>
        <tr><td><strong>wasm-bindgen</strong></td><td>Rust</td><td>High-level Rust‚ÜîJS interop</td></tr>
      </table>

      <h3>AssemblyScript (Easiest for JS Devs)</h3>
      <p>AssemblyScript looks like TypeScript but compiles to WASM:</p>
      <div class="code-block">
        <div class="code-header"><span class="code-lang">AssemblyScript</span></div>
        <pre><span class="comment">// assembly/index.ts ‚Äî looks like TypeScript!</span>
<span class="keyword">export function</span> <span class="function">fibonacci</span>(n: <span class="type">i32</span>): <span class="type">i32</span> {
  <span class="keyword">if</span> (n <= <span class="number">1</span>) <span class="keyword">return</span> n;
  <span class="keyword">return</span> <span class="function">fibonacci</span>(n - <span class="number">1</span>) + <span class="function">fibonacci</span>(n - <span class="number">2</span>);
}

<span class="keyword">export function</span> <span class="function">isPrime</span>(n: <span class="type">i32</span>): <span class="type">bool</span> {
  <span class="keyword">if</span> (n < <span class="number">2</span>) <span class="keyword">return</span> <span class="keyword">false</span>;
  <span class="keyword">for</span> (<span class="keyword">let</span> i: <span class="type">i32</span> = <span class="number">2</span>; i * i <= n; i++) {
    <span class="keyword">if</span> (n % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;
  }
  <span class="keyword">return</span> <span class="keyword">true</span>;
}</pre>
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-lang">Shell</span></div>
        <pre><span class="comment"># Install and build</span>
npm install --save-dev assemblyscript
npx asinit .
npm run asbuild

<span class="comment"># Output: build/release.wasm</span></pre>
      </div>

      <h3>Emscripten (C/C++ ‚Üí WASM)</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-lang">C</span></div>
        <pre><span class="comment">// hello.c</span>
<span class="keyword">#include</span> <span class="string">&lt;emscripten.h&gt;</span>

<span class="type">EMSCRIPTEN_KEEPALIVE</span>
<span class="type">int</span> <span class="function">add</span>(<span class="type">int</span> a, <span class="type">int</span> b) {
    <span class="keyword">return</span> a + b;
}

<span class="type">EMSCRIPTEN_KEEPALIVE</span>
<span class="type">int</span> <span class="function">factorial</span>(<span class="type">int</span> n) {
    <span class="keyword">if</span> (n <= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;
    <span class="keyword">return</span> n * <span class="function">factorial</span>(n - <span class="number">1</span>);
}</pre>
      </div>

      <div class="code-block">
        <div class="code-header"><span class="code-lang">Shell</span></div>
        <pre><span class="comment"># Compile C to WASM</span>
emcc hello.c -o hello.js \\
  -s EXPORTED_FUNCTIONS='["_add","_factorial"]' \\
  -s EXPORTED_RUNTIME_METHODS='["ccall","cwrap"]'

<span class="comment"># This generates: hello.wasm + hello.js (glue code)</span></pre>
      </div>

      <h3>Rust + wasm-pack (Best DX)</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-lang">Rust</span></div>
        <pre><span class="comment">// src/lib.rs</span>
<span class="keyword">use</span> wasm_bindgen::prelude::*;

<span class="type">#[wasm_bindgen]</span>
<span class="keyword">pub fn</span> <span class="function">greet</span>(name: &<span class="type">str</span>) -> <span class="type">String</span> {
    <span class="function">format!</span>(<span class="string">"Hello, {}!"</span>, name)
}

<span class="type">#[wasm_bindgen]</span>
<span class="keyword">pub fn</span> <span class="function">fibonacci</span>(n: <span class="type">u32</span>) -> <span class="type">u32</span> {
    <span class="keyword">match</span> n {
        <span class="number">0</span> | <span class="number">1</span> => n,
        _ => <span class="function">fibonacci</span>(n - <span class="number">1</span>) + <span class="function">fibonacci</span>(n - <span class="number">2</span>),
    }
}</pre>
      </div>

      <h3>Build Pipeline for Production</h3>
      <div class="flow-diagram">
        <div class="flow-step">
          <div class="step-label">Write</div>
          <div class="step-value">Rust / C / AS</div>
        </div>
        <div class="flow-arrow">‚Üí</div>
        <div class="flow-step">
          <div class="step-label">Compile</div>
          <div class="step-value">wasm-pack / emcc</div>
        </div>
        <div class="flow-arrow">‚Üí</div>
        <div class="flow-step">
          <div class="step-label">Optimize</div>
          <div class="step-value">wasm-opt -O3</div>
        </div>
        <div class="flow-arrow">‚Üí</div>
        <div class="flow-step">
          <div class="step-label">Bundle</div>
          <div class="step-value">Webpack / Vite</div>
        </div>
        <div class="flow-arrow">‚Üí</div>
        <div class="flow-step">
          <div class="step-label">Serve</div>
          <div class="step-value">CDN + CORS</div>
        </div>
      </div>

      <h3>Webpack Integration</h3>
      <div class="code-block">
        <div class="code-header"><span class="code-lang">JavaScript</span></div>
        <pre><span class="comment">// webpack.config.js</span>
module.exports = {
  experiments: {
    asyncWebAssembly: <span class="keyword">true</span>,  <span class="comment">// Enable WASM support</span>
  },
};

<span class="comment">// In your app code:</span>
<span class="keyword">import</span> { add, fibonacci } <span class="keyword">from</span> <span class="string">'./math.wasm'</span>;

console.<span class="function">log</span>(<span class="function">add</span>(<span class="number">1</span>, <span class="number">2</span>));        <span class="comment">// 3</span>
console.<span class="function">log</span>(<span class="function">fibonacci</span>(<span class="number">10</span>));  <span class="comment">// 55</span></pre>
      </div>

      <div class="key-point">
        <strong>For JS developers:</strong> Start with <strong>AssemblyScript</strong> ‚Äî the syntax is almost identical to TypeScript. You can write WASM modules without learning a new language!
      </div>
    `
  }
];

// ====================== QUIZ DATA ======================
const quizData = [
  {
    q: "What is WebAssembly?",
    options: [
      "A new programming language that replaces JavaScript",
      "A low-level binary instruction format that runs in browsers at near-native speed",
      "A JavaScript framework for building web applications",
      "A browser plugin for running desktop applications"
    ],
    correct: 1,
    explanation: "WebAssembly is a binary instruction format designed as a compilation target for languages like C, C++, and Rust. It runs alongside JavaScript, not as a replacement."
  },
  {
    q: "Which of these is NOT a valid WASM value type?",
    options: ["i32", "f64", "string", "i64"],
    correct: 2,
    explanation: "WASM only has 4 value types: i32, i64, f32, f64. Strings must be passed through linear memory as bytes."
  },
  {
    q: "What is the recommended way to load a WASM module?",
    options: [
      "WebAssembly.compile()",
      "WebAssembly.instantiateStreaming()",
      "import 'module.wasm'",
      "require('module.wasm')"
    ],
    correct: 1,
    explanation: "instantiateStreaming() is the most efficient ‚Äî it compiles while downloading. It requires the correct MIME type (application/wasm)."
  },
  {
    q: "How large is one WASM memory page?",
    options: ["4KB", "16KB", "64KB", "1MB"],
    correct: 2,
    explanation: "One WASM memory page is exactly 65,536 bytes (64KB). Memory grows in page-sized increments."
  },
  {
    q: "Can WebAssembly directly manipulate the DOM?",
    options: [
      "Yes, through built-in DOM APIs",
      "No, it must use JavaScript as a bridge",
      "Only in Chrome",
      "Yes, but only with special permissions"
    ],
    correct: 1,
    explanation: "WASM cannot directly access the DOM. It must call JavaScript functions (provided via the import object) to interact with the DOM."
  },
  {
    q: "What happens when WASM memory grows via memory.grow()?",
    options: [
      "Nothing special, views stay valid",
      "The module crashes",
      "All existing typed array views become invalid (detached)",
      "It automatically updates all views"
    ],
    correct: 2,
    explanation: "When memory grows, the underlying ArrayBuffer is detached and replaced. All typed array views (Uint8Array, Int32Array, etc.) become invalid and must be re-created."
  },
  {
    q: "Which tool would a JavaScript developer use to write WebAssembly most easily?",
    options: ["Emscripten", "wasm-pack", "AssemblyScript", "LLVM"],
    correct: 2,
    explanation: "AssemblyScript uses TypeScript-like syntax, making it the easiest entry point for JavaScript developers. No need to learn C, C++, or Rust."
  },
  {
    q: "What is the import object used for when loading WASM?",
    options: [
      "Importing CSS styles into the WASM module",
      "Providing JavaScript functions and memory that WASM can access",
      "Importing other WASM modules",
      "Defining the module's export structure"
    ],
    correct: 1,
    explanation: "The import object provides WASM with access to JavaScript functions, memory objects, tables, and globals that the WASM module declared as imports."
  },
  {
    q: "When would WASM NOT be a good choice?",
    options: [
      "Image processing in the browser",
      "DOM manipulation and UI event handling",
      "Real-time audio synthesis",
      "Running a physics engine"
    ],
    correct: 1,
    explanation: "WASM can't access the DOM directly and has overhead for boundary crossings. DOM manipulation should stay in JavaScript."
  },
  {
    q: "What MIME type must the server use for .wasm files with instantiateStreaming?",
    options: [
      "application/octet-stream",
      "application/wasm",
      "text/wasm",
      "binary/wasm"
    ],
    correct: 1,
    explanation: "instantiateStreaming requires 'application/wasm' MIME type. Without it, the browser will reject the response."
  },
  {
    q: "Why is WASM faster than JavaScript for computation?",
    options: [
      "It uses a faster network protocol",
      "It skips security checks",
      "It's pre-compiled with static types, so no JIT warmup or type speculation needed",
      "It runs on a separate CPU core"
    ],
    correct: 2,
    explanation: "WASM is pre-compiled to efficient binary code with known types. JS needs JIT compilation, type speculation, and potential deoptimization ‚Äî all of which add overhead."
  },
  {
    q: "What is the WAT format?",
    options: [
      "WebAssembly Transformation ‚Äî a build tool",
      "WebAssembly Text ‚Äî human-readable S-expression format of WASM",
      "WebAssembly Testing ‚Äî a testing framework",
      "WebAssembly Template ‚Äî a boilerplate generator"
    ],
    correct: 1,
    explanation: "WAT (WebAssembly Text) is the human-readable text representation of WASM binary. It uses S-expressions (like Lisp) and is useful for debugging."
  },
  {
    q: "How do you pass a string from JavaScript to WASM?",
    options: [
      "Directly as a function parameter",
      "Using JSON.stringify()",
      "Write the string bytes into linear memory and pass a pointer + length",
      "Convert to a number first"
    ],
    correct: 2,
    explanation: "WASM has no string type. You must encode the string to bytes, write them into WASM linear memory, then pass the memory offset (pointer) and byte length to the WASM function."
  },
  {
    q: "What is a common performance anti-pattern with WASM?",
    options: [
      "Using typed arrays",
      "Calling WASM functions millions of times from a JS loop (excessive boundary crossings)",
      "Using WebAssembly.Memory",
      "Compiling with optimization flags"
    ],
    correct: 1,
    explanation: "Each JS‚ÜîWASM boundary crossing has overhead. Instead of calling WASM per-item in a JS loop, write all data to WASM memory and let WASM loop internally."
  },
  {
    q: "Which object represents compiled WASM code that can be cached and re-instantiated?",
    options: [
      "WebAssembly.Instance",
      "WebAssembly.Module",
      "WebAssembly.Memory",
      "WebAssembly.Global"
    ],
    correct: 1,
    explanation: "WebAssembly.Module is the compiled, stateless representation. It can be cached (e.g., in IndexedDB) and instantiated multiple times with different imports."
  },
  {
    q: "What does WebAssembly.Memory represent?",
    options: [
      "The browser's RAM allocation",
      "A resizable ArrayBuffer shared between JS and WASM",
      "Cache storage for WASM modules",
      "The call stack"
    ],
    correct: 1,
    explanation: "WebAssembly.Memory is a resizable ArrayBuffer that serves as WASM's linear memory. Both JS and WASM can read/write to it."
  },
  {
    q: "Does WebAssembly have garbage collection?",
    options: [
      "Yes, like JavaScript",
      "No, memory must be managed manually (or by the source language's runtime)",
      "Only for strings",
      "Yes, but only in Chrome"
    ],
    correct: 1,
    explanation: "WASM does not have built-in GC (though a GC proposal exists). Languages compiled to WASM either manage memory manually (C/C++) or bundle their own GC (Go)."
  },
  {
    q: "What tool compiles C/C++ code to WebAssembly?",
    options: ["wasm-pack", "Babel", "Emscripten", "TypeScript compiler"],
    correct: 2,
    explanation: "Emscripten is the primary toolchain for compiling C and C++ to WebAssembly. It also generates JavaScript glue code."
  },
  {
    q: "What is WASM SIMD?",
    options: [
      "A debugging protocol",
      "Single Instruction Multiple Data ‚Äî parallel processing of multiple values",
      "A memory management technique",
      "A way to call multiple functions at once"
    ],
    correct: 1,
    explanation: "SIMD (Single Instruction Multiple Data) lets WASM process multiple numeric values in a single instruction, greatly speeding up tasks like image processing and physics."
  },
  {
    q: "Which company's product (a design tool) is a famous example of WASM in production?",
    options: ["Slack", "Figma", "Notion", "Discord"],
    correct: 1,
    explanation: "Figma uses WASM (compiled from C++) for its rendering engine, achieving 3x faster load times compared to their previous asm.js implementation."
  },
  {
    q: "How do you handle errors from WASM in JavaScript?",
    options: [
      "WASM has its own error system",
      "Use try/catch ‚Äî WASM traps become JavaScript exceptions",
      "Check a global error variable",
      "WASM never produces errors"
    ],
    correct: 1,
    explanation: "WASM traps (like division by zero or out-of-bounds memory access) are converted to JavaScript exceptions that can be caught with try/catch."
  },
  {
    q: "What is the binary magic number that starts every .wasm file?",
    options: ["\\0wasm", "\\0asm", "WASM", "0x1F8B"],
    correct: 1,
    explanation: "Every valid .wasm file starts with the bytes \\0asm (hex: 00 61 73 6D), followed by the version number (01 00 00 00 for version 1)."
  },
  {
    q: "For multi-threaded WASM, which JavaScript API must you use for thread-safe memory access?",
    options: ["Promise.all()", "Atomics", "async/await", "Web Locks API"],
    correct: 1,
    explanation: "When using SharedArrayBuffer with multi-threaded WASM (via Web Workers), you must use the Atomics API for thread-safe read/write operations."
  },
  {
    q: "What HTTP headers are required for SharedArrayBuffer (needed for WASM threads)?",
    options: [
      "Content-Security-Policy: wasm-unsafe-eval",
      "Cross-Origin-Opener-Policy: same-origin AND Cross-Origin-Embedder-Policy: require-corp",
      "X-WASM-Threading: enabled",
      "Access-Control-Allow-Origin: *"
    ],
    correct: 1,
    explanation: "SharedArrayBuffer requires COOP (Cross-Origin-Opener-Policy: same-origin) and COEP (Cross-Origin-Embedder-Policy: require-corp) headers for security."
  },
  {
    q: "Which statement about WASM and JavaScript is TRUE?",
    options: [
      "WASM will eventually replace JavaScript completely",
      "WASM is always faster than JavaScript for every task",
      "WASM and JS are designed to complement each other, with WASM handling compute-heavy tasks",
      "WASM can only run C++ code"
    ],
    correct: 2,
    explanation: "WASM complements JS ‚Äî it excels at computation while JS excels at DOM, events, and I/O. WASM supports many source languages, not just C++."
  }
];

// ====================== EXERCISES DATA ======================
const exercises = [
  {
    id: 1,
    title: "Load a WASM Module (Streaming)",
    difficulty: "easy",
    description: "Write a function that uses WebAssembly.instantiateStreaming to load a WASM module from 'math.wasm' and return the instance's exports.",
    starter: `async function loadWasmModule() {\n  // Your code here\n  // 1. Fetch 'math.wasm'\n  // 2. Use instantiateStreaming\n  // 3. Return instance.exports\n}`,
    solution: `async function loadWasmModule() {\n  const { instance } = await WebAssembly.instantiateStreaming(\n    fetch('math.wasm')\n  );\n  return instance.exports;\n}`,
    check: (code) => {
      return code.includes('instantiateStreaming') &&
             code.includes('fetch') &&
             code.includes('instance') &&
             code.includes('exports');
    }
  },
  {
    id: 2,
    title: "Create an Import Object",
    difficulty: "easy",
    description: "Create an importObject with an 'env' namespace containing: a Memory (1 page), and a 'log' function that logs to console.",
    starter: `const importObject = {\n  // Your code here\n  // Create env namespace with:\n  // - memory: 1 page WebAssembly.Memory\n  // - log: function that console.logs\n};`,
    solution: `const importObject = {\n  env: {\n    memory: new WebAssembly.Memory({ initial: 1 }),\n    log: (value) => console.log('WASM:', value),\n  }\n};`,
    check: (code) => {
      return code.includes('env') &&
             code.includes('WebAssembly.Memory') &&
             code.includes('initial') &&
             code.includes('log') &&
             code.includes('console.log');
    }
  },
  {
    id: 3,
    title: "Write String to WASM Memory",
    difficulty: "medium",
    description: "Write a function that takes a WebAssembly.Memory, a string, and an offset, and writes the string into memory at that offset. Return the byte length written.",
    starter: `function writeStringToMemory(memory, str, offset) {\n  // Your code here\n  // 1. Create a TextEncoder\n  // 2. Encode the string\n  // 3. Create Uint8Array view of memory\n  // 4. Write encoded bytes at offset\n  // 5. Return byte length\n}`,
    solution: `function writeStringToMemory(memory, str, offset) {\n  const encoder = new TextEncoder();\n  const encoded = encoder.encode(str);\n  const view = new Uint8Array(memory.buffer);\n  view.set(encoded, offset);\n  return encoded.byteLength;\n}`,
    check: (code) => {
      return code.includes('TextEncoder') &&
             code.includes('encode') &&
             code.includes('Uint8Array') &&
             code.includes('.set(') &&
             code.includes('byteLength');
    }
  },
  {
    id: 4,
    title: "Read String from WASM Memory",
    difficulty: "medium",
    description: "Write a function that reads a string from WASM memory given a pointer (offset) and length.",
    starter: `function readStringFromMemory(memory, ptr, len) {\n  // Your code here\n  // 1. Create Uint8Array view of the specific region\n  // 2. Use TextDecoder to decode it\n  // 3. Return the string\n}`,
    solution: `function readStringFromMemory(memory, ptr, len) {\n  const bytes = new Uint8Array(memory.buffer, ptr, len);\n  const decoder = new TextDecoder();\n  return decoder.decode(bytes);\n}`,
    check: (code) => {
      return code.includes('Uint8Array') &&
             code.includes('TextDecoder') &&
             code.includes('decode');
    }
  },
  {
    id: 5,
    title: "Benchmark JS vs WASM",
    difficulty: "medium",
    description: "Write a benchmark function that runs a function N times with warmup, and returns average milliseconds per run.",
    starter: `function benchmark(fn, iterations = 100, warmup = 10) {\n  // Your code here\n  // 1. Run fn() warmup times (don't measure)\n  // 2. Record start time with performance.now()\n  // 3. Run fn() iterations times\n  // 4. Record end time\n  // 5. Return average ms per iteration\n}`,
    solution: `function benchmark(fn, iterations = 100, warmup = 10) {\n  // Warmup\n  for (let i = 0; i < warmup; i++) fn();\n  \n  const start = performance.now();\n  for (let i = 0; i < iterations; i++) {\n    fn();\n  }\n  const elapsed = performance.now() - start;\n  return elapsed / iterations;\n}`,
    check: (code) => {
      return code.includes('performance.now') &&
             code.includes('warmup') &&
             code.includes('iterations') &&
             (code.includes('elapsed') || code.includes('end') || code.includes('duration'));
    }
  },
  {
    id: 6,
    title: "Safe Memory View Helper",
    difficulty: "medium",
    description: "Write a function that safely creates a typed array view of WASM memory. It should handle the case where memory may have been grown (buffer detached).",
    starter: `function getMemoryView(memory, TypedArray, offset, length) {\n  // Your code here\n  // Always create a FRESH view from memory.buffer\n  // This handles the case where memory.grow() was called\n  // Return the new typed array view\n}`,
    solution: `function getMemoryView(memory, TypedArray, offset = 0, length) {\n  // Always create fresh view ‚Äî buffer may have been replaced by grow()\n  if (length !== undefined) {\n    return new TypedArray(memory.buffer, offset, length);\n  }\n  return new TypedArray(memory.buffer, offset);\n}`,
    check: (code) => {
      return code.includes('memory.buffer') &&
             code.includes('new') &&
             code.includes('TypedArray') &&
             code.includes('return');
    }
  },
  {
    id: 7,
    title: "WASM Module Cache",
    difficulty: "hard",
    description: "Write a function that loads a WASM module, caches the compiled Module in a Map, and reuses it on subsequent calls for the same URL.",
    starter: `const moduleCache = new Map();\n\nasync function loadCachedWasm(url, imports = {}) {\n  // Your code here\n  // 1. Check if module is in cache\n  // 2. If not, fetch & compile, store in cache\n  // 3. Instantiate from cached module\n  // 4. Return instance\n}`,
    solution: `const moduleCache = new Map();\n\nasync function loadCachedWasm(url, imports = {}) {\n  let module = moduleCache.get(url);\n  \n  if (!module) {\n    const response = await fetch(url);\n    const bytes = await response.arrayBuffer();\n    module = await WebAssembly.compile(bytes);\n    moduleCache.set(url, module);\n  }\n  \n  const instance = await WebAssembly.instantiate(module, imports);\n  return instance;\n}`,
    check: (code) => {
      return code.includes('moduleCache') &&
             (code.includes('.get(') || code.includes('.has(')) &&
             code.includes('.set(') &&
             code.includes('WebAssembly.compile') &&
             code.includes('WebAssembly.instantiate');
    }
  },
  {
    id: 8,
    title: "Pass Array to WASM",
    difficulty: "hard",
    description: "Write a function that writes a JavaScript Float64Array into WASM memory and calls a WASM function to process it.",
    starter: `function processArrayInWasm(instance, jsArray) {\n  // Your code here\n  // 1. Get WASM memory\n  // 2. Allocate space using instance.exports.alloc()\n  // 3. Create Float64Array view at the pointer\n  // 4. Copy jsArray into it\n  // 5. Call instance.exports.processData(ptr, length)\n  // 6. Free with instance.exports.dealloc(ptr)\n  // 7. Return result\n}`,
    solution: `function processArrayInWasm(instance, jsArray) {\n  const memory = instance.exports.memory;\n  const byteLength = jsArray.length * 8; // 8 bytes per f64\n  const ptr = instance.exports.alloc(byteLength);\n  \n  const view = new Float64Array(memory.buffer, ptr, jsArray.length);\n  view.set(jsArray);\n  \n  const result = instance.exports.processData(ptr, jsArray.length);\n  \n  instance.exports.dealloc(ptr);\n  return result;\n}`,
    check: (code) => {
      return code.includes('Float64Array') &&
             code.includes('.set(') &&
             code.includes('alloc') &&
             code.includes('dealloc') &&
             code.includes('processData');
    }
  },
  {
    id: 9,
    title: "Error-Safe WASM Loader",
    difficulty: "hard",
    description: "Write a robust WASM loader that tries instantiateStreaming first, falls back to instantiate with ArrayBuffer, and handles errors.",
    starter: `async function robustLoadWasm(url, imports = {}) {\n  // Your code here\n  // 1. Try instantiateStreaming first\n  // 2. If it fails (wrong MIME type), fall back:\n  //    a. fetch the URL\n  //    b. get arrayBuffer\n  //    c. use WebAssembly.instantiate with the buffer\n  // 3. Return { instance, module }\n}`,
    solution: `async function robustLoadWasm(url, imports = {}) {\n  try {\n    // Try streaming first (fastest)\n    const result = await WebAssembly.instantiateStreaming(\n      fetch(url), imports\n    );\n    return result;\n  } catch (e) {\n    // Fallback: fetch as ArrayBuffer\n    console.warn('Streaming failed, using fallback:', e.message);\n    const response = await fetch(url);\n    const bytes = await response.arrayBuffer();\n    const result = await WebAssembly.instantiate(bytes, imports);\n    return result;\n  }\n}`,
    check: (code) => {
      return code.includes('instantiateStreaming') &&
             code.includes('catch') &&
             code.includes('arrayBuffer') &&
             code.includes('WebAssembly.instantiate') &&
             code.includes('fetch');
    }
  },
  {
    id: 10,
    title: "WASM-Powered Web Worker",
    difficulty: "hard",
    description: "Write a Web Worker message handler that loads WASM, processes data from the main thread, and sends back results.",
    starter: `// worker.js\nself.onmessage = async function(e) {\n  // Your code here\n  // 1. On 'init' message: load WASM module\n  // 2. On 'process' message:\n  //    a. Get data from e.data.payload\n  //    b. Call WASM export to process it\n  //    c. postMessage the result back\n};`,
    solution: `// worker.js\nlet wasmInstance = null;\n\nself.onmessage = async function(e) {\n  const { type, payload } = e.data;\n  \n  if (type === 'init') {\n    const { instance } = await WebAssembly.instantiateStreaming(\n      fetch(payload.wasmUrl)\n    );\n    wasmInstance = instance;\n    self.postMessage({ type: 'ready' });\n  }\n  \n  if (type === 'process' && wasmInstance) {\n    const result = wasmInstance.exports.compute(payload.value);\n    self.postMessage({ type: 'result', data: result });\n  }\n};`,
    check: (code) => {
      return code.includes('onmessage') &&
             code.includes('postMessage') &&
             code.includes('WebAssembly') &&
             code.includes('instance') &&
             code.includes('exports');
    }
  }
];

// ====================== PITFALLS DATA ======================
const pitfalls = [
  {
    title: "Thinking WASM replaces JavaScript",
    icon: "üö´",
    content: `
      <p>This is the #1 misconception. WASM is designed to <em>work alongside</em> JavaScript, not replace it.</p>
      <div class="vs-container">
        <div class="vs-box vs-bad">
          <div class="vs-label">‚ùå Wrong Thinking</div>
          <div class="code-block" style="margin:0;border-radius:0;">
            <pre>"Let's rewrite our entire React app in WASM!"
"WASM is faster so we should use it for everything"
"JavaScript is dead, WASM is the future"</pre>
          </div>
        </div>
        <div class="vs-box vs-good">
          <div class="vs-label">‚úÖ Correct Thinking</div>
          <div class="code-block" style="margin:0;border-radius:0;">
            <pre>"Our image processing is slow ‚Äî let's move
THAT specific logic to WASM"
"WASM for compute, JS for DOM/UI/I/O"
"They complement each other"</pre>
          </div>
        </div>
      </div>
    `
  },
  {
    title: "Forgetting the MIME type for instantiateStreaming",
    icon: "üì°",
    content: `
      <p><code>WebAssembly.instantiateStreaming()</code> requires the server to send .wasm files with MIME type <code>application/wasm</code>.</p>
      <div class="code-block">
        <div class="code-header"><span class="code-lang">Error</span></div>
        <pre><span class="comment">// TypeError: Failed to execute 'compile' on 'WebAssembly':</span>
<span class="comment">// Incorrect response MIME type. Expected 'application/wasm'.</span></pre>
      </div>
      <p><strong>Fix:</strong> Configure your server, or use the fallback pattern:</p>
      <div class="code-block">
        <div class="code-header"><span class="code-lang">JavaScript</span></div>
        <pre><span class="keyword">try</span> {
  result = <span class="keyword">await</span> WebAssembly.<span class="function">instantiateStreaming</span>(<span class="function">fetch</span>(url), imports);
} <span class="keyword">catch</span> (e) {
  <span class="keyword">const</span> resp = <span class="keyword">await</span> <span class="function">fetch</span>(url);
  <span class="keyword">const</span> bytes = <span class="keyword">await</span> resp.<span class="function">arrayBuffer</span>();
  result = <span class="keyword">await</span> WebAssembly.<span class="function">instantiate</span>(bytes, imports);
}</pre>
      </div>
    `
  },
  {
    title: "Stale memory views after memory.grow()",
    icon: "üß†",
    content: `
      <p>When WASM memory grows, the underlying ArrayBuffer is <strong>detached</strong>. Any typed array views you created become <strong>completely invalid</strong>.</p>
      <div class="vs-container">
        <div class="vs-box vs-bad">
          <div class="vs-label">‚ùå Bug: Stale View</div>
          <div class="code-block" style="margin:0;border-radius:0;">
            <pre><span class="keyword">const</span> view = <span class="keyword">new</span> Uint8Array(memory.buffer);
<span class="comment">// ... later, WASM calls memory.grow()</span>
view[0] = <span class="number">42</span>; <span class="comment">// üí• TypeError! Buffer detached!</span></pre>
          </div>
        </div>
        <div class="vs-box vs-good">
          <div class="vs-label">‚úÖ Always Re-create Views</div>
          <div class="code-block" style="margin:0;border-radius:0;">
            <pre><span class="comment">// Re-create view every time you need it</span>
<span class="keyword">function</span> <span class="function">getView</span>() {
  <span class="keyword">return new</span> Uint8Array(memory.buffer);
}
<span class="function">getView</span>()[<span class="number">0</span>] = <span class="number">42</span>; <span class="comment">// ‚úÖ Always fresh</span></pre>
          </div>
        </div>
      </div>
    `
  },
  {
    title: "Excessive JS‚ÜîWASM boundary crossings",
    icon: "üîÑ",
    content: `
      <p>Each call from JS to WASM (or vice versa) has overhead. Calling WASM in a tight loop is an anti-pattern.</p>
      <div class="vs-container">
        <div class="vs-box vs-bad">
          <div class="vs-label">‚ùå Slow: Million crossings</div>
          <div class="code-block" style="margin:0;border-radius:0;">
            <pre><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i < <span class="number">1000000</span>; i++) {
  sum += wasm.exports.<span class="function">square</span>(data[i]);
}
<span class="comment">// 1 million boundary crossings!</span></pre>
          </div>
        </div>
        <div class="vs-box vs-good">
          <div class="vs-label">‚úÖ Fast: One crossing</div>
          <div class="code-block" style="margin:0;border-radius:0;">
            <pre><span class="comment">// Copy data to WASM memory</span>
view.<span class="function">set</span>(data, ptr);
<span class="comment">// One call ‚Äî WASM loops internally</span>
sum = wasm.exports.<span class="function">sumSquares</span>(ptr, len);
<span class="comment">// 1 boundary crossing!</span></pre>
          </div>
        </div>
      </div>
    `
  },
  {
    title: "Memory leaks in WASM",
    icon: "üíß",
    content: `
      <p>WASM has <strong>no garbage collector</strong>. If your source language (C/C++) allocates memory, you MUST free it manually.</p>
      <div class="vs-container">
        <div class="vs-box vs-bad">
          <div class="vs-label">‚ùå Memory Leak</div>
          <div class="code-block" style="margin:0;border-radius:0;">
            <pre><span class="keyword">const</span> ptr = wasm.exports.<span class="function">alloc</span>(<span class="number">1024</span>);
<span class="comment">// ... use memory ...</span>
<span class="comment">// forgot to call dealloc! üíß Leaked!</span></pre>
          </div>
        </div>
        <div class="vs-box vs-good">
          <div class="vs-label">‚úÖ Proper Cleanup</div>
          <div class="code-block" style="margin:0;border-radius:0;">
            <pre><span class="keyword">const</span> ptr = wasm.exports.<span class="function">alloc</span>(<span class="number">1024</span>);
<span class="keyword">try</span> {
  <span class="comment">// ... use memory ...</span>
} <span class="keyword">finally</span> {
  wasm.exports.<span class="function">dealloc</span>(ptr); <span class="comment">// ‚úÖ Always free</span>
}</pre>
          </div>
        </div>
      </div>
    `
  },
  {
    title: "Not benchmarking properly (no JIT warmup)",
    icon: "üìä",
    content: `
      <p>JavaScript gets faster after JIT warmup. If you benchmark JS cold vs WASM, you get misleading results.</p>
      <div class="vs-container">
        <div class="vs-box vs-bad">
          <div class="vs-label">‚ùå Unfair Benchmark</div>
          <div class="code-block" style="margin:0;border-radius:0;">
            <pre><span class="comment">// No warmup ‚Äî JS hasn't JIT-compiled yet</span>
<span class="keyword">const</span> start = performance.<span class="function">now</span>();
<span class="function">jsFn</span>();  <span class="comment">// slow (cold)</span>
console.<span class="function">log</span>(performance.<span class="function">now</span>() - start);</pre>
          </div>
        </div>
        <div class="vs-box vs-good">
          <div class="vs-label">‚úÖ Fair Benchmark</div>
          <div class="code-block" style="margin:0;border-radius:0;">
            <pre><span class="comment">// Warmup rounds first</span>
<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i < <span class="number">100</span>; i++) <span class="function">jsFn</span>();
<span class="keyword">const</span> start = performance.<span class="function">now</span>();
<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i < <span class="number">1000</span>; i++) <span class="function">jsFn</span>();
<span class="comment">// Average over many runs</span></pre>
          </div>
        </div>
      </div>
    `
  },
  {
    title: "Using WASM for string-heavy operations",
    icon: "üìù",
    content: `
      <p>WASM has no native string type. Every string operation requires encoding/decoding through linear memory ‚Äî which can make it <em>slower</em> than pure JS.</p>
      <div class="danger">
        <strong>Don't use WASM for:</strong> Template rendering, HTML generation, JSON parsing, URL manipulation, regex-heavy processing. JavaScript's engine is highly optimized for string operations.
      </div>
    `
  },
  {
    title: "Forgetting endianness",
    icon: "üîÄ",
    content: `
      <p>WASM uses <strong>little-endian</strong> byte order. When reading/writing multi-byte values through DataView, you must specify <code>true</code> for little-endian.</p>
      <div class="code-block">
        <div class="code-header"><span class="code-lang">JavaScript</span></div>
        <pre><span class="keyword">const</span> dv = <span class="keyword">new</span> DataView(memory.buffer);
<span class="comment">// ‚ùå Forgetting endianness (defaults to big-endian)</span>
dv.<span class="function">setInt32</span>(<span class="number">0</span>, <span class="number">42</span>);            <span class="comment">// Wrong byte order!</span>

<span class="comment">// ‚úÖ Specify little-endian</span>
dv.<span class="function">setInt32</span>(<span class="number">0</span>, <span class="number">42</span>, <span class="keyword">true</span>);      <span class="comment">// Correct!</span></pre>
      </div>
      <p>Note: Typed arrays (Int32Array, etc.) automatically use the platform's native byte order, which is little-endian on all common platforms.</p>
    `
  },
  {
    title: "Not caching compiled modules",
    icon: "üíæ",
    content: `
      <p>Compiling WASM takes time. For repeat visits, cache the compiled Module in IndexedDB.</p>
      <div class="code-block">
        <div class="code-header"><span class="code-lang">JavaScript</span></div>
        <pre><span class="comment">// Cache in IndexedDB for instant loads on return visits</span>
<span class="keyword">async function</span> <span class="function">getCachedModule</span>(url) {
  <span class="keyword">const</span> db = <span class="keyword">await</span> <span class="function">openDB</span>();
  <span class="keyword">let</span> module = <span class="keyword">await</span> db.<span class="function">get</span>(<span class="string">'wasm-cache'</span>, url);

  <span class="keyword">if</span> (!module) {
    <span class="keyword">const</span> bytes = <span class="keyword">await</span> (<span class="keyword">await</span> <span class="function">fetch</span>(url)).<span class="function">arrayBuffer</span>();
    module = <span class="keyword">await</span> WebAssembly.<span class="function">compile</span>(bytes);
    <span class="keyword">await</span> db.<span class="function">put</span>(<span class="string">'wasm-cache'</span>, module, url);
  }

  <span class="keyword">return</span> WebAssembly.<span class="function">instantiate</span>(module, imports);
}</pre>
      </div>
    `
  },
  {
    title: "Assuming WASM is always faster",
    icon: "üê¢",
    content: `
      <p>WASM is NOT always faster. In many scenarios, modern JS engines are just as fast or faster:</p>
      <ul class="styled-list">
        <li>Small functions with simple logic (JIT makes them blazing fast)</li>
        <li>Operations where WASM startup time dominates execution time</li>
        <li>String operations (JS is native, WASM needs marshaling)</li>
        <li>Cases where boundary crossing overhead exceeds computation savings</li>
      </ul>
      <div class="key-point">
        <strong>Rule:</strong> Always benchmark your specific use case. Don't assume ‚Äî measure!
      </div>
    `
  },
  {
    title: "Ignoring WASM module size",
    icon: "üì¶",
    content: `
      <p>Large WASM modules increase initial load time. A 5MB WASM file will hurt performance even if computation is fast.</p>
      <ul class="styled-list">
        <li>Use <code>wasm-opt -Oz</code> to minimize size</li>
        <li>Use <code>wasm-strip</code> to remove debug info</li>
        <li>Lazy-load WASM only when needed</li>
        <li>Use code splitting ‚Äî don't ship what you don't need</li>
        <li>Enable gzip/brotli compression on server (WASM compresses well)</li>
      </ul>
    `
  },
  {
    title: "Not handling WASM traps",
    icon: "üí•",
    content: `
      <p>WASM operations can "trap" (crash) on errors like division by zero, out-of-bounds memory access, or unreachable code. These become JS exceptions.</p>
      <div class="code-block">
        <div class="code-header"><span class="code-lang">JavaScript</span></div>
        <pre><span class="keyword">try</span> {
  <span class="comment">// This might trap if WASM accesses invalid memory</span>
  <span class="keyword">const</span> result = wasm.exports.<span class="function">riskyOperation</span>(<span class="number">42</span>);
} <span class="keyword">catch</span> (e) {
  <span class="keyword">if</span> (e <span class="keyword">instanceof</span> WebAssembly.RuntimeError) {
    console.<span class="function">error</span>(<span class="string">'WASM trap:'</span>, e.message);
    <span class="comment">// "unreachable", "out of bounds", "integer divide by zero"</span>
  }
}</pre>
      </div>
    `
  }
];

// ====================== CHEAT SHEET DATA ======================
const cheatItems = [
  {
    title: "üì• Loading WASM",
    code: `<span class="comment">// Best: Streaming (compiles while downloading)</span>
<span class="keyword">const</span> { instance, module } =
  <span class="keyword">await</span> WebAssembly.<span class="function">instantiateStreaming</span>(
    <span class="function">fetch</span>(<span class="string">'mod.wasm'</span>), importObj
  );

<span class="comment">// Fallback: ArrayBuffer</span>
<span class="keyword">const</span> bytes = <span class="keyword">await</span> (<span class="keyword">await</span> <span class="function">fetch</span>(<span class="string">'mod.wasm'</span>)).<span class="function">arrayBuffer</span>();
<span class="keyword">const</span> { instance } = <span class="keyword">await</span> WebAssembly.<span class="function">instantiate</span>(bytes);`
  },
  {
    title: "üì§ Import Object",
    code: `<span class="keyword">const</span> imports = {
  env: {
    memory: <span class="keyword">new</span> WebAssembly.<span class="function">Memory</span>({ initial: <span class="number">1</span> }),
    table: <span class="keyword">new</span> WebAssembly.<span class="function">Table</span>({
      initial: <span class="number">1</span>, element: <span class="string">'anyfunc'</span>
    }),
    <span class="function">log</span>: (v) => console.<span class="function">log</span>(v),
  }
};`
  },
  {
    title: "üìû Calling Functions",
    code: `<span class="comment">// JS ‚Üí WASM</span>
instance.exports.<span class="function">add</span>(<span class="number">2</span>, <span class="number">3</span>);

<span class="comment">// WASM ‚Üí JS (via import object)</span>
<span class="comment">// WASM calls env.log(42) ‚Üí runs your JS function</span>`
  },
  {
    title: "üßÆ Memory Operations",
    code: `<span class="keyword">const</span> mem = <span class="keyword">new</span> WebAssembly.<span class="function">Memory</span>({ initial: <span class="number">1</span> });
<span class="keyword">const</span> u8 = <span class="keyword">new</span> Uint8Array(mem.buffer);
<span class="keyword">const</span> i32 = <span class="keyword">new</span> Int32Array(mem.buffer);
<span class="keyword">const</span> f64 = <span class="keyword">new</span> Float64Array(mem.buffer);

mem.<span class="function">grow</span>(<span class="number">1</span>);  <span class="comment">// +64KB, re-create views!</span>
u8 = <span class="keyword">new</span> Uint8Array(mem.buffer); <span class="comment">// fresh!</span>`
  },
  {
    title: "üìù String Passing",
    code: `<span class="comment">// JS ‚Üí WASM memory</span>
<span class="keyword">const</span> enc = <span class="keyword">new</span> TextEncoder();
<span class="keyword">new</span> Uint8Array(mem.buffer).<span class="function">set</span>(
  enc.<span class="function">encode</span>(<span class="string">"hello"</span>), offset
);

<span class="comment">// WASM memory ‚Üí JS</span>
<span class="keyword">new</span> TextDecoder().<span class="function">decode</span>(
  <span class="keyword">new</span> Uint8Array(mem.buffer, ptr, len)
);`
  },
  {
    title: "üìä WASM Types (Only 4!)",
    code: `i32  <span class="comment">‚Äî 32-bit integer</span>
i64  <span class="comment">‚Äî 64-bit integer</span>
f32  <span class="comment">‚Äî 32-bit float</span>
f64  <span class="comment">‚Äî 64-bit float</span>

<span class="comment">No strings, no objects, no arrays, no booleans</span>
<span class="comment">Booleans: i32 (0=false, non-0=true)</span>`
  },
  {
    title: "üîç Key Objects",
    code: `WebAssembly.Module    <span class="comment">// compiled code (cacheable)</span>
WebAssembly.Instance  <span class="comment">// running module + state</span>
WebAssembly.Memory    <span class="comment">// resizable ArrayBuffer</span>
WebAssembly.Table     <span class="comment">// function references</span>
WebAssembly.Global    <span class="comment">// shared global variable</span>

<span class="comment">// Validation</span>
WebAssembly.<span class="function">validate</span>(bytes) <span class="comment">// ‚Üí true/false</span>`
  },
  {
    title: "‚ö†Ô∏è Error Handling",
    code: `<span class="keyword">try</span> {
  instance.exports.<span class="function">risky</span>();
} <span class="keyword">catch</span> (e) {
  <span class="keyword">if</span> (e <span class="keyword">instanceof</span> WebAssembly.CompileError)
    <span class="comment">// Invalid WASM binary</span>
  <span class="keyword">if</span> (e <span class="keyword">instanceof</span> WebAssembly.LinkError)
    <span class="comment">// Import mismatch</span>
  <span class="keyword">if</span> (e <span class="keyword">instanceof</span> WebAssembly.RuntimeError)
    <span class="comment">// Trap: div by 0, OOB, unreachable</span>
}`
  },
  {
    title: "‚ö° Performance Rules",
    code: `<span class="comment">1. Minimize JS‚ÜîWASM boundary crossings</span>
<span class="comment">2. Batch data ‚Üí process in WASM ‚Üí read results</span>
<span class="comment">3. Use instantiateStreaming (not instantiate)</span>
<span class="comment">4. Cache compiled Module in IndexedDB</span>
<span class="comment">5. Warmup JS before benchmarking</span>
<span class="comment">6. Use WASM for: math, loops, numeric data</span>
<span class="comment">7. Use JS for: DOM, strings, I/O, events</span>`
  },
  {
    title: "üõ†Ô∏è Toolchains",
    code: `<span class="comment">C/C++ ‚Üí Emscripten ‚Üí .wasm</span>
<span class="comment">Rust  ‚Üí wasm-pack  ‚Üí .wasm + JS glue</span>
<span class="comment">TS-like ‚Üí AssemblyScript ‚Üí .wasm</span>
<span class="comment">Go    ‚Üí TinyGo     ‚Üí .wasm</span>

<span class="comment">Optimize: wasm-opt -O3 input.wasm -o out.wasm</span>
<span class="comment">Strip:    wasm-strip module.wasm</span>`
  },
  {
    title: "üîê Security Model",
    code: `<span class="comment">‚úÖ Same sandbox as JavaScript</span>
<span class="comment">‚úÖ Same-origin policy applies</span>
<span class="comment">‚úÖ No raw system access</span>
<span class="comment">‚úÖ Memory bounds-checked</span>
<span class="comment">‚úÖ Can't access JS objects directly</span>

<span class="comment">SharedArrayBuffer requires:</span>
<span class="comment">COOP: same-origin</span>
<span class="comment">COEP: require-corp</span>`
  },
  {
    title: "üéØ When to Use WASM",
    code: `<span class="comment">‚úÖ USE: Image/video processing</span>
<span class="comment">‚úÖ USE: Gaming / physics engines</span>
<span class="comment">‚úÖ USE: Crypto / hashing</span>
<span class="comment">‚úÖ USE: Porting C++/Rust code to web</span>
<span class="comment">‚úÖ USE: Audio synthesis</span>
<span class="comment">‚úÖ USE: Scientific computation</span>

<span class="comment">‚ùå AVOID: DOM manipulation</span>
<span class="comment">‚ùå AVOID: String processing</span>
<span class="comment">‚ùå AVOID: Simple CRUD apps</span>
<span class="comment">‚ùå AVOID: Event handling</span>`
  }
];

// ====================== RENDER FUNCTIONS ======================

function renderLessonGrid() {
  const grid = document.getElementById('lessonGrid');
  grid.innerHTML = lessons.map(l => `
    <div class="lesson-card ${state.completedLessons.has(l.id) ? 'completed' : ''}" onclick="showLesson(${l.id})">
      <div class="lesson-num">Lesson ${l.id} of ${lessons.length}</div>
      <h3>${l.icon} ${l.title}</h3>
      <p>${l.desc}</p>
      <div class="lesson-status">${state.completedLessons.has(l.id) ? '‚úÖ' : 'üìñ'}</div>
    </div>
  `).join('');
}

function showLesson(id) {
  const lesson = lessons.find(l => l.id === id);
  if (!lesson) return;

  document.getElementById('lessonList').style.display = 'none';
  const content = document.getElementById('lessonContent');
  content.className = 'lesson-detail active fade-in';
  content.innerHTML = `
    <button class="back-btn" onclick="hideLesson()">‚Üê Back to Lessons</button>
    <div class="card">
      ${lesson.content}
      <button class="complete-btn ${state.completedLessons.has(id) ? 'completed' : ''}"
              onclick="toggleLesson(${id}, this)">
        ${state.completedLessons.has(id) ? '‚úÖ Completed' : '‚òê Mark as Complete'}
      </button>
    </div>
  `;
}

function hideLesson() {
  document.getElementById('lessonList').style.display = 'block';
  document.getElementById('lessonContent').className = 'lesson-detail';
  renderLessonGrid();
}

function toggleLesson(id, btn) {
  if (state.completedLessons.has(id)) {
    state.completedLessons.delete(id);
    btn.textContent = '‚òê Mark as Complete';
    btn.className = 'complete-btn';
  } else {
    state.completedLessons.add(id);
    btn.textContent = '‚úÖ Completed';
    btn.className = 'complete-btn completed';
    btn.classList.add('pulse');
  }
  saveState();
  updateProgress();
}

function renderQuizzes() {
  const container = document.getElementById('quizContainer');
  container.innerHTML = quizData.map((q, idx) => `
    <div class="quiz-question" id="quiz-${idx}">
      <h4>
        <span class="q-num">${idx + 1}</span>
        <span>${q.q}</span>
      </h4>
      <div class="quiz-options">
        ${q.options.map((opt, oi) => `
          <button class="quiz-option" data-quiz="${idx}" data-option="${oi}" onclick="selectOption(${idx}, ${oi}, this)">
            <span class="opt-letter">${String.fromCharCode(65 + oi)}</span>
            <span>${opt}</span>
          </button>
        `).join('')}
      </div>
      <div class="quiz-explanation" id="explanation-${idx}">${q.explanation}</div>
    </div>
  `).join('');
}

function selectOption(qIdx, optIdx, btn) {
  if (state.quizSubmitted) return;
  const options = document.querySelectorAll(`[data-quiz="${qIdx}"]`);
  options.forEach(o => o.classList.remove('selected', 'correct', 'incorrect'));
  btn.classList.add('selected');
  state.quizAnswers[qIdx] = optIdx;
}

function submitQuiz() {
  if (Object.keys(state.quizAnswers).length < quizData.length) {
    const unanswered = quizData.length - Object.keys(state.quizAnswers).length;
    if (!confirm(`You have ${unanswered} unanswered question(s). Submit anyway?`)) return;
  }

  state.quizSubmitted = true;
  let correct = 0;

  quizData.forEach((q, idx) => {
    const selected = state.quizAnswers[idx];
    const options = document.querySelectorAll(`[data-quiz="${idx}"]`);

    if (selected !== undefined) {
      if (selected === q.correct) {
        options[selected].classList.add('selected', 'correct');
        correct++;
      } else {
        options[selected].classList.add('selected', 'incorrect');
        options[q.correct].classList.add('show-correct');
      }
    } else {
      options[q.correct].classList.add('show-correct');
    }

    document.getElementById(`explanation-${idx}`).classList.add('show');
  });

  const pct = Math.round((correct / quizData.length) * 100);
  state.bestQuizScore = Math.max(state.bestQuizScore, pct);
  saveState();

  const scoreCard = document.getElementById('quizScoreCard');
  scoreCard.style.display = 'block';
  scoreCard.innerHTML = `
    <div class="score-big">${correct}/${quizData.length}</div>
    <p style="color:var(--text-secondary); margin-top:0.5rem;">${pct}% ‚Äî ${
      pct >= 90 ? 'üåü Excellent! Interview ready!' :
      pct >= 70 ? 'üëç Good job! Review missed questions.' :
      pct >= 50 ? 'üìö Keep studying. Review the lessons.' :
      'üí™ Keep going! Re-read the lessons and try again.'
    }</p>
  `;

  document.getElementById('submitQuiz').style.display = 'none';
  document.getElementById('resetQuiz').style.display = 'inline-flex';
  updateProgress();
}

function resetQuiz() {
  state.quizAnswers = {};
  state.quizSubmitted = false;
  document.getElementById('quizScoreCard').style.display = 'none';
  document.getElementById('submitQuiz').style.display = 'inline-flex';
  document.getElementById('resetQuiz').style.display = 'none';
  renderQuizzes();
}

function renderExercises() {
  const container = document.getElementById('exerciseContainer');
  container.innerHTML = exercises.map(ex => `
    <div class="exercise-box" id="exercise-${ex.id}">
      <div class="exercise-header">
        <h3>üîß Exercise ${ex.id}: ${ex.title}</h3>
        <span class="difficulty ${ex.difficulty}">${ex.difficulty}</span>
      </div>
      <div class="exercise-body">
        <p>${ex.description}</p>
        <textarea class="exercise-editor" id="editor-${ex.id}" spellcheck="false">${ex.starter}</textarea>
        <div class="exercise-actions">
          <button class="btn btn-primary" onclick="checkExercise(${ex.id})">‚úì Check Answer</button>
          <button class="btn btn-secondary" onclick="showSolution(${ex.id})">üëÅ Show Solution</button>
          <button class="btn btn-secondary" onclick="resetExercise(${ex.id})">‚Ü∫ Reset</button>
        </div>
        <div class="exercise-result" id="result-${ex.id}"></div>
      </div>
    </div>
  `).join('');
}

function checkExercise(id) {
  const ex = exercises.find(e => e.id === id);
  const code = document.getElementById(`editor-${id}`).value;
  const result = document.getElementById(`result-${id}`);

  if (ex.check(code)) {
    result.className = 'exercise-result show success';
    result.textContent = '‚úÖ Correct! Your solution looks good.';
    state.exercisesCompleted.add(id);
    saveState();
    updateProgress();
  } else {
    result.className = 'exercise-result show error';
    result.textContent = '‚ùå Not quite. Check the key elements: ' + getHint(ex);
  }
}

function getHint(ex) {
  const hints = {
    1: 'Use instantiateStreaming, fetch, and return instance.exports',
    2: 'Need env namespace, WebAssembly.Memory, and a log function',
    3: 'Use TextEncoder, Uint8Array, .set(), and return byteLength',
    4: 'Use Uint8Array with offset/length and TextDecoder.decode()',
    5: 'Use performance.now(), warmup loop, and return average',
    6: 'Always create fresh view from memory.buffer',
    7: 'Check cache with .get(), compile if missing, .set() to cache',
    8: 'Use Float64Array, .set() to copy, call alloc/dealloc',
    9: 'Try instantiateStreaming, catch, fallback to arrayBuffer + instantiate',
    10: 'Handle onmessage, use postMessage, load WASM in worker'
  };
  return hints[ex.id] || 'Review the lesson material';
}

function showSolution(id) {
  const ex = exercises.find(e => e.id === id);
  document.getElementById(`editor-${id}`).value = ex.solution;
  const result = document.getElementById(`result-${id}`);
  result.className = 'exercise-result show success';
  result.textContent = 'üìã Solution revealed. Study it, then try writing it from memory!';
}

function resetExercise(id) {
  const ex = exercises.find(e => e.id === id);
  document.getElementById(`editor-${id}`).value = ex.starter;
  document.getElementById(`result-${id}`).className = 'exercise-result';
}

function renderPitfalls() {
  const container = document.getElementById('pitfallContainer');
  container.innerHTML = pitfalls.map((p, idx) => `
    <div class="pitfall" id="pitfall-${idx}">
      <div class="pitfall-header" onclick="togglePitfall(${idx})">
        <span class="pitfall-icon">${p.icon}</span>
        <h3>${p.title}</h3>
        <span class="pitfall-toggle">‚ñº</span>
      </div>
      <div class="pitfall-body">
        ${p.content}
      </div>
    </div>
  `).join('');
}

function togglePitfall(idx) {
  document.getElementById(`pitfall-${idx}`).classList.toggle('open');
}

function renderCheatSheet() {
  const grid = document.getElementById('cheatGrid');
  grid.innerHTML = cheatItems.map(item => `
    <div class="cheat-card">
      <h4>${item.title}</h4>
      <div class="code-block">
        <pre>${item.code}</pre>
      </div>
    </div>
  `).join('');
}

// ====================== NAVIGATION ======================
document.querySelectorAll('.nav-tab').forEach(tab => {
  tab.addEventListener('click', () => {
    document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
    tab.classList.add('active');
    document.getElementById(`section-${tab.dataset.tab}`).classList.add('active');

    // Reset lesson view when switching back
    if (tab.dataset.tab === 'lessons') {
      hideLesson();
    }
  });
});

// ====================== PROGRESS ======================
function updateProgress() {
  const totalItems = lessons.length + exercises.length; // lessons + exercises
  const completed = state.completedLessons.size + state.exercisesCompleted.size;
  const pct = Math.round((completed / totalItems) * 100);

  document.getElementById('progressFill').style.width = pct + '%';
  document.getElementById('progressPercent').textContent = pct + '%';
  document.getElementById('lessonsComplete').textContent = `${state.completedLessons.size}/${lessons.length}`;
  document.getElementById('exercisesDone').textContent = `${state.exercisesCompleted.size}/${exercises.length}`;
  document.getElementById('quizScore').textContent = state.bestQuizScore + '%';
  document.getElementById('lessonBadge').textContent = lessons.length - state.completedLessons.size;
}

// ====================== UTILITIES ======================
function copyCode(btn) {
  const pre = btn.closest('.code-block').querySelector('pre');
  const text = pre.textContent || pre.innerText;
  navigator.clipboard.writeText(text).then(() => {
    const orig = btn.textContent;
    btn.textContent = 'Copied!';
    btn.style.color = 'var(--green)';
    btn.style.borderColor = 'var(--green)';
    setTimeout(() => {
      btn.textContent = orig;
      btn.style.color = '';
      btn.style.borderColor = '';
    }, 1500);
  });
}

// ====================== INIT ======================
renderLessonGrid();
renderQuizzes();
renderExercises();
renderPitfalls();
renderCheatSheet();
updateProgress();
</script>
</body>
</html>