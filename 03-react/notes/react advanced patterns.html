<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>üöÄ React Advanced Patterns Mastery</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
:root{
  --bg:#0a0a1a;--card:#1a1a2e;--card2:#16213e;--text:#e0e0e0;--text2:#a0a0b0;
  --cyan:#00d4ff;--purple:#a855f7;--emerald:#10b981;--amber:#f59e0b;
  --red:#ef4444;--green:#22c55e;--codebg:#0d1117;--border:#2a2a4a;
  --glow-cyan:0 0 20px rgba(0,212,255,.3);--glow-purple:0 0 20px rgba(168,85,247,.3);
  --glow-emerald:0 0 20px rgba(16,185,129,.3);--glow-amber:0 0 20px rgba(245,158,11,.3);
}
body{font-family:'Segoe UI',system-ui,-apple-system,sans-serif;background:var(--bg);color:var(--text);line-height:1.7;overflow-x:hidden}
::selection{background:var(--cyan);color:var(--bg)}
::-webkit-scrollbar{width:8px}
::-webkit-scrollbar-track{background:var(--bg)}
::-webkit-scrollbar-thumb{background:var(--border);border-radius:4px}
::-webkit-scrollbar-thumb:hover{background:var(--cyan)}

/* Header */
.header{position:fixed;top:0;left:0;right:0;z-index:100;background:rgba(10,10,26,.95);backdrop-filter:blur(20px);border-bottom:1px solid var(--border);padding:0 2rem;height:64px;display:flex;align-items:center;justify-content:space-between}
.logo{font-size:1.3rem;font-weight:800;background:linear-gradient(135deg,var(--cyan),var(--purple));-webkit-background-clip:text;-webkit-text-fill-color:transparent}
.logo span{font-size:.8rem;-webkit-text-fill-color:var(--text2);margin-left:.5rem}
.stats{display:flex;gap:1.5rem;align-items:center}
.stat{display:flex;align-items:center;gap:.4rem;font-size:.85rem;color:var(--text2)}
.stat .val{color:var(--amber);font-weight:700;font-size:1rem}
.progress-bar{position:fixed;top:64px;left:0;right:0;height:3px;background:var(--border);z-index:99}
.progress-fill{height:100%;background:linear-gradient(90deg,var(--cyan),var(--purple),var(--emerald),var(--amber));transition:width .5s;width:0%}

/* Navigation */
.nav{position:fixed;top:67px;left:0;right:0;z-index:98;background:rgba(10,10,26,.9);backdrop-filter:blur(10px);border-bottom:1px solid var(--border);display:flex;justify-content:center;gap:.5rem;padding:.6rem 1rem;flex-wrap:wrap}
.nav-btn{padding:.5rem 1.2rem;border:2px solid var(--border);background:transparent;color:var(--text2);border-radius:25px;cursor:pointer;font-size:.85rem;font-weight:600;transition:all .3s;position:relative;overflow:hidden}
.nav-btn::before{content:'';position:absolute;inset:0;opacity:0;transition:opacity .3s}
.nav-btn[data-ch="0"]{--accent:var(--cyan)}.nav-btn[data-ch="1"]{--accent:var(--purple)}
.nav-btn[data-ch="2"]{--accent:var(--emerald)}.nav-btn[data-ch="3"]{--accent:var(--amber)}
.nav-btn:hover,.nav-btn.active{border-color:var(--accent);color:var(--accent);box-shadow:0 0 15px color-mix(in srgb,var(--accent) 30%,transparent)}
.nav-btn.active{background:color-mix(in srgb,var(--accent) 10%,transparent)}
.nav-btn .check{margin-left:.3rem;font-size:.7rem}

/* Main */
main{max-width:900px;margin:0 auto;padding:140px 1.5rem 3rem}
.chapter{display:none;animation:fadeIn .5s}
.chapter.active{display:block}
@keyframes fadeIn{from{opacity:0;transform:translateY(20px)}to{opacity:1;transform:translateY(0)}}

/* Section Cards */
.section-card{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:2rem;margin-bottom:2rem;position:relative;overflow:hidden}
.section-card::before{content:'';position:absolute;top:0;left:0;right:0;height:3px}
.section-card.cyan::before{background:linear-gradient(90deg,var(--cyan),transparent)}
.section-card.purple::before{background:linear-gradient(90deg,var(--purple),transparent)}
.section-card.emerald::before{background:linear-gradient(90deg,var(--emerald),transparent)}
.section-card.amber::before{background:linear-gradient(90deg,var(--amber),transparent)}

h1{font-size:2.2rem;font-weight:800;margin-bottom:.5rem}
h2{font-size:1.5rem;font-weight:700;margin-bottom:1rem;display:flex;align-items:center;gap:.5rem}
h3{font-size:1.15rem;font-weight:600;margin:1.2rem 0 .6rem;color:var(--text)}
.subtitle{color:var(--text2);font-size:1.05rem;margin-bottom:2rem}
p{margin-bottom:.8rem;color:var(--text2)}
strong{color:var(--text)}
.emoji-big{font-size:2.5rem;margin-bottom:1rem;display:block}
ul,ol{margin:.5rem 0 1rem 1.5rem;color:var(--text2)}
li{margin-bottom:.4rem}
li strong{color:var(--text)}

/* Code Blocks */
.code-block{background:var(--codebg);border:1px solid var(--border);border-radius:12px;margin:1rem 0;overflow:hidden;position:relative}
.code-header{display:flex;justify-content:space-between;align-items:center;padding:.5rem 1rem;background:rgba(255,255,255,.03);border-bottom:1px solid var(--border);font-size:.75rem;color:var(--text2)}
.code-lang{background:var(--border);padding:.15rem .5rem;border-radius:8px;font-size:.7rem;text-transform:uppercase;letter-spacing:.5px}
.code-body{padding:1rem 1.2rem;overflow-x:auto;font-family:'Fira Code','Cascadia Code','JetBrains Mono',monospace;font-size:.85rem;line-height:1.8;white-space:pre;tab-size:2;color:#e6e6e6}
.code-body .kw{color:#ff79c6}.code-body .fn{color:#50fa7b}.code-body .str{color:#f1fa8c}
.code-body .cm{color:#6272a4;font-style:italic}.code-body .num{color:#bd93f9}
.code-body .op{color:#ff79c6}.code-body .tag{color:#ff79c6}.code-body .attr{color:#50fa7b}
.code-body .comp{color:#8be9fd}.code-body .hook{color:#bd93f9}
.copy-btn{padding:.2rem .6rem;background:var(--border);border:none;color:var(--text2);border-radius:6px;cursor:pointer;font-size:.7rem;transition:all .2s}
.copy-btn:hover{background:var(--cyan);color:var(--bg)}

/* Visual Diagrams */
.diagram{background:var(--card2);border:1px solid var(--border);border-radius:12px;padding:1.5rem;margin:1.5rem 0;position:relative;overflow:hidden}
.diagram-title{font-weight:700;margin-bottom:1rem;font-size:.9rem;text-transform:uppercase;letter-spacing:1px}
.tree{display:flex;flex-direction:column;align-items:center;gap:.3rem}
.tree-node{padding:.4rem 1rem;border-radius:8px;font-size:.8rem;font-weight:600;position:relative;text-align:center;min-width:80px;border:2px solid}
.tree-node.app{background:rgba(0,212,255,.15);border-color:var(--cyan);color:var(--cyan)}
.tree-node.mid{background:rgba(160,160,176,.1);border-color:var(--text2);color:var(--text2)}
.tree-node.leaf{background:rgba(16,185,129,.15);border-color:var(--emerald);color:var(--emerald)}
.tree-node.provider{background:rgba(168,85,247,.15);border-color:var(--purple);color:var(--purple)}
.tree-node.highlighted{animation:pulse 1.5s infinite}
@keyframes pulse{0%,100%{box-shadow:0 0 0 0 rgba(0,212,255,.4)}50%{box-shadow:0 0 0 8px rgba(0,212,255,0)}}
.tree-row{display:flex;gap:1rem;justify-content:center;flex-wrap:wrap}
.tree-connector{width:2px;height:20px;background:var(--border);margin:0 auto}
.tree-branch{display:flex;flex-direction:column;align-items:center}
.arrow{color:var(--red);font-size:.7rem;margin:.2rem 0;font-weight:700;animation:arrowPulse 2s infinite}
.arrow.good{color:var(--emerald)}
@keyframes arrowPulse{0%,100%{opacity:.5}50%{opacity:1}}
.vs-divider{display:flex;align-items:center;gap:1rem;margin:1.5rem 0;color:var(--amber);font-weight:700}
.vs-divider::before,.vs-divider::after{content:'';flex:1;height:1px;background:var(--border)}
.diagram-row{display:grid;grid-template-columns:1fr 1fr;gap:1.5rem}
@media(max-width:600px){.diagram-row{grid-template-columns:1fr}}

/* Interactive Elements */
.interactive{background:linear-gradient(135deg,rgba(0,212,255,.05),rgba(168,85,247,.05));border:1px solid var(--border);border-radius:12px;padding:1.5rem;margin:1.5rem 0}
.interactive-title{font-weight:700;margin-bottom:1rem;display:flex;align-items:center;gap:.5rem}
.btn{padding:.6rem 1.2rem;border:none;border-radius:8px;font-weight:600;cursor:pointer;font-size:.85rem;transition:all .2s;display:inline-flex;align-items:center;gap:.3rem}
.btn-primary{background:var(--cyan);color:var(--bg)}.btn-primary:hover{box-shadow:var(--glow-cyan);transform:translateY(-1px)}
.btn-success{background:var(--green);color:var(--bg)}.btn-success:hover{box-shadow:0 0 20px rgba(34,197,94,.3)}
.btn-purple{background:var(--purple);color:white}.btn-purple:hover{box-shadow:var(--glow-purple)}
.btn-amber{background:var(--amber);color:var(--bg)}.btn-amber:hover{box-shadow:var(--glow-amber)}
.btn-outline{background:transparent;border:2px solid var(--border);color:var(--text)}.btn-outline:hover{border-color:var(--cyan);color:var(--cyan)}
.btn-sm{padding:.3rem .8rem;font-size:.8rem}
.btn:disabled{opacity:.5;cursor:not-allowed;transform:none!important}
.btn-group{display:flex;gap:.5rem;flex-wrap:wrap;margin-top:1rem}

/* Quiz */
.quiz{background:var(--card2);border:1px solid var(--border);border-radius:12px;padding:1.5rem;margin:1rem 0}
.quiz-question{font-weight:600;margin-bottom:1rem;font-size:1rem}
.quiz-options{display:flex;flex-direction:column;gap:.5rem}
.quiz-opt{padding:.7rem 1rem;border:2px solid var(--border);border-radius:10px;cursor:pointer;transition:all .2s;font-size:.9rem;background:transparent;color:var(--text);text-align:left;width:100%}
.quiz-opt:hover:not(.disabled){border-color:var(--cyan);background:rgba(0,212,255,.05)}
.quiz-opt.correct{border-color:var(--green)!important;background:rgba(34,197,94,.1)!important;color:var(--green)!important}
.quiz-opt.wrong{border-color:var(--red)!important;background:rgba(239,68,68,.1)!important;color:var(--red)!important}
.quiz-opt.disabled{cursor:not-allowed;opacity:.7}
.quiz-explanation{margin-top:1rem;padding:1rem;border-radius:8px;font-size:.85rem;display:none;animation:fadeIn .3s}
.quiz-explanation.show{display:block}
.quiz-explanation.correct{background:rgba(34,197,94,.1);border-left:3px solid var(--green);color:var(--green)}
.quiz-explanation.wrong{background:rgba(239,68,68,.1);border-left:3px solid var(--red);color:var(--red)}

/* Exercise */
.exercise{background:var(--card2);border:1px solid var(--border);border-radius:12px;padding:1.5rem;margin:1rem 0}
.exercise-prompt{font-weight:600;margin-bottom:1rem}
.exercise textarea{width:100%;min-height:120px;background:var(--codebg);border:2px solid var(--border);border-radius:8px;color:var(--text);font-family:'Fira Code','Cascadia Code',monospace;font-size:.85rem;padding:1rem;resize:vertical;line-height:1.6}
.exercise textarea:focus{outline:none;border-color:var(--cyan)}
.exercise-result{margin-top:.8rem;padding:.8rem;border-radius:8px;font-size:.85rem;display:none;animation:fadeIn .3s}
.exercise-result.pass{display:block;background:rgba(34,197,94,.1);border-left:3px solid var(--green);color:var(--green)}
.exercise-result.fail{display:block;background:rgba(239,68,68,.1);border-left:3px solid var(--red);color:var(--red)}
.exercise-hint{margin-top:.5rem;padding:.8rem;background:rgba(245,158,11,.1);border-left:3px solid var(--amber);border-radius:8px;font-size:.85rem;color:var(--amber);display:none}
.exercise-hint.show{display:block}

/* Pitfall Cards */
.pitfall{background:rgba(239,68,68,.05);border:1px solid rgba(239,68,68,.2);border-radius:12px;padding:1.2rem;margin:.8rem 0;position:relative;padding-left:3rem}
.pitfall::before{content:'‚ö†Ô∏è';position:absolute;left:1rem;top:1.2rem;font-size:1.1rem}
.pitfall-title{font-weight:700;color:var(--red);margin-bottom:.3rem;font-size:.95rem}
.pitfall p{font-size:.85rem;margin-bottom:.3rem}
.pitfall .fix{background:rgba(34,197,94,.05);border:1px solid rgba(34,197,94,.2);border-radius:8px;padding:.8rem;margin-top:.5rem}
.pitfall .fix-title{color:var(--green);font-weight:600;font-size:.85rem;margin-bottom:.3rem}

/* Tip Cards */
.tip{background:rgba(0,212,255,.05);border:1px solid rgba(0,212,255,.2);border-radius:12px;padding:1rem;margin:.8rem 0;padding-left:3rem;position:relative}
.tip::before{content:'üí°';position:absolute;left:1rem;top:1rem}
.tip p{font-size:.85rem;margin:0}

/* Tabs within sections */
.tab-container{margin:1rem 0}
.tab-buttons{display:flex;gap:.3rem;margin-bottom:1rem;flex-wrap:wrap;border-bottom:2px solid var(--border);padding-bottom:0}
.tab-btn{padding:.5rem 1rem;background:transparent;border:none;color:var(--text2);cursor:pointer;font-size:.85rem;font-weight:600;border-bottom:2px solid transparent;margin-bottom:-2px;transition:all .2s}
.tab-btn.active{color:var(--cyan);border-bottom-color:var(--cyan)}
.tab-btn:hover:not(.active){color:var(--text)}
.tab-content{display:none;animation:fadeIn .3s}
.tab-content.active{display:block}

/* Collapsible */
.collapsible{margin:.5rem 0}
.collapsible-toggle{width:100%;padding:.8rem 1rem;background:rgba(255,255,255,.03);border:1px solid var(--border);border-radius:8px;color:var(--text);cursor:pointer;text-align:left;font-size:.9rem;font-weight:600;display:flex;justify-content:space-between;align-items:center;transition:all .2s}
.collapsible-toggle:hover{background:rgba(255,255,255,.06)}
.collapsible-toggle .arrow-icon{transition:transform .3s}
.collapsible-toggle.open .arrow-icon{transform:rotate(180deg)}
.collapsible-content{max-height:0;overflow:hidden;transition:max-height .3s;padding:0 1rem}
.collapsible-content.open{max-height:2000px;padding:.8rem 1rem}

/* Render Visualization */
.render-viz{display:flex;gap:1rem;flex-wrap:wrap;justify-content:center;margin:1rem 0}
.render-component{padding:.8rem 1.2rem;border:2px solid var(--border);border-radius:10px;font-size:.8rem;font-weight:600;text-align:center;min-width:100px;transition:all .3s;background:var(--card)}
.render-component.rerendering{animation:rerender .6s;border-color:var(--red);background:rgba(239,68,68,.1)}
.render-component.stable{border-color:var(--green);background:rgba(34,197,94,.1)}
.render-component.memoized{border-color:var(--emerald);box-shadow:0 0 10px rgba(16,185,129,.2)}
@keyframes rerender{0%{transform:scale(1);box-shadow:none}50%{transform:scale(1.05);box-shadow:0 0 20px rgba(239,68,68,.5)}100%{transform:scale(1);box-shadow:none}}
.render-label{font-size:.7rem;color:var(--text2);margin-top:.2rem}
.render-count{font-size:.7rem;color:var(--amber);margin-top:.15rem}

/* Badge/Tag */
.badge{display:inline-block;padding:.15rem .5rem;border-radius:6px;font-size:.7rem;font-weight:700;text-transform:uppercase;letter-spacing:.5px}
.badge-cyan{background:rgba(0,212,255,.15);color:var(--cyan)}
.badge-purple{background:rgba(168,85,247,.15);color:var(--purple)}
.badge-emerald{background:rgba(16,185,129,.15);color:var(--emerald)}
.badge-amber{background:rgba(245,158,11,.15);color:var(--amber)}
.badge-red{background:rgba(239,68,68,.15);color:var(--red)}

/* Score popup */
.score-popup{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:var(--card);border:2px solid var(--amber);border-radius:16px;padding:2rem;text-align:center;z-index:200;box-shadow:0 0 40px rgba(245,158,11,.3);display:none;animation:popIn .3s}
@keyframes popIn{from{transform:translate(-50%,-50%) scale(.8);opacity:0}to{transform:translate(-50%,-50%) scale(1);opacity:1}}
.score-popup .big-emoji{font-size:3rem;margin-bottom:.5rem}
.score-popup .score-text{font-size:1.5rem;font-weight:800;color:var(--amber)}
.overlay{position:fixed;inset:0;background:rgba(0,0,0,.7);z-index:199;display:none}

/* XP Float Animation */
.xp-float{position:fixed;pointer-events:none;color:var(--amber);font-weight:800;font-size:1.2rem;z-index:300;animation:xpFloat 1.5s forwards}
@keyframes xpFloat{0%{opacity:1;transform:translateY(0)}100%{opacity:0;transform:translateY(-60px)}}

/* Analogy Box */
.analogy{background:linear-gradient(135deg,rgba(168,85,247,.08),rgba(0,212,255,.08));border:1px solid var(--purple);border-radius:12px;padding:1.2rem;margin:1rem 0;padding-left:3rem;position:relative}
.analogy::before{content:'üé≠';position:absolute;left:1rem;top:1.2rem}
.analogy-title{font-weight:700;color:var(--purple);margin-bottom:.3rem}

/* Chapter intro */
.chapter-intro{text-align:center;padding:2rem 0 1rem;margin-bottom:1rem}
.chapter-intro h1{background:linear-gradient(135deg,var(--cyan),var(--purple));-webkit-background-clip:text;-webkit-text-fill-color:transparent;font-size:2.5rem;margin-bottom:.5rem}
.chapter-num{font-size:.8rem;text-transform:uppercase;letter-spacing:3px;color:var(--text2);margin-bottom:.5rem}

/* Flow diagram */
.flow{display:flex;align-items:center;justify-content:center;gap:.3rem;flex-wrap:wrap;margin:1rem 0}
.flow-item{padding:.5rem 1rem;border-radius:8px;font-size:.8rem;font-weight:600}
.flow-arrow{color:var(--cyan);font-size:1.2rem;font-weight:700}

/* Responsive */
@media(max-width:700px){
  .header{padding:0 1rem}.logo span{display:none}.stats{gap:.8rem}
  .stat span:not(.val){display:none}main{padding:130px 1rem 2rem}
  h1{font-size:1.8rem}.section-card{padding:1.2rem}.diagram-row{grid-template-columns:1fr}
  .nav{gap:.3rem;padding:.4rem .5rem}.nav-btn{padding:.4rem .8rem;font-size:.75rem}
}

/* Print-friendly code */
.code-inline{background:var(--codebg);padding:.15rem .4rem;border-radius:4px;font-family:monospace;font-size:.85rem;color:var(--cyan)}

/* Completion */
.chapter-complete{text-align:center;padding:2rem;background:linear-gradient(135deg,rgba(34,197,94,.1),rgba(0,212,255,.1));border:1px solid var(--green);border-radius:16px;margin:2rem 0}
.chapter-complete h2{color:var(--green)}
</style>
</head>
<body>

<!-- Header -->
<header class="header">
  <div class="logo">‚öõÔ∏è React Advanced Patterns <span>Mastery</span></div>
  <div class="stats">
    <div class="stat">‚ö° <span>XP:</span> <span class="val" id="xp-display">0</span></div>
    <div class="stat">üèÜ <span>Score:</span> <span class="val" id="score-display">0<span style="color:var(--text2)">/40</span></span></div>
    <div class="stat">üî• <span>Streak:</span> <span class="val" id="streak-display">0</span></div>
  </div>
</header>
<div class="progress-bar"><div class="progress-fill" id="progress-fill"></div></div>

<!-- Navigation -->
<nav class="nav" id="main-nav">
  <button class="nav-btn active" data-ch="0" onclick="switchChapter(0)">üì¶ Context API</button>
  <button class="nav-btn" data-ch="1" onclick="switchChapter(1)">üîÑ useReducer + useContext</button>
  <button class="nav-btn" data-ch="2" onclick="switchChapter(2)">‚ö° useMemo & useCallback</button>
  <button class="nav-btn" data-ch="3" onclick="switchChapter(3)">ü™ù Custom Hooks</button>
</nav>

<main>

<!-- ==================== CHAPTER 0: Context API ==================== -->
<section class="chapter active" id="ch-0">
  <div class="chapter-intro">
    <div class="chapter-num">Chapter 1 of 4</div>
    <h1>üì¶ Context API</h1>
    <p class="subtitle">Escape prop drilling hell and share state like a pro</p>
  </div>

  <!-- THEORY -->
  <div class="section-card cyan">
    <h2>üéØ The Problem: Prop Drilling</h2>
    <p>Imagine you have a <strong>user object</strong> at the top of your app, and a tiny component 5 levels deep needs it. Without Context, you'd have to pass it through EVERY intermediate component ‚Äî even ones that don't need it.</p>

    <div class="analogy">
      <div class="analogy-title">Real-World Analogy</div>
      <p>Prop drilling is like passing a note in class through 10 students who don't care about it, just to reach one person in the back. <strong>Context</strong> is like the teacher announcing the message so anyone who needs it can hear directly!</p>
    </div>

    <!-- Visual: Prop Drilling vs Context -->
    <div class="diagram">
      <div class="diagram-title">üîç Prop Drilling vs Context</div>
      <div class="diagram-row">
        <div>
          <h3 style="text-align:center;color:var(--red);margin-top:0">‚ùå Prop Drilling</h3>
          <div class="tree">
            <div class="tree-node app">App <small>(has theme)</small></div>
            <div class="arrow">‚Üì props.theme</div>
            <div class="tree-node mid">Layout</div>
            <div class="arrow">‚Üì props.theme</div>
            <div class="tree-node mid">Sidebar</div>
            <div class="arrow">‚Üì props.theme</div>
            <div class="tree-node mid">Menu</div>
            <div class="arrow">‚Üì props.theme</div>
            <div class="tree-node leaf">MenuItem <small>(uses theme)</small></div>
          </div>
        </div>
        <div>
          <h3 style="text-align:center;color:var(--green);margin-top:0">‚úÖ Context API</h3>
          <div class="tree">
            <div class="tree-node provider">ThemeProvider</div>
            <div class="tree-connector"></div>
            <div class="tree-node mid">App</div>
            <div class="tree-connector"></div>
            <div class="tree-node mid" style="opacity:.5">Layout</div>
            <div class="tree-connector"></div>
            <div class="tree-node mid" style="opacity:.5">Sidebar ‚Üí Menu</div>
            <div class="arrow good">‚ö° useContext(ThemeCtx)</div>
            <div class="tree-node leaf highlighted">MenuItem <small>(reads directly!)</small></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- CREATING CONTEXT -->
  <div class="section-card cyan">
    <h2>üèóÔ∏è Creating & Using Context ‚Äî Step by Step</h2>

    <h3>Step 1: Create the Context</h3>
    <div class="code-block">
      <div class="code-header"><span class="code-lang">jsx</span><button class="copy-btn" onclick="copyCode(this)">üìã Copy</button></div>
      <div class="code-body"><span class="cm">// ThemeContext.js</span>
<span class="kw">import</span> { createContext } <span class="kw">from</span> <span class="str">'react'</span>;

<span class="cm">// Create context with a default value</span>
<span class="kw">export const</span> <span class="comp">ThemeContext</span> = <span class="fn">createContext</span>(<span class="str">'light'</span>);
<span class="cm">// The default 'light' is used ONLY when no Provider wraps the consumer</span></div>
    </div>

    <h3>Step 2: Wrap with Provider</h3>
    <div class="code-block">
      <div class="code-header"><span class="code-lang">jsx</span><button class="copy-btn" onclick="copyCode(this)">üìã Copy</button></div>
      <div class="code-body"><span class="cm">// App.jsx</span>
<span class="kw">import</span> { <span class="comp">ThemeContext</span> } <span class="kw">from</span> <span class="str">'./ThemeContext'</span>;
<span class="kw">import</span> { useState } <span class="kw">from</span> <span class="str">'react'</span>;

<span class="kw">function</span> <span class="fn">App</span>() {
  <span class="kw">const</span> [theme, setTheme] = <span class="hook">useState</span>(<span class="str">'dark'</span>);

  <span class="kw">return</span> (
    <span class="tag">&lt;<span class="comp">ThemeContext.Provider</span></span> <span class="attr">value</span>={{ theme, setTheme }}<span class="tag">&gt;</span>
      <span class="tag">&lt;<span class="comp">Dashboard</span> /&gt;</span>
    <span class="tag">&lt;/<span class="comp">ThemeContext.Provider</span>&gt;</span>
  );
}</div>
    </div>

    <h3>Step 3: Consume with useContext</h3>
    <div class="code-block">
      <div class="code-header"><span class="code-lang">jsx</span><button class="copy-btn" onclick="copyCode(this)">üìã Copy</button></div>
      <div class="code-body"><span class="cm">// DeepNestedComponent.jsx ‚Äî no prop drilling needed!</span>
<span class="kw">import</span> { useContext } <span class="kw">from</span> <span class="str">'react'</span>;
<span class="kw">import</span> { <span class="comp">ThemeContext</span> } <span class="kw">from</span> <span class="str">'./ThemeContext'</span>;

<span class="kw">function</span> <span class="fn">DeepNestedComponent</span>() {
  <span class="kw">const</span> { theme, setTheme } = <span class="hook">useContext</span>(<span class="comp">ThemeContext</span>);

  <span class="kw">return</span> (
    <span class="tag">&lt;button</span> <span class="attr">onClick</span>={() => <span class="fn">setTheme</span>(theme === <span class="str">'dark'</span> ? <span class="str">'light'</span> : <span class="str">'dark'</span>)}<span class="tag">&gt;</span>
      Current: {theme} ‚Äî Click to toggle
    <span class="tag">&lt;/button&gt;</span>
  );
}</div>
    </div>

    <div class="tip">
      <p><strong>Pro tip:</strong> Create a custom hook to avoid importing both useContext and the Context everywhere: <code class="code-inline">const useTheme = () => useContext(ThemeContext)</code></p>
    </div>
  </div>

  <!-- REAL-WORLD EXAMPLE: AUTH -->
  <div class="section-card cyan">
    <h2>üîê Real-World Example: Auth Context</h2>
    <p>This is the pattern you'll see in <strong>every production React app</strong>. This is interview gold! üéØ</p>

    <div class="code-block">
      <div class="code-header"><span class="code-lang">jsx</span><span>AuthContext.jsx ‚Äî Complete Pattern</span></div>
      <div class="code-body"><span class="kw">import</span> { createContext, useContext, useState, useCallback } <span class="kw">from</span> <span class="str">'react'</span>;

<span class="cm">// 1. Create context</span>
<span class="kw">const</span> <span class="comp">AuthContext</span> = <span class="fn">createContext</span>(<span class="kw">null</span>);

<span class="cm">// 2. Create Provider component</span>
<span class="kw">export function</span> <span class="fn">AuthProvider</span>({ children }) {
  <span class="kw">const</span> [user, setUser] = <span class="hook">useState</span>(<span class="kw">null</span>);
  <span class="kw">const</span> [loading, setLoading] = <span class="hook">useState</span>(<span class="kw">false</span>);

  <span class="kw">const</span> <span class="fn">login</span> = <span class="hook">useCallback</span>(<span class="kw">async</span> (email, password) => {
    <span class="fn">setLoading</span>(<span class="kw">true</span>);
    <span class="kw">const</span> res = <span class="kw">await</span> <span class="fn">fetch</span>(<span class="str">'/api/login'</span>, {
      method: <span class="str">'POST'</span>,
      body: JSON.<span class="fn">stringify</span>({ email, password })
    });
    <span class="kw">const</span> data = <span class="kw">await</span> res.<span class="fn">json</span>();
    <span class="fn">setUser</span>(data.user);
    <span class="fn">setLoading</span>(<span class="kw">false</span>);
  }, []);

  <span class="kw">const</span> <span class="fn">logout</span> = <span class="hook">useCallback</span>(() => {
    <span class="fn">setUser</span>(<span class="kw">null</span>);
  }, []);

  <span class="kw">return</span> (
    <span class="tag">&lt;<span class="comp">AuthContext.Provider</span></span> <span class="attr">value</span>={{ user, loading, login, logout }}<span class="tag">&gt;</span>
      {children}
    <span class="tag">&lt;/<span class="comp">AuthContext.Provider</span>&gt;</span>
  );
}

<span class="cm">// 3. Custom hook with safety check</span>
<span class="kw">export function</span> <span class="fn">useAuth</span>() {
  <span class="kw">const</span> context = <span class="hook">useContext</span>(<span class="comp">AuthContext</span>);
  <span class="kw">if</span> (!context) {
    <span class="kw">throw new</span> Error(<span class="str">'useAuth must be used within AuthProvider'</span>);
  }
  <span class="kw">return</span> context;
}

<span class="cm">// 4. Usage anywhere in the app:</span>
<span class="cm">// const { user, login, logout } = useAuth();</span></div>
    </div>

    <div class="tip"><p><strong>Interview tip:</strong> Always include the safety check in your custom context hook. It shows you write production-quality code! The error message helps developers debug instantly.</p></div>
  </div>

  <!-- INTERACTIVE DEMO -->
  <div class="section-card cyan">
    <h2>üéÆ Interactive: Context Flow Simulator</h2>
    <p>Click components to see how context value flows without prop drilling:</p>
    <div class="interactive" id="context-sim">
      <div style="display:flex;flex-direction:column;align-items:center;gap:6px">
        <div class="render-component" style="border-color:var(--purple);cursor:pointer" onclick="simContext('provider')">
          <div>üü£ ThemeProvider</div>
          <div class="render-label">value = "<span id="ctx-val">dark</span>"</div>
          <button class="btn btn-sm btn-purple" onclick="event.stopPropagation();toggleCtxVal()" style="margin-top:4px">Toggle Theme</button>
        </div>
        <div style="color:var(--border)">‚îÇ</div>
        <div class="render-component" onclick="simContext('app')" style="cursor:pointer">
          <div>App</div>
          <div class="render-label">no context used</div>
        </div>
        <div style="display:flex;gap:2rem">
          <div style="display:flex;flex-direction:column;align-items:center;gap:6px">
            <div style="color:var(--border)">‚îÇ</div>
            <div class="render-component" onclick="simContext('header')" style="cursor:pointer">
              <div>Header</div>
              <div class="render-label">no context used</div>
            </div>
          </div>
          <div style="display:flex;flex-direction:column;align-items:center;gap:6px">
            <div style="color:var(--border)">‚îÇ</div>
            <div class="render-component" style="border-color:var(--emerald);cursor:pointer" onclick="simContext('button')">
              <div>üü¢ ThemeButton</div>
              <div class="render-label">useContext(Theme) ‚úì</div>
              <div class="render-count" id="ctx-reads">reads: 0</div>
            </div>
          </div>
        </div>
      </div>
      <p style="text-align:center;margin-top:1rem;font-size:.8rem;color:var(--text2)" id="ctx-msg">üëÜ Toggle the theme to see which components re-render</p>
    </div>
  </div>

  <!-- QUIZ: Context API -->
  <div class="section-card cyan">
    <h2>üß† Quiz: Context API</h2>

    <div class="quiz" data-quiz="ctx-1">
      <div class="quiz-question">Q1: What problem does Context API primarily solve?</div>
      <div class="quiz-options">
        <button class="quiz-opt" onclick="checkQuiz('ctx-1',this,false)">A) It replaces Redux entirely</button>
        <button class="quiz-opt" onclick="checkQuiz('ctx-1',this,true)">B) It avoids passing props through many intermediate components (prop drilling)</button>
        <button class="quiz-opt" onclick="checkQuiz('ctx-1',this,false)">C) It makes components render faster</button>
        <button class="quiz-opt" onclick="checkQuiz('ctx-1',this,false)">D) It handles async operations</button>
      </div>
      <div class="quiz-explanation" id="ctx-1-exp"></div>
    </div>

    <div class="quiz" data-quiz="ctx-2">
      <div class="quiz-question">Q2: What does <code class="code-inline">createContext('default')</code> ‚Äî when is "default" used?</div>
      <div class="quiz-options">
        <button class="quiz-opt" onclick="checkQuiz('ctx-2',this,false)">A) Always as the initial value</button>
        <button class="quiz-opt" onclick="checkQuiz('ctx-2',this,false)">B) When the Provider passes undefined</button>
        <button class="quiz-opt" onclick="checkQuiz('ctx-2',this,true)">C) When a component reads context without being wrapped by a Provider</button>
        <button class="quiz-opt" onclick="checkQuiz('ctx-2',this,false)">D) It's passed to every consumer automatically</button>
      </div>
      <div class="quiz-explanation" id="ctx-2-exp"></div>
    </div>

    <div class="quiz" data-quiz="ctx-3">
      <div class="quiz-question">Q3: What happens to ALL consumers when the Context value changes?</div>
      <div class="quiz-options">
        <button class="quiz-opt" onclick="checkQuiz('ctx-3',this,false)">A) Nothing ‚Äî they only re-render when their own state changes</button>
        <button class="quiz-opt" onclick="checkQuiz('ctx-3',this,true)">B) They all re-render, regardless of React.memo</button>
        <button class="quiz-opt" onclick="checkQuiz('ctx-3',this,false)">C) Only the closest consumer re-renders</button>
        <button class="quiz-opt" onclick="checkQuiz('ctx-3',this,false)">D) They re-render only if they use useCallback</button>
      </div>
      <div class="quiz-explanation" id="ctx-3-exp"></div>
    </div>

    <div class="quiz" data-quiz="ctx-4">
      <div class="quiz-question">Q4: What is the recommended way to consume context in a function component?</div>
      <div class="quiz-options">
        <button class="quiz-opt" onclick="checkQuiz('ctx-4',this,false)">A) Context.Consumer render prop</button>
        <button class="quiz-opt" onclick="checkQuiz('ctx-4',this,true)">B) useContext(MyContext) hook</button>
        <button class="quiz-opt" onclick="checkQuiz('ctx-4',this,false)">C) this.context</button>
        <button class="quiz-opt" onclick="checkQuiz('ctx-4',this,false)">D) connect() HOC</button>
      </div>
      <div class="quiz-explanation" id="ctx-4-exp"></div>
    </div>
  </div>

  <!-- EXERCISE -->
  <div class="section-card cyan">
    <h2>üí™ Exercise: Build a Language Context</h2>

    <div class="exercise" data-ex="ctx-ex1">
      <div class="exercise-prompt">Fill in the missing parts to create a Language Context that provides the current language and a function to switch languages:</div>
      <textarea id="ctx-ex1-input" spellcheck="false" placeholder="Type your answer here...">// Fill in the blanks:

const LanguageContext = ______('en');

function LanguageProvider({ children }) {
  const [lang, setLang] = useState('en');

  return (
    <LanguageContext.______ value={{ lang, setLang }}>
      {children}
    </LanguageContext.______>
  );
}

function useLanguage() {
  return ______(LanguageContext);
}</textarea>
      <div class="btn-group">
        <button class="btn btn-primary" onclick="checkExercise('ctx-ex1')">‚úÖ Check Answer</button>
        <button class="btn btn-outline" onclick="showHint('ctx-ex1')">üí° Hint</button>
        <button class="btn btn-outline" onclick="showSolution('ctx-ex1')">üëÅÔ∏è Show Solution</button>
      </div>
      <div class="exercise-hint" id="ctx-ex1-hint">The four blanks are: createContext, Provider, Provider, useContext</div>
      <div class="exercise-result" id="ctx-ex1-result"></div>
    </div>
  </div>

  <!-- PITFALLS -->
  <div class="section-card cyan">
    <h2>üö® Common Pitfalls & Mistakes</h2>

    <div class="pitfall">
      <div class="pitfall-title">Pitfall #1: Creating a new object every render</div>
      <p>Passing an inline object as the value creates a NEW reference on every render, causing ALL consumers to re-render!</p>
      <div class="code-block"><div class="code-header"><span class="code-lang">jsx</span><span class="badge badge-red">‚ùå BAD</span></div>
<div class="code-body"><span class="cm">// New object created every render = all consumers re-render!</span>
<span class="tag">&lt;<span class="comp">MyContext.Provider</span></span> <span class="attr">value</span>={{ user, setUser }}<span class="tag">&gt;</span></div></div>
      <div class="fix">
        <div class="fix-title">‚úÖ Fix: useMemo the value</div>
        <div class="code-block"><div class="code-header"><span class="code-lang">jsx</span><span class="badge badge-emerald">‚úÖ GOOD</span></div>
<div class="code-body"><span class="kw">const</span> value = <span class="hook">useMemo</span>(() => ({ user, setUser }), [user]);
<span class="tag">&lt;<span class="comp">MyContext.Provider</span></span> <span class="attr">value</span>={value}<span class="tag">&gt;</span></div></div>
      </div>
    </div>

    <div class="pitfall">
      <div class="pitfall-title">Pitfall #2: Using Context for EVERYTHING</div>
      <p>Context is NOT a replacement for all state management. Frequent updates (like mouse position, typing) in Context cause performance issues because EVERY consumer re-renders.</p>
      <div class="fix">
        <div class="fix-title">‚úÖ When to use Context:</div>
        <p>Theme, auth, locale, feature flags ‚Äî values that change <strong>infrequently</strong>.</p>
        <p>For frequent updates, consider: useState + props, useReducer, Zustand, or Jotai.</p>
      </div>
    </div>

    <div class="pitfall">
      <div class="pitfall-title">Pitfall #3: Forgetting the Provider wrapper</div>
      <p>If you forget to wrap your app with the Provider, <code class="code-inline">useContext</code> returns the default value (which is often <code class="code-inline">undefined</code>), causing silent bugs.</p>
      <div class="fix">
        <div class="fix-title">‚úÖ Fix: Add a guard in your custom hook</div>
        <div class="code-block"><div class="code-header"><span class="code-lang">jsx</span></div>
<div class="code-body"><span class="kw">function</span> <span class="fn">useMyContext</span>() {
  <span class="kw">const</span> ctx = <span class="hook">useContext</span>(<span class="comp">MyContext</span>);
  <span class="kw">if</span> (ctx === <span class="kw">undefined</span>) {
    <span class="kw">throw new</span> Error(<span class="str">'useMyContext must be within MyProvider'</span>);
  }
  <span class="kw">return</span> ctx;
}</div></div>
      </div>
    </div>

    <div class="pitfall">
      <div class="pitfall-title">Pitfall #4: One mega-Context instead of splitting</div>
      <p>Putting unrelated state in one Context (user + theme + cart + notifications) means changing ANY of them re-renders ALL consumers.</p>
      <div class="fix">
        <div class="fix-title">‚úÖ Fix: Split into separate contexts</div>
        <p>Create <code class="code-inline">AuthContext</code>, <code class="code-inline">ThemeContext</code>, <code class="code-inline">CartContext</code> separately. Components only subscribe to what they need.</p>
      </div>
    </div>
  </div>
</section>

<!-- ==================== CHAPTER 1: useReducer + useContext ==================== -->
<section class="chapter" id="ch-1">
  <div class="chapter-intro">
    <div class="chapter-num">Chapter 2 of 4</div>
    <h1>üîÑ useReducer + useContext</h1>
    <p class="subtitle">Build a predictable state management system ‚Äî your own mini-Redux!</p>
  </div>

  <!-- THEORY -->
  <div class="section-card purple">
    <h2>üß† Understanding useReducer</h2>

    <div class="analogy">
      <div class="analogy-title">Real-World Analogy</div>
      <p>Think of a <strong>vending machine</strong>. You press a button (dispatch an action), the machine processes it internally (reducer), and out comes your snack (new state). You don't reach inside the machine ‚Äî you interact only through defined buttons!</p>
    </div>

    <h3>The Pattern</h3>
    <div class="flow">
      <div class="flow-item" style="background:rgba(245,158,11,.15);color:var(--amber)">üéØ Action</div>
      <div class="flow-arrow">‚Üí</div>
      <div class="flow-item" style="background:rgba(168,85,247,.15);color:var(--purple)">üì§ dispatch()</div>
      <div class="flow-arrow">‚Üí</div>
      <div class="flow-item" style="background:rgba(0,212,255,.15);color:var(--cyan)">‚öôÔ∏è Reducer</div>
      <div class="flow-arrow">‚Üí</div>
      <div class="flow-item" style="background:rgba(16,185,129,.15);color:var(--emerald)">‚ú® New State</div>
      <div class="flow-arrow">‚Üí</div>
      <div class="flow-item" style="background:rgba(239,68,68,.15);color:var(--red)">üîÑ Re-render</div>
    </div>

    <h3>useReducer Signature</h3>
    <div class="code-block">
      <div class="code-header"><span class="code-lang">jsx</span></div>
      <div class="code-body"><span class="kw">const</span> [state, dispatch] = <span class="hook">useReducer</span>(reducerFn, initialState);

<span class="cm">// reducerFn: (currentState, action) => newState</span>
<span class="cm">// dispatch: function to send actions to the reducer</span></div>
    </div>

    <h3>When to use useReducer over useState?</h3>
    <ul>
      <li>State has <strong>multiple sub-values</strong> (objects with many fields)</li>
      <li>Next state depends on <strong>previous state</strong></li>
      <li>Complex <strong>state transitions</strong> (add, remove, update, filter)</li>
      <li>You want <strong>predictable, testable</strong> state updates</li>
    </ul>
  </div>

  <!-- EXAMPLE: Counter -->
  <div class="section-card purple">
    <h2>üìù Example 1: Counter with useReducer</h2>

    <div class="code-block">
      <div class="code-header"><span class="code-lang">jsx</span><button class="copy-btn" onclick="copyCode(this)">üìã Copy</button></div>
      <div class="code-body"><span class="kw">const</span> initialState = { count: <span class="num">0</span> };

<span class="kw">function</span> <span class="fn">counterReducer</span>(state, action) {
  <span class="kw">switch</span> (action.type) {
    <span class="kw">case</span> <span class="str">'INCREMENT'</span>:
      <span class="kw">return</span> { count: state.count + <span class="num">1</span> };
    <span class="kw">case</span> <span class="str">'DECREMENT'</span>:
      <span class="kw">return</span> { count: state.count - <span class="num">1</span> };
    <span class="kw">case</span> <span class="str">'RESET'</span>:
      <span class="kw">return</span> initialState;
    <span class="kw">case</span> <span class="str">'SET'</span>:
      <span class="kw">return</span> { count: action.payload };
    <span class="kw">default</span>:
      <span class="kw">throw new</span> Error(<span class="str">`Unknown action: ${action.type}`</span>);
  }
}

<span class="kw">function</span> <span class="fn">Counter</span>() {
  <span class="kw">const</span> [state, dispatch] = <span class="hook">useReducer</span>(counterReducer, initialState);

  <span class="kw">return</span> (
    <span class="tag">&lt;div&gt;</span>
      <span class="tag">&lt;p&gt;</span>Count: {state.count}<span class="tag">&lt;/p&gt;</span>
      <span class="tag">&lt;button</span> <span class="attr">onClick</span>={() => <span class="fn">dispatch</span>({ type: <span class="str">'INCREMENT'</span> })}<span class="tag">&gt;</span>+<span class="tag">&lt;/button&gt;</span>
      <span class="tag">&lt;button</span> <span class="attr">onClick</span>={() => <span class="fn">dispatch</span>({ type: <span class="str">'DECREMENT'</span> })}<span class="tag">&gt;</span>-<span class="tag">&lt;/button&gt;</span>
      <span class="tag">&lt;button</span> <span class="attr">onClick</span>={() => <span class="fn">dispatch</span>({ type: <span class="str">'RESET'</span> })}<span class="tag">&gt;</span>Reset<span class="tag">&lt;/button&gt;</span>
      <span class="tag">&lt;button</span> <span class="attr">onClick</span>={() => <span class="fn">dispatch</span>({ type: <span class="str">'SET'</span>, payload: <span class="num">100</span> })}<span class="tag">&gt;</span>Set 100<span class="tag">&lt;/button&gt;</span>
    <span class="tag">&lt;/div&gt;</span>
  );
}</div>
    </div>

    <!-- Interactive Counter Demo -->
    <div class="interactive">
      <div class="interactive-title">üéÆ Try It Live!</div>
      <div style="text-align:center">
        <div style="font-size:2rem;font-weight:800;margin:.5rem 0" id="reducer-count">0</div>
        <div style="font-size:.75rem;color:var(--text2);margin-bottom:.5rem" id="reducer-log">No actions dispatched yet</div>
        <div class="btn-group" style="justify-content:center">
          <button class="btn btn-purple" onclick="demoReducer('DECREMENT')">‚ûñ DECREMENT</button>
          <button class="btn btn-purple" onclick="demoReducer('INCREMENT')">‚ûï INCREMENT</button>
          <button class="btn btn-outline" onclick="demoReducer('RESET')">üîÑ RESET</button>
          <button class="btn btn-amber" onclick="demoReducer('SET')">üíØ SET 100</button>
        </div>
      </div>
    </div>
  </div>

  <!-- TODO EXAMPLE with useReducer + useContext -->
  <div class="section-card purple">
    <h2>üöÄ Example 2: Todo App with useReducer + useContext</h2>
    <p>This is the <strong>killer pattern</strong> ‚Äî combining useReducer with Context to create a global state management solution. <span class="badge badge-purple">Interview Favorite</span></p>

    <div class="code-block">
      <div class="code-header"><span class="code-lang">jsx</span><span>TodoContext.jsx ‚Äî Complete Implementation</span></div>
      <div class="code-body"><span class="kw">import</span> { createContext, useContext, useReducer } <span class="kw">from</span> <span class="str">'react'</span>;

<span class="cm">// Action types as constants (prevents typos!)</span>
<span class="kw">const</span> ACTIONS = {
  ADD: <span class="str">'ADD_TODO'</span>,
  TOGGLE: <span class="str">'TOGGLE_TODO'</span>,
  DELETE: <span class="str">'DELETE_TODO'</span>,
  EDIT: <span class="str">'EDIT_TODO'</span>,
};

<span class="cm">// Pure reducer function ‚Äî easy to test!</span>
<span class="kw">function</span> <span class="fn">todoReducer</span>(state, action) {
  <span class="kw">switch</span> (action.type) {
    <span class="kw">case</span> ACTIONS.ADD:
      <span class="kw">return</span> [
        ...state,
        { id: Date.<span class="fn">now</span>(), text: action.payload, done: <span class="kw">false</span> }
      ];
    <span class="kw">case</span> ACTIONS.TOGGLE:
      <span class="kw">return</span> state.<span class="fn">map</span>(todo =>
        todo.id === action.payload
          ? { ...todo, done: !todo.done }
          : todo
      );
    <span class="kw">case</span> ACTIONS.DELETE:
      <span class="kw">return</span> state.<span class="fn">filter</span>(todo => todo.id !== action.payload);
    <span class="kw">default</span>:
      <span class="kw">return</span> state;
  }
}

<span class="cm">// Separate contexts for state and dispatch (optimization!)</span>
<span class="kw">const</span> <span class="comp">TodoStateCtx</span> = <span class="fn">createContext</span>();
<span class="kw">const</span> <span class="comp">TodoDispatchCtx</span> = <span class="fn">createContext</span>();

<span class="kw">export function</span> <span class="fn">TodoProvider</span>({ children }) {
  <span class="kw">const</span> [todos, dispatch] = <span class="hook">useReducer</span>(todoReducer, []);

  <span class="kw">return</span> (
    <span class="tag">&lt;<span class="comp">TodoStateCtx.Provider</span></span> <span class="attr">value</span>={todos}<span class="tag">&gt;</span>
      <span class="tag">&lt;<span class="comp">TodoDispatchCtx.Provider</span></span> <span class="attr">value</span>={dispatch}<span class="tag">&gt;</span>
        {children}
      <span class="tag">&lt;/<span class="comp">TodoDispatchCtx.Provider</span>&gt;</span>
    <span class="tag">&lt;/<span class="comp">TodoStateCtx.Provider</span>&gt;</span>
  );
}

<span class="cm">// Custom hooks</span>
<span class="kw">export const</span> <span class="fn">useTodos</span> = () => <span class="hook">useContext</span>(<span class="comp">TodoStateCtx</span>);
<span class="kw">export const</span> <span class="fn">useTodoDispatch</span> = () => <span class="hook">useContext</span>(<span class="comp">TodoDispatchCtx</span>);</div>
    </div>

    <div class="tip"><p><strong>Why split state and dispatch into separate contexts?</strong> Components that only dispatch actions (like an "Add Todo" button) won't re-render when the todo list changes! This is a major optimization.</p></div>
  </div>

  <!-- INTERACTIVE STATE MACHINE -->
  <div class="section-card purple">
    <h2>üéÆ Interactive: State Machine Visualization</h2>
    <p>Watch how actions flow through the reducer to produce new state:</p>
    <div class="interactive" id="state-machine">
      <div style="display:flex;flex-wrap:wrap;gap:1rem;align-items:center;justify-content:center">
        <div class="render-component" id="sm-action" style="min-width:120px">
          <div>üì§ Action</div>
          <div class="render-label" id="sm-action-text">‚Äî</div>
        </div>
        <div style="font-size:1.5rem;color:var(--purple)">‚Üí</div>
        <div class="render-component" id="sm-reducer" style="min-width:120px;border-color:var(--purple)">
          <div>‚öôÔ∏è Reducer</div>
          <div class="render-label">Processing...</div>
        </div>
        <div style="font-size:1.5rem;color:var(--purple)">‚Üí</div>
        <div class="render-component" id="sm-state" style="min-width:200px;border-color:var(--emerald)">
          <div>üì¶ State</div>
          <div class="render-label" id="sm-state-text">{ todos: [] }</div>
        </div>
      </div>
      <div class="btn-group" style="justify-content:center;margin-top:1rem">
        <button class="btn btn-purple" onclick="smDispatch('ADD','Buy milk')">‚ûï Add "Buy milk"</button>
        <button class="btn btn-purple" onclick="smDispatch('ADD','Learn React')">‚ûï Add "Learn React"</button>
        <button class="btn btn-amber" onclick="smDispatch('TOGGLE',0)">‚úÖ Toggle First</button>
        <button class="btn btn-outline" onclick="smDispatch('DELETE',0)" style="border-color:var(--red);color:var(--red)">üóëÔ∏è Delete First</button>
      </div>
    </div>
  </div>

  <!-- QUIZ -->
  <div class="section-card purple">
    <h2>üß† Quiz: useReducer</h2>

    <div class="quiz" data-quiz="red-1">
      <div class="quiz-question">Q1: What must a reducer function always return?</div>
      <div class="quiz-options">
        <button class="quiz-opt" onclick="checkQuiz('red-1',this,false)">A) undefined</button>
        <button class="quiz-opt" onclick="checkQuiz('red-1',this,true)">B) The new state</button>
        <button class="quiz-opt" onclick="checkQuiz('red-1',this,false)">C) A Promise</button>
        <button class="quiz-opt" onclick="checkQuiz('red-1',this,false)">D) The action object</button>
      </div>
      <div class="quiz-explanation" id="red-1-exp"></div>
    </div>

    <div class="quiz" data-quiz="red-2">
      <div class="quiz-question">Q2: Why split state and dispatch into separate Contexts?</div>
      <div class="quiz-options">
        <button class="quiz-opt" onclick="checkQuiz('red-2',this,false)">A) It's required by React</button>
        <button class="quiz-opt" onclick="checkQuiz('red-2',this,true)">B) So components that only dispatch don't re-render when state changes</button>
        <button class="quiz-opt" onclick="checkQuiz('red-2',this,false)">C) To avoid using useReducer</button>
        <button class="quiz-opt" onclick="checkQuiz('red-2',this,false)">D) It has no benefit, it's just convention</button>
      </div>
      <div class="quiz-explanation" id="red-2-exp"></div>
    </div>

    <div class="quiz" data-quiz="red-3">
      <div class="quiz-question">Q3: Can you put async logic (API calls) inside a reducer?</div>
      <div class="quiz-options">
        <button class="quiz-opt" onclick="checkQuiz('red-3',this,true)">A) No ‚Äî reducers must be pure functions</button>
        <button class="quiz-opt" onclick="checkQuiz('red-3',this,false)">B) Yes ‚Äî reducers can do anything</button>
        <button class="quiz-opt" onclick="checkQuiz('red-3',this,false)">C) Only with useEffect</button>
        <button class="quiz-opt" onclick="checkQuiz('red-3',this,false)">D) Only if you use middleware</button>
      </div>
      <div class="quiz-explanation" id="red-3-exp"></div>
    </div>

    <div class="quiz" data-quiz="red-4">
      <div class="quiz-question">Q4: What's in the action object by convention?</div>
      <div class="quiz-options">
        <button class="quiz-opt" onclick="checkQuiz('red-4',this,false)">A) { name, data }</button>
        <button class="quiz-opt" onclick="checkQuiz('red-4',this,true)">B) { type, payload }</button>
        <button class="quiz-opt" onclick="checkQuiz('red-4',this,false)">C) { action, value }</button>
        <button class="quiz-opt" onclick="checkQuiz('red-4',this,false)">D) { kind, args }</button>
      </div>
      <div class="quiz-explanation" id="red-4-exp"></div>
    </div>
  </div>

  <!-- EXERCISE -->
  <div class="section-card purple">
    <h2>üí™ Exercise: Build a Shopping Cart Reducer</h2>
    <div class="exercise" data-ex="red-ex1">
      <div class="exercise-prompt">Complete the reducer for a shopping cart. Handle ADD_ITEM (with payload as item object) and REMOVE_ITEM (with payload as item id):</div>
      <textarea id="red-ex1-input" spellcheck="false">function cartReducer(state, action) {
  switch (action.type) {
    case 'ADD_ITEM':
      // Return new array with item added
      return ______;
    case 'REMOVE_ITEM':
      // Return new array without the item
      return ______;
    default:
      return state;
  }
}</textarea>
      <div class="btn-group">
        <button class="btn btn-purple" onclick="checkExercise('red-ex1')">‚úÖ Check</button>
        <button class="btn btn-outline" onclick="showHint('red-ex1')">üí° Hint</button>
        <button class="btn btn-outline" onclick="showSolution('red-ex1')">üëÅÔ∏è Solution</button>
      </div>
      <div class="exercise-hint" id="red-ex1-hint">ADD: spread the state array and add action.payload. REMOVE: use .filter() to remove by id</div>
      <div class="exercise-result" id="red-ex1-result"></div>
    </div>
  </div>

  <!-- PITFALLS -->
  <div class="section-card purple">
    <h2>üö® Common Pitfalls</h2>

    <div class="pitfall">
      <div class="pitfall-title">Pitfall #1: Mutating state in the reducer</div>
      <div class="code-block"><div class="code-header"><span class="badge badge-red">‚ùå BAD</span></div>
<div class="code-body"><span class="kw">case</span> <span class="str">'TOGGLE'</span>:
  state.todos[action.index].done = !state.todos[action.index].done;  <span class="cm">// MUTATION!</span>
  <span class="kw">return</span> state;  <span class="cm">// Same reference ‚Äî React won't re-render!</span></div></div>
      <div class="fix"><div class="fix-title">‚úÖ Always return NEW objects/arrays</div>
<div class="code-block"><div class="code-header"><span class="badge badge-emerald">‚úÖ GOOD</span></div>
<div class="code-body"><span class="kw">case</span> <span class="str">'TOGGLE'</span>:
  <span class="kw">return</span> {
    ...state,
    todos: state.todos.<span class="fn">map</span>((t, i) =>
      i === action.index ? { ...t, done: !t.done } : t
    )
  };</div></div>
      </div>
    </div>

    <div class="pitfall">
      <div class="pitfall-title">Pitfall #2: Missing default case</div>
      <p>Without a default case, dispatching an unknown action returns undefined, which can crash your app.</p>
      <div class="fix"><div class="fix-title">‚úÖ Always include default ‚Äî return current state or throw</div>
<div class="code-block"><div class="code-header"><span class="badge badge-emerald">‚úÖ GOOD</span></div>
<div class="code-body"><span class="kw">default</span>:
  <span class="kw">throw new</span> Error(<span class="str">`Unhandled action: ${action.type}`</span>);
  <span class="cm">// OR: return state;</span></div></div>
      </div>
    </div>

    <div class="pitfall">
      <div class="pitfall-title">Pitfall #3: Async logic in reducers</div>
      <p>Reducers must be <strong>pure</strong> ‚Äî no API calls, no side effects, no random values.</p>
      <div class="fix"><div class="fix-title">‚úÖ Do async work outside, then dispatch the result</div>
<div class="code-block"><div class="code-header"><span class="badge badge-emerald">‚úÖ GOOD</span></div>
<div class="code-body"><span class="kw">const</span> <span class="fn">fetchTodos</span> = <span class="kw">async</span> () => {
  <span class="fn">dispatch</span>({ type: <span class="str">'LOADING'</span> });
  <span class="kw">const</span> data = <span class="kw">await</span> <span class="fn">fetch</span>(<span class="str">'/api/todos'</span>);
  <span class="fn">dispatch</span>({ type: <span class="str">'LOADED'</span>, payload: data });
};</div></div>
      </div>
    </div>
  </div>
</section>

<!-- ==================== CHAPTER 2: useMemo & useCallback ==================== -->
<section class="chapter" id="ch-2">
  <div class="chapter-intro">
    <div class="chapter-num">Chapter 3 of 4</div>
    <h1>‚ö° useMemo & useCallback</h1>
    <p class="subtitle">Master performance optimization ‚Äî know when to use and when NOT to</p>
  </div>

  <!-- THEORY: WHY RE-RENDERS -->
  <div class="section-card emerald">
    <h2>üîç Why Components Re-Render</h2>
    <p>Before optimizing, you MUST understand <strong>what causes re-renders</strong>:</p>
    <ol>
      <li><strong>State changes</strong> ‚Äî calling setState/dispatch</li>
      <li><strong>Parent re-renders</strong> ‚Äî if parent re-renders, ALL children re-render by default</li>
      <li><strong>Context changes</strong> ‚Äî when a consumed context value changes</li>
    </ol>

    <div class="analogy">
      <div class="analogy-title">Real-World Analogy</div>
      <p><strong>useMemo</strong> is like a <strong>calculator with memory</strong>. If you ask "what's 247 √ó 389?" it calculates once and remembers. Ask again with the same numbers? Instant answer. Different numbers? It recalculates.</p>
      <p><strong>useCallback</strong> is like giving someone your <strong>business card</strong> instead of writing your number on a new napkin every time. Same card = same reference = they know it hasn't changed.</p>
    </div>
  </div>

  <!-- REFERENCE EQUALITY -->
  <div class="section-card emerald">
    <h2>üîë The Key Concept: Reference Equality</h2>
    <p>This is the <strong>#1 concept</strong> you must understand for optimization:</p>

    <div class="code-block">
      <div class="code-header"><span class="code-lang">js</span><span>Understanding References</span></div>
      <div class="code-body"><span class="cm">// Primitives compare by VALUE</span>
<span class="str">"hello"</span> === <span class="str">"hello"</span>  <span class="cm">// true ‚úÖ</span>
<span class="num">42</span> === <span class="num">42</span>              <span class="cm">// true ‚úÖ</span>

<span class="cm">// Objects/arrays/functions compare by REFERENCE</span>
{ name: <span class="str">"Dan"</span> } === { name: <span class="str">"Dan"</span> }  <span class="cm">// false ‚ùå (different objects!)</span>
[<span class="num">1</span>,<span class="num">2</span>,<span class="num">3</span>] === [<span class="num">1</span>,<span class="num">2</span>,<span class="num">3</span>]                  <span class="cm">// false ‚ùå (different arrays!)</span>

<span class="kw">const</span> <span class="fn">fn1</span> = () => <span class="num">42</span>;
<span class="kw">const</span> <span class="fn">fn2</span> = () => <span class="num">42</span>;
fn1 === fn2  <span class="cm">// false ‚ùå (different function instances!)</span>

<span class="cm">// THIS is why React re-renders children even with "same" props</span>
<span class="cm">// Every render creates NEW object/function references</span></div>
    </div>

    <div class="interactive">
      <div class="interactive-title">üéÆ Reference Equality Tester</div>
      <div style="display:flex;gap:1rem;flex-wrap:wrap;justify-content:center">
        <button class="btn btn-success" onclick="refTest('42 === 42')">42 === 42</button>
        <button class="btn btn-success" onclick="refTest('{} === {}')">{ } === { }</button>
        <button class="btn btn-success" onclick="refTest('[] === []')">[ ] === [ ]</button>
        <button class="btn btn-success" onclick="refTest('fn === fn')">"hi" === "hi"</button>
      </div>
      <div id="ref-result" style="text-align:center;margin-top:1rem;font-size:1.1rem;font-weight:700"></div>
    </div>
  </div>

  <!-- useMemo -->
  <div class="section-card emerald">
    <h2>üßÆ useMemo ‚Äî Memoize Expensive Values</h2>

    <div class="code-block">
      <div class="code-header"><span class="code-lang">jsx</span><span>Syntax</span></div>
      <div class="code-body"><span class="kw">const</span> memoizedValue = <span class="hook">useMemo</span>(() => {
  <span class="kw">return</span> <span class="fn">expensiveComputation</span>(a, b);
}, [a, b]); <span class="cm">// Only recomputes when a or b change</span></div>
    </div>

    <h3>Example: Filtering a Large List</h3>
    <div class="code-block">
      <div class="code-header"><span class="code-lang">jsx</span><button class="copy-btn" onclick="copyCode(this)">üìã Copy</button></div>
      <div class="code-body"><span class="kw">function</span> <span class="fn">ProductList</span>({ products, searchTerm }) {
  <span class="cm">// ‚ùå Without useMemo: filters on EVERY render (even unrelated ones)</span>
  <span class="cm">// const filtered = products.filter(p => p.name.includes(searchTerm));</span>

  <span class="cm">// ‚úÖ With useMemo: only re-filters when products or searchTerm change</span>
  <span class="kw">const</span> filtered = <span class="hook">useMemo</span>(() => {
    console.<span class="fn">log</span>(<span class="str">'Filtering...'</span>); <span class="cm">// Watch when this runs!</span>
    <span class="kw">return</span> products.<span class="fn">filter</span>(p =>
      p.name.<span class="fn">toLowerCase</span>().<span class="fn">includes</span>(searchTerm.<span class="fn">toLowerCase</span>())
    );
  }, [products, searchTerm]);

  <span class="kw">const</span> [count, setCount] = <span class="hook">useState</span>(<span class="num">0</span>);

  <span class="kw">return</span> (
    <span class="tag">&lt;div&gt;</span>
      <span class="cm">{/* Clicking this won't re-filter because count isn't a dependency */}</span>
      <span class="tag">&lt;button</span> <span class="attr">onClick</span>={() => <span class="fn">setCount</span>(c => c + <span class="num">1</span>)}<span class="tag">&gt;</span>
        Clicked {count} times
      <span class="tag">&lt;/button&gt;</span>
      {filtered.<span class="fn">map</span>(p => <span class="tag">&lt;div</span> <span class="attr">key</span>={p.id}<span class="tag">&gt;</span>{p.name}<span class="tag">&lt;/div&gt;</span>)}
    <span class="tag">&lt;/div&gt;</span>
  );
}</div>
    </div>

    <div class="interactive">
      <div class="interactive-title">üéÆ useMemo Demo ‚Äî Watch Computation Count</div>
      <div style="display:flex;gap:1rem;flex-wrap:wrap;justify-content:center;align-items:center">
        <div>
          <label style="font-size:.8rem;color:var(--text2)">Search:</label><br>
          <input type="text" id="memo-search" oninput="memoDemo()" placeholder="Filter items..." style="padding:.4rem .8rem;background:var(--codebg);border:1px solid var(--border);border-radius:6px;color:var(--text);font-size:.9rem">
        </div>
        <button class="btn btn-success" onclick="memoUnrelated()">Click Me (unrelated state)</button>
        <div style="text-align:center">
          <div style="font-size:.75rem;color:var(--text2)">Unrelated renders: <span id="memo-renders" style="color:var(--amber)">0</span></div>
          <div style="font-size:.75rem;color:var(--text2)">Filter computations: <span id="memo-computes" style="color:var(--emerald)">0</span></div>
        </div>
      </div>
      <div id="memo-results" style="margin-top:.8rem;font-size:.85rem;color:var(--text2)"></div>
      <p style="font-size:.75rem;color:var(--text2);margin-top:.5rem">üëÜ Notice: clicking the button increases renders but NOT filter computations ‚Äî that's useMemo!</p>
    </div>
  </div>

  <!-- useCallback -->
  <div class="section-card emerald">
    <h2>üîí useCallback ‚Äî Memoize Functions</h2>

    <div class="code-block">
      <div class="code-header"><span class="code-lang">jsx</span><span>Syntax</span></div>
      <div class="code-body"><span class="cm">// useCallback returns the SAME function reference between renders</span>
<span class="kw">const</span> <span class="fn">memoizedFn</span> = <span class="hook">useCallback</span>(() => {
  <span class="fn">doSomething</span>(a, b);
}, [a, b]);

<span class="cm">// Equivalent to:</span>
<span class="kw">const</span> <span class="fn">memoizedFn</span> = <span class="hook">useMemo</span>(() => {
  <span class="kw">return</span> () => <span class="fn">doSomething</span>(a, b);
}, [a, b]);</div>
    </div>

    <h3>When useCallback Matters</h3>
    <div class="code-block">
      <div class="code-header"><span class="code-lang">jsx</span><button class="copy-btn" onclick="copyCode(this)">üìã Copy</button></div>
      <div class="code-body"><span class="cm">// Without useCallback: ExpensiveChild re-renders every time Parent renders</span>
<span class="cm">// because handleClick is a NEW function reference each render</span>

<span class="kw">function</span> <span class="fn">Parent</span>() {
  <span class="kw">const</span> [count, setCount] = <span class="hook">useState</span>(<span class="num">0</span>);
  <span class="kw">const</span> [name, setName] = <span class="hook">useState</span>(<span class="str">''</span>);

  <span class="cm">// ‚úÖ Stable reference ‚Äî only changes when count changes</span>
  <span class="kw">const</span> <span class="fn">handleClick</span> = <span class="hook">useCallback</span>(() => {
    console.<span class="fn">log</span>(<span class="str">'Count is:'</span>, count);
  }, [count]);

  <span class="kw">return</span> (
    <span class="tag">&lt;div&gt;</span>
      <span class="tag">&lt;input</span> <span class="attr">value</span>={name} <span class="attr">onChange</span>={e => <span class="fn">setName</span>(e.target.value)} /&gt;
      <span class="cm">{/* Won't re-render when name changes, only when count changes */}</span>
      <span class="tag">&lt;<span class="comp">ExpensiveChild</span></span> <span class="attr">onClick</span>={handleClick} /&gt;
    <span class="tag">&lt;/div&gt;</span>
  );
}

<span class="cm">// Must use React.memo for useCallback to matter!</span>
<span class="kw">const</span> <span class="comp">ExpensiveChild</span> = React.<span class="fn">memo</span>(({ onClick }) => {
  console.<span class="fn">log</span>(<span class="str">'ExpensiveChild rendered'</span>);
  <span class="kw">return</span> <span class="tag">&lt;button</span> <span class="attr">onClick</span>={onClick}<span class="tag">&gt;</span>Click<span class="tag">&lt;/button&gt;</span>;
});</div>
    </div>

    <div class="tip"><p><strong>Critical:</strong> <code class="code-inline">useCallback</code> is USELESS without <code class="code-inline">React.memo</code> on the child! If the child doesn't check props with memo, it re-renders anyway because its parent re-rendered.</p></div>
  </div>

  <!-- RE-RENDER VISUALIZATION -->
  <div class="section-card emerald">
    <h2>üéÆ Interactive: Re-render Visualization</h2>
    <p>Watch which components re-render with and without optimization:</p>

    <div class="tab-container">
      <div class="tab-buttons">
        <button class="tab-btn active" onclick="switchTab(this,'viz')">Without Optimization</button>
        <button class="tab-btn" onclick="switchTab(this,'viz')">With useMemo/useCallback</button>
      </div>
      <div class="tab-content active" data-tab="viz">
        <div class="interactive">
          <div class="render-viz">
            <div>
              <div class="render-component" id="viz1-parent">Parent<div class="render-count">renders: <span>0</span></div></div>
            </div>
          </div>
          <div style="display:flex;gap:1rem;justify-content:center;flex-wrap:wrap;margin:.5rem 0">
            <div class="render-component" id="viz1-child1">ExpensiveList<div class="render-label">renders: <span>0</span></div></div>
            <div class="render-component" id="viz1-child2">Chart<div class="render-label">renders: <span>0</span></div></div>
            <div class="render-component" id="viz1-child3">Footer<div class="render-label">renders: <span>0</span></div></div>
          </div>
          <div class="btn-group" style="justify-content:center">
            <button class="btn btn-success" onclick="vizRender(1,'all')">setState in Parent</button>
          </div>
          <p style="font-size:.75rem;color:var(--red);text-align:center;margin-top:.5rem">‚ùå ALL children re-render every time!</p>
        </div>
      </div>
      <div class="tab-content" data-tab="viz">
        <div class="interactive">
          <div class="render-viz">
            <div class="render-component" id="viz2-parent">Parent<div class="render-count">renders: <span>0</span></div></div>
          </div>
          <div style="display:flex;gap:1rem;justify-content:center;flex-wrap:wrap;margin:.5rem 0">
            <div class="render-component memoized" id="viz2-child1">memo(ExpensiveList)<div class="render-label">renders: <span>0</span></div></div>
            <div class="render-component memoized" id="viz2-child2">memo(Chart)<div class="render-label">renders: <span>0</span></div></div>
            <div class="render-component" id="viz2-child3">Footer<div class="render-label">renders: <span>0</span></div></div>
          </div>
          <div class="btn-group" style="justify-content:center">
            <button class="btn btn-success" onclick="vizRender(2,'optimized')">setState in Parent</button>
          </div>
          <p style="font-size:.75rem;color:var(--green);text-align:center;margin-top:.5rem">‚úÖ Memoized children skip re-rendering!</p>
        </div>
      </div>
    </div>
  </div>

  <!-- QUIZ -->
  <div class="section-card emerald">
    <h2>üß† Quiz: useMemo & useCallback</h2>

    <div class="quiz" data-quiz="memo-1">
      <div class="quiz-question">Q1: useMemo returns...</div>
      <div class="quiz-options">
        <button class="quiz-opt" onclick="checkQuiz('memo-1',this,true)">A) A memoized value (result of the function)</button>
        <button class="quiz-opt" onclick="checkQuiz('memo-1',this,false)">B) A memoized function</button>
        <button class="quiz-opt" onclick="checkQuiz('memo-1',this,false)">C) A boolean</button>
        <button class="quiz-opt" onclick="checkQuiz('memo-1',this,false)">D) A ref object</button>
      </div>
      <div class="quiz-explanation" id="memo-1-exp"></div>
    </div>

    <div class="quiz" data-quiz="memo-2">
      <div class="quiz-question">Q2: useCallback is useless without...</div>
      <div class="quiz-options">
        <button class="quiz-opt" onclick="checkQuiz('memo-2',this,false)">A) useEffect</button>
        <button class="quiz-opt" onclick="checkQuiz('memo-2',this,false)">B) useState</button>
        <button class="quiz-opt" onclick="checkQuiz('memo-2',this,true)">C) React.memo on the child component</button>
        <button class="quiz-opt" onclick="checkQuiz('memo-2',this,false)">D) useReducer</button>
      </div>
      <div class="quiz-explanation" id="memo-2-exp"></div>
    </div>

    <div class="quiz" data-quiz="memo-3">
      <div class="quiz-question">Q3: When should you NOT use useMemo?</div>
      <div class="quiz-options">
        <button class="quiz-opt" onclick="checkQuiz('memo-3',this,false)">A) When filtering a 10,000 item list</button>
        <button class="quiz-opt" onclick="checkQuiz('memo-3',this,true)">B) For simple operations like adding two numbers</button>
        <button class="quiz-opt" onclick="checkQuiz('memo-3',this,false)">C) When creating objects passed to memoized children</button>
        <button class="quiz-opt" onclick="checkQuiz('memo-3',this,false)">D) When the computation involves sorting</button>
      </div>
      <div class="quiz-explanation" id="memo-3-exp"></div>
    </div>

    <div class="quiz" data-quiz="memo-4">
      <div class="quiz-question">Q4: What does this return? <code class="code-inline">useCallback(fn, [a, b])</code></div>
      <div class="quiz-options">
        <button class="quiz-opt" onclick="checkQuiz('memo-4',this,false)">A) The result of calling fn(a, b)</button>
        <button class="quiz-opt" onclick="checkQuiz('memo-4',this,true)">B) fn itself, but with a stable reference that changes only when a or b change</button>
        <button class="quiz-opt" onclick="checkQuiz('memo-4',this,false)">C) A new function every time</button>
        <button class="quiz-opt" onclick="checkQuiz('memo-4',this,false)">D) undefined</button>
      </div>
      <div class="quiz-explanation" id="memo-4-exp"></div>
    </div>
  </div>

  <!-- EXERCISE -->
  <div class="section-card emerald">
    <h2>üí™ Exercise: Optimize This Component</h2>
    <div class="exercise" data-ex="memo-ex1">
      <div class="exercise-prompt">This component has performance issues. Add useMemo for the expensive computation and useCallback for the handler:</div>
      <textarea id="memo-ex1-input" spellcheck="false">function SearchResults({ items, query }) {
  const [selected, setSelected] = useState(null);

  // TODO: Wrap with useMemo
  const filtered = items.filter(item =>
    item.name.toLowerCase().includes(query.toLowerCase())
  ).sort((a, b) => a.name.localeCompare(b.name));

  // TODO: Wrap with useCallback
  const handleSelect = (id) => {
    setSelected(id);
  };

  return (
    <div>
      {filtered.map(item => (
        <MemoizedItem
          key={item.id}
          item={item}
          onSelect={handleSelect}
          isSelected={item.id === selected}
        />
      ))}
    </div>
  );
}</textarea>
      <div class="btn-group">
        <button class="btn btn-success" onclick="checkExercise('memo-ex1')">‚úÖ Check</button>
        <button class="btn btn-outline" onclick="showHint('memo-ex1')">üí° Hint</button>
        <button class="btn btn-outline" onclick="showSolution('memo-ex1')">üëÅÔ∏è Solution</button>
      </div>
      <div class="exercise-hint" id="memo-ex1-hint">Wrap filtered with useMemo([items, query]) and handleSelect with useCallback([]). Think about dependencies!</div>
      <div class="exercise-result" id="memo-ex1-result"></div>
    </div>
  </div>

  <!-- PITFALLS -->
  <div class="section-card emerald">
    <h2>üö® Common Pitfalls</h2>

    <div class="pitfall">
      <div class="pitfall-title">Pitfall #1: Premature Optimization</div>
      <p><strong>The #1 mistake!</strong> Don't wrap everything in useMemo/useCallback. Memoization has a cost (memory + comparison). Only optimize when you measure a problem.</p>
      <div class="fix"><div class="fix-title">‚úÖ Rule of thumb</div>
        <p>Profile first with React DevTools. If a computation takes &lt;1ms, useMemo likely adds overhead rather than saving it.</p>
      </div>
    </div>

    <div class="pitfall">
      <div class="pitfall-title">Pitfall #2: Missing dependencies</div>
      <div class="code-block"><div class="code-header"><span class="badge badge-red">‚ùå STALE CLOSURE</span></div>
<div class="code-body"><span class="kw">const</span> <span class="fn">handleClick</span> = <span class="hook">useCallback</span>(() => {
  console.<span class="fn">log</span>(count); <span class="cm">// Always logs the initial count!</span>
}, []); <span class="cm">// Missing count in deps ‚ö†Ô∏è</span></div></div>
      <div class="fix"><div class="fix-title">‚úÖ Always include all used variables in deps</div>
<div class="code-block"><div class="code-header"><span class="badge badge-emerald">‚úÖ CORRECT</span></div>
<div class="code-body"><span class="kw">const</span> <span class="fn">handleClick</span> = <span class="hook">useCallback</span>(() => {
  console.<span class="fn">log</span>(count);
}, [count]); <span class="cm">// ‚úÖ Updates when count changes</span></div></div>
      </div>
    </div>

    <div class="pitfall">
      <div class="pitfall-title">Pitfall #3: useCallback without React.memo</div>
      <p>useCallback alone does NOTHING for performance. The child component must be wrapped in <code class="code-inline">React.memo</code> to skip re-renders based on prop comparison.</p>
    </div>

    <div class="pitfall">
      <div class="pitfall-title">Pitfall #4: Memoizing inside map/loop</div>
      <p>You can't call hooks inside loops, conditions, or callbacks. This is a Rules of Hooks violation!</p>
      <div class="code-block"><div class="code-header"><span class="badge badge-red">‚ùå WILL CRASH</span></div>
<div class="code-body">items.<span class="fn">map</span>(item => {
  <span class="kw">const</span> val = <span class="hook">useMemo</span>(() => compute(item), [item]); <span class="cm">// ‚ùå Hook in loop!</span>
});</div></div>
    </div>
  </div>
</section>

<!-- ==================== CHAPTER 3: Custom Hooks ==================== -->
<section class="chapter" id="ch-3">
  <div class="chapter-intro">
    <div class="chapter-num">Chapter 4 of 4</div>
    <h1>ü™ù Custom Hooks</h1>
    <p class="subtitle">Extract, reuse, and compose logic like a senior developer</p>
  </div>

  <!-- THEORY -->
  <div class="section-card amber">
    <h2>üéØ What Are Custom Hooks?</h2>
    <p>Custom hooks are <strong>JavaScript functions that start with "use"</strong> and can call other hooks. They let you extract component logic into reusable functions.</p>

    <div class="analogy">
      <div class="analogy-title">Real-World Analogy</div>
      <p>Custom hooks are like <strong>kitchen appliances</strong>. Instead of manually dicing vegetables every time (duplicating logic in components), you use a food processor (custom hook). Any recipe (component) can use the same appliance!</p>
    </div>

    <h3>The Rules</h3>
    <ul>
      <li>Name MUST start with <code class="code-inline">use</code> (useMyHook, not myHook)</li>
      <li>Can call other hooks (useState, useEffect, useContext, other custom hooks)</li>
      <li>Each component using the hook gets its OWN separate state</li>
      <li>Follow the same Rules of Hooks (no conditionals, no loops)</li>
    </ul>

    <div class="diagram">
      <div class="diagram-title">üîç Custom Hook = Extracted Logic</div>
      <div class="diagram-row">
        <div>
          <h3 style="text-align:center;color:var(--red);margin-top:0">‚ùå Before: Duplicated Logic</h3>
          <div class="code-block" style="margin:0"><div class="code-body" style="font-size:.75rem"><span class="cm">// ComponentA</span>
<span class="kw">const</span> [data, setData] = <span class="hook">useState</span>(<span class="kw">null</span>);
<span class="kw">const</span> [loading, setLoading] = <span class="hook">useState</span>(<span class="kw">true</span>);
<span class="kw">const</span> [error, setError] = <span class="hook">useState</span>(<span class="kw">null</span>);
<span class="hook">useEffect</span>(() => { <span class="fn">fetch</span>(url)... }, [url]);

<span class="cm">// ComponentB ‚Äî SAME code copy-pasted!</span>
<span class="kw">const</span> [data, setData] = <span class="hook">useState</span>(<span class="kw">null</span>);
<span class="kw">const</span> [loading, setLoading] = <span class="hook">useState</span>(<span class="kw">true</span>);
...</div></div>
        </div>
        <div>
          <h3 style="text-align:center;color:var(--green);margin-top:0">‚úÖ After: Custom Hook</h3>
          <div class="code-block" style="margin:0"><div class="code-body" style="font-size:.75rem"><span class="cm">// useFetch.js ‚Äî write once!</span>
<span class="kw">function</span> <span class="fn">useFetch</span>(url) {
  <span class="cm">// all the logic here</span>
  <span class="kw">return</span> { data, loading, error };
}

<span class="cm">// ComponentA</span>
<span class="kw">const</span> { data } = <span class="fn">useFetch</span>(<span class="str">'/api/users'</span>);

<span class="cm">// ComponentB</span>
<span class="kw">const</span> { data } = <span class="fn">useFetch</span>(<span class="str">'/api/posts'</span>);</div></div>
        </div>
      </div>
    </div>
  </div>

  <!-- EXAMPLES -->
  <div class="section-card amber">
    <h2>üìù Essential Custom Hooks Collection</h2>
    <p>These are hooks you'll build and use in every production app. <span class="badge badge-amber">Interview Gold</span></p>

    <div class="tab-container">
      <div class="tab-buttons">
        <button class="tab-btn active" onclick="switchTab(this,'hooks')">useToggle</button>
        <button class="tab-btn" onclick="switchTab(this,'hooks')">useLocalStorage</button>
        <button class="tab-btn" onclick="switchTab(this,'hooks')">useFetch</button>
        <button class="tab-btn" onclick="switchTab(this,'hooks')">useDebounce</button>
        <button class="tab-btn" onclick="switchTab(this,'hooks')">usePrevious</button>
        <button class="tab-btn" onclick="switchTab(this,'hooks')">useWindowSize</button>
      </div>

      <!-- useToggle -->
      <div class="tab-content active" data-tab="hooks">
        <h3>useToggle ‚Äî The Simplest Custom Hook</h3>
        <div class="code-block">
          <div class="code-header"><span class="code-lang">jsx</span><button class="copy-btn" onclick="copyCode(this)">üìã Copy</button></div>
          <div class="code-body"><span class="kw">import</span> { useState, <span class="hook">useCallback</span> } <span class="kw">from</span> <span class="str">'react'</span>;

<span class="kw">function</span> <span class="fn">useToggle</span>(initialValue = <span class="kw">false</span>) {
  <span class="kw">const</span> [value, setValue] = <span class="hook">useState</span>(initialValue);

  <span class="kw">const</span> <span class="fn">toggle</span> = <span class="hook">useCallback</span>(() => {
    <span class="fn">setValue</span>(v => !v);
  }, []);

  <span class="kw">const</span> <span class="fn">setTrue</span> = <span class="hook">useCallback</span>(() => <span class="fn">setValue</span>(<span class="kw">true</span>), []);
  <span class="kw">const</span> <span class="fn">setFalse</span> = <span class="hook">useCallback</span>(() => <span class="fn">setValue</span>(<span class="kw">false</span>), []);

  <span class="kw">return</span> { value, toggle, setTrue, setFalse };
}

<span class="cm">// Usage:</span>
<span class="kw">function</span> <span class="fn">Modal</span>() {
  <span class="kw">const</span> { value: isOpen, toggle, setFalse: close } = <span class="fn">useToggle</span>();
  <span class="kw">return</span> (
    <span class="tag">&lt;&gt;</span>
      <span class="tag">&lt;button</span> <span class="attr">onClick</span>={toggle}<span class="tag">&gt;</span>Open Modal<span class="tag">&lt;/button&gt;</span>
      {isOpen && <span class="tag">&lt;div</span> <span class="attr">className</span>=<span class="str">"modal"</span><span class="tag">&gt;</span>
        <span class="tag">&lt;button</span> <span class="attr">onClick</span>={close}<span class="tag">&gt;</span>Close<span class="tag">&lt;/button&gt;</span>
      <span class="tag">&lt;/div&gt;</span>}
    <span class="tag">&lt;/&gt;</span>
  );
}</div>
        </div>
        <div class="interactive">
          <div class="interactive-title">üéÆ Try It</div>
          <div style="text-align:center">
            <div style="font-size:1.5rem;margin-bottom:.5rem" id="toggle-val">OFF üî¥</div>
            <button class="btn btn-amber" onclick="demoToggle()">Toggle!</button>
          </div>
        </div>
      </div>

      <!-- useLocalStorage -->
      <div class="tab-content" data-tab="hooks">
        <h3>useLocalStorage ‚Äî Persist State Across Sessions</h3>
        <div class="code-block">
          <div class="code-header"><span class="code-lang">jsx</span><button class="copy-btn" onclick="copyCode(this)">üìã Copy</button></div>
          <div class="code-body"><span class="kw">function</span> <span class="fn">useLocalStorage</span>(key, initialValue) {
  <span class="cm">// Initialize state from localStorage or use initial value</span>
  <span class="kw">const</span> [storedValue, setStoredValue] = <span class="hook">useState</span>(() => {
    <span class="kw">try</span> {
      <span class="kw">const</span> item = window.localStorage.<span class="fn">getItem</span>(key);
      <span class="kw">return</span> item ? JSON.<span class="fn">parse</span>(item) : initialValue;
    } <span class="kw">catch</span> (error) {
      console.<span class="fn">warn</span>(<span class="str">`Error reading localStorage key "${key}":`</span>, error);
      <span class="kw">return</span> initialValue;
    }
  });

  <span class="cm">// Wrapper around setState that also saves to localStorage</span>
  <span class="kw">const</span> <span class="fn">setValue</span> = <span class="hook">useCallback</span>((value) => {
    <span class="kw">try</span> {
      <span class="cm">// Allow value to be a function (like useState)</span>
      <span class="kw">const</span> valueToStore = value <span class="kw">instanceof</span> Function
        ? <span class="fn">value</span>(storedValue)
        : value;
      <span class="fn">setStoredValue</span>(valueToStore);
      window.localStorage.<span class="fn">setItem</span>(key, JSON.<span class="fn">stringify</span>(valueToStore));
    } <span class="kw">catch</span> (error) {
      console.<span class="fn">warn</span>(<span class="str">`Error setting localStorage key "${key}":`</span>, error);
    }
  }, [key, storedValue]);

  <span class="kw">return</span> [storedValue, setValue];
}

<span class="cm">// Usage:</span>
<span class="kw">const</span> [theme, setTheme] = <span class="fn">useLocalStorage</span>(<span class="str">'theme'</span>, <span class="str">'dark'</span>);
<span class="kw">const</span> [cart, setCart] = <span class="fn">useLocalStorage</span>(<span class="str">'cart'</span>, []);</div>
        </div>
      </div>

      <!-- useFetch -->
      <div class="tab-content" data-tab="hooks">
        <h3>useFetch ‚Äî Data Fetching Made Simple</h3>
        <div class="code-block">
          <div class="code-header"><span class="code-lang">jsx</span><button class="copy-btn" onclick="copyCode(this)">üìã Copy</button></div>
          <div class="code-body"><span class="kw">function</span> <span class="fn">useFetch</span>(url) {
  <span class="kw">const</span> [data, setData] = <span class="hook">useState</span>(<span class="kw">null</span>);
  <span class="kw">const</span> [loading, setLoading] = <span class="hook">useState</span>(<span class="kw">true</span>);
  <span class="kw">const</span> [error, setError] = <span class="hook">useState</span>(<span class="kw">null</span>);

  <span class="hook">useEffect</span>(() => {
    <span class="kw">const</span> controller = <span class="kw">new</span> AbortController();

    <span class="kw">const</span> <span class="fn">fetchData</span> = <span class="kw">async</span> () => {
      <span class="fn">setLoading</span>(<span class="kw">true</span>);
      <span class="fn">setError</span>(<span class="kw">null</span>);
      <span class="kw">try</span> {
        <span class="kw">const</span> res = <span class="kw">await</span> <span class="fn">fetch</span>(url, { signal: controller.signal });
        <span class="kw">if</span> (!res.ok) <span class="kw">throw new</span> Error(<span class="str">`HTTP ${res.status}`</span>);
        <span class="kw">const</span> json = <span class="kw">await</span> res.<span class="fn">json</span>();
        <span class="fn">setData</span>(json);
      } <span class="kw">catch</span> (err) {
        <span class="kw">if</span> (err.name !== <span class="str">'AbortError'</span>) <span class="fn">setError</span>(err.message);
      } <span class="kw">finally</span> {
        <span class="fn">setLoading</span>(<span class="kw">false</span>);
      }
    };

    <span class="fn">fetchData</span>();
    <span class="kw">return</span> () => controller.<span class="fn">abort</span>(); <span class="cm">// Cleanup!</span>
  }, [url]);

  <span class="kw">return</span> { data, loading, error };
}

<span class="cm">// Usage:</span>
<span class="kw">function</span> <span class="fn">UserProfile</span>({ userId }) {
  <span class="kw">const</span> { data: user, loading, error } = <span class="fn">useFetch</span>(<span class="str">`/api/users/${userId}`</span>);

  <span class="kw">if</span> (loading) <span class="kw">return</span> <span class="tag">&lt;Spinner /&gt;</span>;
  <span class="kw">if</span> (error) <span class="kw">return</span> <span class="tag">&lt;Error</span> <span class="attr">message</span>={error} /&gt;;
  <span class="kw">return</span> <span class="tag">&lt;h1&gt;</span>{user.name}<span class="tag">&lt;/h1&gt;</span>;
}</div>
        </div>
        <div class="tip"><p><strong>Notice the AbortController!</strong> This prevents setting state on unmounted components. Always clean up async operations in hooks. This shows you write production-quality code!</p></div>
      </div>

      <!-- useDebounce -->
      <div class="tab-content" data-tab="hooks">
        <h3>useDebounce ‚Äî Delay Rapid Updates</h3>
        <div class="code-block">
          <div class="code-header"><span class="code-lang">jsx</span><button class="copy-btn" onclick="copyCode(this)">üìã Copy</button></div>
          <div class="code-body"><span class="kw">function</span> <span class="fn">useDebounce</span>(value, delay = <span class="num">300</span>) {
  <span class="kw">const</span> [debouncedValue, setDebouncedValue] = <span class="hook">useState</span>(value);

  <span class="hook">useEffect</span>(() => {
    <span class="kw">const</span> timer = <span class="fn">setTimeout</span>(() => {
      <span class="fn">setDebouncedValue</span>(value);
    }, delay);

    <span class="kw">return</span> () => <span class="fn">clearTimeout</span>(timer); <span class="cm">// Cleanup on every change</span>
  }, [value, delay]);

  <span class="kw">return</span> debouncedValue;
}

<span class="cm">// Usage: Search input that waits for user to stop typing</span>
<span class="kw">function</span> <span class="fn">Search</span>() {
  <span class="kw">const</span> [query, setQuery] = <span class="hook">useState</span>(<span class="str">''</span>);
  <span class="kw">const</span> debouncedQuery = <span class="fn">useDebounce</span>(query, <span class="num">500</span>);

  <span class="cm">// API call only fires when debouncedQuery changes (after 500ms pause)</span>
  <span class="kw">const</span> { data } = <span class="fn">useFetch</span>(
    debouncedQuery ? <span class="str">`/api/search?q=${debouncedQuery}`</span> : <span class="kw">null</span>
  );

  <span class="kw">return</span> <span class="tag">&lt;input</span> <span class="attr">value</span>={query} <span class="attr">onChange</span>={e => <span class="fn">setQuery</span>(e.target.value)} /&gt;;
}</div>
        </div>

        <div class="interactive">
          <div class="interactive-title">üéÆ Debounce Demo ‚Äî Type Fast!</div>
          <input type="text" id="debounce-input" oninput="debounceDemo()" placeholder="Type something fast..." style="padding:.5rem .8rem;background:var(--codebg);border:1px solid var(--border);border-radius:6px;color:var(--text);font-size:.9rem;width:100%;max-width:300px">
          <div style="margin-top:.5rem;font-size:.85rem">
            <div>Actual value: <span id="debounce-actual" style="color:var(--red)">""</span> (updates instantly)</div>
            <div>Debounced value: <span id="debounce-delayed" style="color:var(--green)">""</span> (updates after 500ms pause)</div>
            <div style="color:var(--text2);font-size:.75rem;margin-top:.3rem">API calls saved: <span id="debounce-saved" style="color:var(--amber)">0</span></div>
          </div>
        </div>
      </div>

      <!-- usePrevious -->
      <div class="tab-content" data-tab="hooks">
        <h3>usePrevious ‚Äî Track Previous Value</h3>
        <div class="code-block">
          <div class="code-header"><span class="code-lang">jsx</span><button class="copy-btn" onclick="copyCode(this)">üìã Copy</button></div>
          <div class="code-body"><span class="kw">import</span> { useRef, useEffect } <span class="kw">from</span> <span class="str">'react'</span>;

<span class="kw">function</span> <span class="fn">usePrevious</span>(value) {
  <span class="kw">const</span> ref = <span class="hook">useRef</span>();

  <span class="hook">useEffect</span>(() => {
    ref.current = value;
  }, [value]); <span class="cm">// Runs AFTER render, so ref holds the previous value</span>

  <span class="kw">return</span> ref.current;
}

<span class="cm">// Usage:</span>
<span class="kw">function</span> <span class="fn">Counter</span>() {
  <span class="kw">const</span> [count, setCount] = <span class="hook">useState</span>(<span class="num">0</span>);
  <span class="kw">const</span> prevCount = <span class="fn">usePrevious</span>(count);

  <span class="kw">return</span> (
    <span class="tag">&lt;p&gt;</span>
      Now: {count}, Before: {prevCount}
      {count > prevCount && <span class="str">' üìà Going up!'</span>}
      {count &lt; prevCount && <span class="str">' üìâ Going down!'</span>}
    <span class="tag">&lt;/p&gt;</span>
  );
}</div>
        </div>
      </div>

      <!-- useWindowSize -->
      <div class="tab-content" data-tab="hooks">
        <h3>useWindowSize ‚Äî Responsive Logic</h3>
        <div class="code-block">
          <div class="code-header"><span class="code-lang">jsx</span><button class="copy-btn" onclick="copyCode(this)">üìã Copy</button></div>
          <div class="code-body"><span class="kw">function</span> <span class="fn">useWindowSize</span>() {
  <span class="kw">const</span> [size, setSize] = <span class="hook">useState</span>({
    width: window.innerWidth,
    height: window.innerHeight,
  });

  <span class="hook">useEffect</span>(() => {
    <span class="kw">const</span> <span class="fn">handleResize</span> = () => {
      <span class="fn">setSize</span>({
        width: window.innerWidth,
        height: window.innerHeight,
      });
    };

    window.<span class="fn">addEventListener</span>(<span class="str">'resize'</span>, handleResize);
    <span class="kw">return</span> () => window.<span class="fn">removeEventListener</span>(<span class="str">'resize'</span>, handleResize);
  }, []);

  <span class="kw">return</span> size;
}

<span class="cm">// Usage:</span>
<span class="kw">function</span> <span class="fn">Layout</span>() {
  <span class="kw">const</span> { width } = <span class="fn">useWindowSize</span>();

  <span class="kw">return</span> width > <span class="num">768</span>
    ? <span class="tag">&lt;<span class="comp">DesktopNav</span> /&gt;</span>
    : <span class="tag">&lt;<span class="comp">MobileNav</span> /&gt;</span>;
}</div>
        </div>
        <div class="interactive">
          <div class="interactive-title">üéÆ Live Window Size</div>
          <div style="text-align:center;font-size:1.2rem;font-weight:700">
            <span id="win-w">0</span> √ó <span id="win-h">0</span>
            <div style="font-size:.8rem;color:var(--text2);margin-top:.3rem">Resize your browser to see it update!</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- COMPOSING HOOKS -->
  <div class="section-card amber">
    <h2>üß© Composing Hooks ‚Äî The Power Move</h2>
    <p>Custom hooks can call OTHER custom hooks! This creates powerful, reusable abstractions:</p>

    <div class="code-block">
      <div class="code-header"><span class="code-lang">jsx</span><span>Composed Hook: useSearchAPI</span></div>
      <div class="code-body"><span class="kw">function</span> <span class="fn">useSearchAPI</span>(endpoint) {
  <span class="kw">const</span> [query, setQuery] = <span class="hook">useState</span>(<span class="str">''</span>);
  <span class="kw">const</span> debouncedQuery = <span class="fn">useDebounce</span>(query, <span class="num">300</span>);   <span class="cm">// ‚Üê custom hook!</span>
  <span class="kw">const</span> { data, loading, error } = <span class="fn">useFetch</span>(         <span class="cm">// ‚Üê custom hook!</span>
    debouncedQuery ? <span class="str">`${endpoint}?q=${debouncedQuery}`</span> : <span class="kw">null</span>
  );
  <span class="kw">const</span> prevResults = <span class="fn">usePrevious</span>(data);           <span class="cm">// ‚Üê custom hook!</span>

  <span class="kw">return</span> {
    query, setQuery,
    results: data,
    prevResults,
    loading,
    error,
    hasChanged: data !== prevResults,
  };
}

<span class="cm">// Usage ‚Äî so clean!</span>
<span class="kw">const</span> { query, setQuery, results, loading } = <span class="fn">useSearchAPI</span>(<span class="str">'/api/search'</span>);</div>
    </div>
  </div>

  <!-- QUIZ -->
  <div class="section-card amber">
    <h2>üß† Quiz: Custom Hooks</h2>

    <div class="quiz" data-quiz="hook-1">
      <div class="quiz-question">Q1: What MUST a custom hook name start with?</div>
      <div class="quiz-options">
        <button class="quiz-opt" onclick="checkQuiz('hook-1',this,false)">A) "custom"</button>
        <button class="quiz-opt" onclick="checkQuiz('hook-1',this,true)">B) "use"</button>
        <button class="quiz-opt" onclick="checkQuiz('hook-1',this,false)">C) "hook"</button>
        <button class="quiz-opt" onclick="checkQuiz('hook-1',this,false)">D) It doesn't matter</button>
      </div>
      <div class="quiz-explanation" id="hook-1-exp"></div>
    </div>

    <div class="quiz" data-quiz="hook-2">
      <div class="quiz-question">Q2: Do two components using the same custom hook share state?</div>
      <div class="quiz-options">
        <button class="quiz-opt" onclick="checkQuiz('hook-2',this,false)">A) Yes, always</button>
        <button class="quiz-opt" onclick="checkQuiz('hook-2',this,true)">B) No ‚Äî each component gets its own independent state</button>
        <button class="quiz-opt" onclick="checkQuiz('hook-2',this,false)">C) Only if they're siblings</button>
        <button class="quiz-opt" onclick="checkQuiz('hook-2',this,false)">D) Only with useRef</button>
      </div>
      <div class="quiz-explanation" id="hook-2-exp"></div>
    </div>

    <div class="quiz" data-quiz="hook-3">
      <div class="quiz-question">Q3: Why does useFetch use AbortController?</div>
      <div class="quiz-options">
        <button class="quiz-opt" onclick="checkQuiz('hook-3',this,false)">A) To make the request faster</button>
        <button class="quiz-opt" onclick="checkQuiz('hook-3',this,true)">B) To cancel in-flight requests when the component unmounts or URL changes</button>
        <button class="quiz-opt" onclick="checkQuiz('hook-3',this,false)">C) To handle errors</button>
        <button class="quiz-opt" onclick="checkQuiz('hook-3',this,false)">D) It's required by React</button>
      </div>
      <div class="quiz-explanation" id="hook-3-exp"></div>
    </div>

    <div class="quiz" data-quiz="hook-4">
      <div class="quiz-question">Q4: Can a custom hook return JSX?</div>
      <div class="quiz-options">
        <button class="quiz-opt" onclick="checkQuiz('hook-4',this,false)">A) Yes, that's the main purpose</button>
        <button class="quiz-opt" onclick="checkQuiz('hook-4',this,true)">B) Technically yes, but it's an anti-pattern. Hooks should return data/functions, not UI</button>
        <button class="quiz-opt" onclick="checkQuiz('hook-4',this,false)">C) No, it will throw an error</button>
        <button class="quiz-opt" onclick="checkQuiz('hook-4',this,false)">D) Only in class components</button>
      </div>
      <div class="quiz-explanation" id="hook-4-exp"></div>
    </div>
  </div>

  <!-- EXERCISE -->
  <div class="section-card amber">
    <h2>üí™ Exercise: Build useClickOutside</h2>
    <div class="exercise" data-ex="hook-ex1">
      <div class="exercise-prompt">Complete the useClickOutside hook that calls a handler when the user clicks outside a ref element (used for closing dropdowns/modals):</div>
      <textarea id="hook-ex1-input" spellcheck="false">function useClickOutside(ref, handler) {
  useEffect(() => {
    const listener = (event) => {
      // Check if click is outside the ref element
      if (!ref.current || ref.______(event.target)) {
        return; // Click was inside, do nothing
      }
      handler(event); // Click was outside!
    };

    document.addEventListener('mousedown', listener);
    return () => document.______('mousedown', listener);
  }, [ref, handler]);
}</textarea>
      <div class="btn-group">
        <button class="btn btn-amber" onclick="checkExercise('hook-ex1')">‚úÖ Check</button>
        <button class="btn btn-outline" onclick="showHint('hook-ex1')">üí° Hint</button>
        <button class="btn btn-outline" onclick="showSolution('hook-ex1')">üëÅÔ∏è Solution</button>
      </div>
      <div class="exercise-hint" id="hook-ex1-hint">First blank: "contains" (checks if the element contains the click target). Second blank: "removeEventListener" (cleanup!).</div>
      <div class="exercise-result" id="hook-ex1-result"></div>
    </div>
  </div>

  <!-- EXERCISE 2 -->
  <div class="section-card amber">
    <h2>üí™ Exercise: Build useCounter</h2>
    <div class="exercise" data-ex="hook-ex2">
      <div class="exercise-prompt">Build a useCounter hook that returns count, increment, decrement, and reset functions:</div>
      <textarea id="hook-ex2-input" spellcheck="false">function useCounter(initialValue = 0) {
  const [count, setCount] = ______(initialValue);

  const increment = useCallback(() => {
    setCount(c => c + 1);
  }, []);

  const decrement = ______(() => {
    setCount(c => c - 1);
  }, []);

  const reset = useCallback(() => {
    ______(initialValue);
  }, [initialValue]);

  return { count, increment, ______, reset };
}</textarea>
      <div class="btn-group">
        <button class="btn btn-amber" onclick="checkExercise('hook-ex2')">‚úÖ Check</button>
        <button class="btn btn-outline" onclick="showHint('hook-ex2')">üí° Hint</button>
        <button class="btn btn-outline" onclick="showSolution('hook-ex2')">üëÅÔ∏è Solution</button>
      </div>
      <div class="exercise-hint" id="hook-ex2-hint">Blanks: useState, useCallback, setCount, decrement</div>
      <div class="exercise-result" id="hook-ex2-result"></div>
    </div>
  </div>

  <!-- PITFALLS -->
  <div class="section-card amber">
    <h2>üö® Common Pitfalls</h2>

    <div class="pitfall">
      <div class="pitfall-title">Pitfall #1: Not starting with "use"</div>
      <p>If you name your hook <code class="code-inline">getWindowSize()</code> instead of <code class="code-inline">useWindowSize()</code>, React's linter won't enforce the Rules of Hooks, leading to subtle bugs.</p>
    </div>

    <div class="pitfall">
      <div class="pitfall-title">Pitfall #2: Thinking hooks share state between components</div>
      <p>Each component calling <code class="code-inline">useToggle()</code> gets its OWN independent boolean. If you need shared state, combine with Context!</p>
    </div>

    <div class="pitfall">
      <div class="pitfall-title">Pitfall #3: Calling hooks conditionally</div>
      <div class="code-block"><div class="code-header"><span class="badge badge-red">‚ùå WILL CRASH</span></div>
<div class="code-body"><span class="kw">function</span> <span class="fn">useData</span>(shouldFetch) {
  <span class="kw">if</span> (shouldFetch) {
    <span class="kw">const</span> [data, setData] = <span class="hook">useState</span>(<span class="kw">null</span>); <span class="cm">// ‚ùå Conditional hook!</span>
  }
}</div></div>
      <div class="fix"><div class="fix-title">‚úÖ Call the hook always, use the condition inside</div>
<div class="code-block"><div class="code-header"><span class="badge badge-emerald">‚úÖ CORRECT</span></div>
<div class="code-body"><span class="kw">function</span> <span class="fn">useData</span>(shouldFetch) {
  <span class="kw">const</span> [data, setData] = <span class="hook">useState</span>(<span class="kw">null</span>); <span class="cm">// ‚úÖ Always called</span>
  <span class="hook">useEffect</span>(() => {
    <span class="kw">if</span> (!shouldFetch) <span class="kw">return</span>; <span class="cm">// Condition inside effect</span>
    <span class="fn">fetchData</span>().<span class="fn">then</span>(setData);
  }, [shouldFetch]);
}</div></div>
      </div>
    </div>

    <div class="pitfall">
      <div class="pitfall-title">Pitfall #4: Over-abstracting</div>
      <p>Don't create a custom hook for one-time logic used in a single component. Extract only when you see duplicated patterns across 2+ components.</p>
    </div>

    <div class="pitfall">
      <div class="pitfall-title">Pitfall #5: Forgetting cleanup in useEffect</div>
      <p>Event listeners, timers, subscriptions, and AbortControllers all need cleanup. Memory leaks are the #1 source of bugs in custom hooks.</p>
    </div>
  </div>

  <!-- FINAL CHEAT SHEET -->
  <div class="section-card amber">
    <h2>üìã Custom Hooks Cheat Sheet</h2>
    <table style="width:100%;border-collapse:collapse;font-size:.85rem">
      <tr style="border-bottom:2px solid var(--border)">
        <th style="text-align:left;padding:.5rem;color:var(--amber)">Hook</th>
        <th style="text-align:left;padding:.5rem;color:var(--amber)">Purpose</th>
        <th style="text-align:left;padding:.5rem;color:var(--amber)">Returns</th>
      </tr>
      <tr style="border-bottom:1px solid var(--border)"><td style="padding:.5rem"><code class="code-inline">useToggle</code></td><td style="padding:.5rem">Boolean on/off</td><td style="padding:.5rem">{ value, toggle }</td></tr>
      <tr style="border-bottom:1px solid var(--border)"><td style="padding:.5rem"><code class="code-inline">useLocalStorage</code></td><td style="padding:.5rem">Persistent state</td><td style="padding:.5rem">[value, setValue]</td></tr>
      <tr style="border-bottom:1px solid var(--border)"><td style="padding:.5rem"><code class="code-inline">useFetch</code></td><td style="padding:.5rem">API data fetching</td><td style="padding:.5rem">{ data, loading, error }</td></tr>
      <tr style="border-bottom:1px solid var(--border)"><td style="padding:.5rem"><code class="code-inline">useDebounce</code></td><td style="padding:.5rem">Delay rapid updates</td><td style="padding:.5rem">debouncedValue</td></tr>
      <tr style="border-bottom:1px solid var(--border)"><td style="padding:.5rem"><code class="code-inline">usePrevious</code></td><td style="padding:.5rem">Track previous value</td><td style="padding:.5rem">previousValue</td></tr>
      <tr><td style="padding:.5rem"><code class="code-inline">useWindowSize</code></td><td style="padding:.5rem">Responsive logic</td><td style="padding:.5rem">{ width, height }</td></tr>
    </table>
  </div>
</section>

</main>

<!-- Score Popup -->
<div class="overlay" id="overlay" onclick="closePopup()"></div>
<div class="score-popup" id="score-popup">
  <div class="big-emoji" id="popup-emoji">üéâ</div>
  <div class="score-text" id="popup-text">+10 XP</div>
  <p style="color:var(--text2);margin-top:.5rem" id="popup-sub"></p>
  <button class="btn btn-amber" onclick="closePopup()" style="margin-top:1rem">Continue</button>
</div>

<script>
// ============================
// APP STATE
// ============================
const state = {
  xp: 0,
  score: 0,
  totalQuestions: 16,
  streak: 0,
  currentChapter: 0,
  answeredQuizzes: new Set(),
  completedExercises: new Set(),
  chapterProgress: [0, 0, 0, 0],
};

// ============================
// NAVIGATION
// ============================
function switchChapter(idx) {
  state.currentChapter = idx;
  document.querySelectorAll('.chapter').forEach((ch, i) => {
    ch.classList.toggle('active', i === idx);
  });
  document.querySelectorAll('.nav-btn').forEach((btn, i) => {
    btn.classList.toggle('active', i === idx);
  });
  window.scrollTo({ top: 0, behavior: 'smooth' });
}

// ============================
// TABS
// ============================
function switchTab(btn, group) {
  const container = btn.closest('.tab-container');
  const buttons = container.querySelectorAll('.tab-btn');
  const contents = container.querySelectorAll('.tab-content');
  const idx = Array.from(buttons).indexOf(btn);
  buttons.forEach(b => b.classList.remove('active'));
  contents.forEach(c => c.classList.remove('active'));
  btn.classList.add('active');
  if (contents[idx]) contents[idx].classList.add('active');
}

// ============================
// QUIZ ENGINE
// ============================
const quizExplanations = {
  'ctx-1': { correct: 'Context API eliminates prop drilling ‚Äî passing data through intermediate components that don\'t need it. It lets any component access shared data directly.', wrong: 'Context doesn\'t replace Redux (it lacks middleware, dev tools, etc.), doesn\'t improve performance, and doesn\'t handle async.' },
  'ctx-2': { correct: 'The default value in createContext() is only used when useContext is called outside of any matching Provider. It\'s a fallback, not an initial value!', wrong: 'The default is NOT used when a Provider exists. Even passing undefined from a Provider is different from having no Provider at all.' },
  'ctx-3': { correct: 'When context value changes, ALL components consuming that context re-render ‚Äî even if wrapped in React.memo! Memo only checks props, not context.', wrong: 'Context re-renders ALL consumers, not just the closest one. React.memo cannot prevent context-triggered re-renders.' },
  'ctx-4': { correct: 'useContext() is the modern, recommended way to consume context in function components. It\'s cleaner than the Consumer render prop pattern.', wrong: 'Consumer render props still work but are verbose. this.context is for class components. connect() is from Redux, not React Context.' },
  'red-1': { correct: 'A reducer MUST return the new state. React uses this return value to update the component. If you return undefined, state becomes undefined!', wrong: 'Reducers are synchronous, pure functions. They take current state + action and return new state. Nothing else.' },
  'red-2': { correct: 'Splitting contexts means components only subscribe to what they need. A component using only dispatch won\'t re-render when state changes!', wrong: 'It\'s not required by React ‚Äî it\'s an optimization pattern. dispatch from useReducer is already stable (doesn\'t change between renders).' },
  'red-3': { correct: 'Reducers must be pure ‚Äî same inputs always produce same outputs, with no side effects. Do async work outside the reducer, then dispatch the result.', wrong: 'Reducers cannot contain async operations, API calls, random numbers, Date.now(), or any side effects.' },
  'red-4': { correct: '{ type, payload } is the conventional action shape: "type" describes what happened, "payload" carries the data. This convention comes from Redux/Flux.', wrong: 'While you can use any shape, { type, payload } is the widely adopted convention in the React ecosystem.' },
  'memo-1': { correct: 'useMemo returns the RESULT of calling the function ‚Äî the computed value. useCallback returns the function itself.', wrong: 'useMemo caches the return value of the computation. useCallback caches the function reference itself.' },
  'memo-2': { correct: 'useCallback gives a stable function reference, but without React.memo the child re-renders anyway (because its parent re-rendered). They work as a pair!', wrong: 'React.memo makes the child compare old/new props. useCallback ensures the function prop has a stable reference. You need both.' },
  'memo-3': { correct: 'For trivial computations, useMemo adds overhead (storing the value, comparing deps) that exceeds the computation cost. Only memoize expensive operations!', wrong: 'Don\'t optimize prematurely. The cost of memoization (comparison + memory) can exceed simple calculations.' },
  'memo-4': { correct: 'useCallback returns the same function instance between renders, only creating a new one when dependencies change. It\'s sugar for useMemo(() => fn, deps).', wrong: 'useCallback memoizes the function reference, not its return value. It helps prevent unnecessary re-renders of memoized children.' },
  'hook-1': { correct: 'Custom hooks MUST start with "use" (lowercase). This tells React\'s linter to enforce the Rules of Hooks ‚Äî no conditional calls, etc.', wrong: 'The "use" prefix is mandatory. Without it, React cannot enforce hook rules, leading to potential bugs.' },
  'hook-2': { correct: 'Custom hooks share LOGIC, not STATE. Each component calling the hook gets completely independent state instances, just like each call to useState is independent.', wrong: 'If you need shared state, combine hooks with Context. The hook itself just encapsulates reusable logic patterns.' },
  'hook-3': { correct: 'AbortController cancels in-flight fetch requests when the component unmounts or the URL changes. Without it, you\'d set state on an unmounted component (memory leak + warning).', wrong: 'AbortController is about cleanup ‚Äî canceling pending requests. It\'s essential for preventing memory leaks and race conditions.' },
  'hook-4': { correct: 'Technically hooks CAN return JSX, but it\'s an anti-pattern. If you need to return UI, make a component. Hooks should return data and functions for separation of concerns.', wrong: 'Hooks returning JSX blurs the line between hooks and components. Keep hooks for logic, components for UI.' },
};

function checkQuiz(id, btn, isCorrect) {
  if (state.answeredQuizzes.has(id)) return;
  state.answeredQuizzes.add(id);

  const quiz = btn.closest('.quiz');
  const options = quiz.querySelectorAll('.quiz-opt');
  options.forEach(opt => {
    opt.classList.add('disabled');
    opt.disabled = true;
  });

  const exp = document.getElementById(id + '-exp');
  if (isCorrect) {
    btn.classList.add('correct');
    state.score++;
    state.streak++;
    addXP(10);
    exp.className = 'quiz-explanation show correct';
    exp.innerHTML = '‚úÖ Correct! ' + quizExplanations[id].correct;
    // Mark correct answer on other options
    options.forEach(opt => {
      if (opt !== btn && opt.onclick.toString().includes('true')) {
        // this was the other correct answer indicator
      }
    });
  } else {
    btn.classList.add('wrong');
    state.streak = 0;
    exp.className = 'quiz-explanation show wrong';
    exp.innerHTML = '‚ùå Not quite. ' + quizExplanations[id].wrong;
    // Highlight correct answer
    options.forEach(opt => {
      const onclickStr = opt.getAttribute('onclick');
      if (onclickStr && onclickStr.includes('true')) {
        opt.classList.add('correct');
      }
    });
  }
  updateUI();
}

// ============================
// EXERCISE ENGINE
// ============================
const exerciseCheckers = {
  'ctx-ex1': {
    check: (input) => {
      const lower = input.toLowerCase().replace(/\s+/g, '');
      return lower.includes('createcontext') && lower.includes('.provider') && lower.includes('usecontext');
    },
    solution: `const LanguageContext = createContext('en');

function LanguageProvider({ children }) {
  const [lang, setLang] = useState('en');

  return (
    <LanguageContext.Provider value={{ lang, setLang }}>
      {children}
    </LanguageContext.Provider>
  );
}

function useLanguage() {
  return useContext(LanguageContext);
}`
  },
  'red-ex1': {
    check: (input) => {
      const lower = input.toLowerCase().replace(/\s+/g, '');
      return (lower.includes('...state') || lower.includes('[...state')) && lower.includes('filter') && lower.includes('action.payload');
    },
    solution: `function cartReducer(state, action) {
  switch (action.type) {
    case 'ADD_ITEM':
      return [...state, action.payload];
    case 'REMOVE_ITEM':
      return state.filter(item => item.id !== action.payload);
    default:
      return state;
  }
}`
  },
  'memo-ex1': {
    check: (input) => {
      const lower = input.replace(/\s+/g, '');
      return lower.includes('useMemo') && lower.includes('useCallback');
    },
    solution: `function SearchResults({ items, query }) {
  const [selected, setSelected] = useState(null);

  const filtered = useMemo(() =>
    items.filter(item =>
      item.name.toLowerCase().includes(query.toLowerCase())
    ).sort((a, b) => a.name.localeCompare(b.name)),
    [items, query]
  );

  const handleSelect = useCallback((id) => {
    setSelected(id);
  }, []);

  return (
    <div>
      {filtered.map(item => (
        <MemoizedItem
          key={item.id}
          item={item}
          onSelect={handleSelect}
          isSelected={item.id === selected}
        />
      ))}
    </div>
  );
}`
  },
  'hook-ex1': {
    check: (input) => {
      const lower = input.toLowerCase().replace(/\s+/g, '');
      return lower.includes('contains') && lower.includes('removeeventlistener');
    },
    solution: `function useClickOutside(ref, handler) {
  useEffect(() => {
    const listener = (event) => {
      if (!ref.current || ref.current.contains(event.target)) {
        return;
      }
      handler(event);
    };

    document.addEventListener('mousedown', listener);
    return () => document.removeEventListener('mousedown', listener);
  }, [ref, handler]);
}`
  },
  'hook-ex2': {
    check: (input) => {
      const lower = input.replace(/\s+/g, '');
      return lower.includes('useState') && lower.includes('useCallback') && lower.includes('setCount') && lower.includes('decrement');
    },
    solution: `function useCounter(initialValue = 0) {
  const [count, setCount] = useState(initialValue);

  const increment = useCallback(() => {
    setCount(c => c + 1);
  }, []);

  const decrement = useCallback(() => {
    setCount(c => c - 1);
  }, []);

  const reset = useCallback(() => {
    setCount(initialValue);
  }, [initialValue]);

  return { count, increment, decrement, reset };
}`
  }
};

function checkExercise(id) {
  const input = document.getElementById(id + '-input').value;
  const result = document.getElementById(id + '-result');
  const checker = exerciseCheckers[id];

  if (checker.check(input)) {
    result.className = 'exercise-result pass';
    result.innerHTML = 'üéâ Excellent! Your solution looks correct!';
    if (!state.completedExercises.has(id)) {
      state.completedExercises.add(id);
      addXP(20);
      state.streak++;
    }
  } else {
    result.className = 'exercise-result fail';
    result.innerHTML = '‚ùå Not quite right. Check the key concepts and try again, or click "Show Solution" to learn.';
    state.streak = 0;
  }
  updateUI();
}

function showHint(id) {
  const hint = document.getElementById(id + '-hint');
  hint.classList.toggle('show');
}

function showSolution(id) {
  const textarea = document.getElementById(id + '-input');
  textarea.value = exerciseCheckers[id].solution;
  textarea.style.borderColor = 'var(--amber)';
}

// ============================
// XP & SCORING
// ============================
function addXP(amount) {
  state.xp += amount;
  showXPFloat(amount);
  updateUI();
}

function showXPFloat(amount) {
  const float = document.createElement('div');
  float.className = 'xp-float';
  float.textContent = `+${amount} XP`;
  float.style.left = Math.random() * 60 + 20 + '%';
  float.style.top = '50%';
  document.body.appendChild(float);
  setTimeout(() => float.remove(), 1500);
}

function updateUI() {
  document.getElementById('xp-display').textContent = state.xp;
  document.getElementById('score-display').innerHTML = `${state.score}<span style="color:var(--text2)">/${state.totalQuestions}</span>`;
  document.getElementById('streak-display').textContent = state.streak;

  const progress = ((state.answeredQuizzes.size + state.completedExercises.size) / (state.totalQuestions + 5)) * 100;
  document.getElementById('progress-fill').style.width = Math.min(progress, 100) + '%';

  // Update nav checks
  const chapterQuizCounts = [4, 4, 4, 4];
  let answered = 0;
  ['ctx-1','ctx-2','ctx-3','ctx-4'].forEach(q => { if (state.answeredQuizzes.has(q)) answered++ });
  if (answered === 4) document.querySelector('.nav-btn[data-ch="0"]').innerHTML = 'üì¶ Context API <span class="check">‚úÖ</span>';
  answered = 0;
  ['red-1','red-2','red-3','red-4'].forEach(q => { if (state.answeredQuizzes.has(q)) answered++ });
  if (answered === 4) document.querySelector('.nav-btn[data-ch="1"]').innerHTML = 'üîÑ useReducer <span class="check">‚úÖ</span>';
  answered = 0;
  ['memo-1','memo-2','memo-3','memo-4'].forEach(q => { if (state.answeredQuizzes.has(q)) answered++ });
  if (answered === 4) document.querySelector('.nav-btn[data-ch="2"]').innerHTML = '‚ö° Memo/Callback <span class="check">‚úÖ</span>';
  answered = 0;
  ['hook-1','hook-2','hook-3','hook-4'].forEach(q => { if (state.answeredQuizzes.has(q)) answered++ });
  if (answered === 4) document.querySelector('.nav-btn[data-ch="3"]').innerHTML = 'ü™ù Custom Hooks <span class="check">‚úÖ</span>';
}

function closePopup() {
  document.getElementById('score-popup').style.display = 'none';
  document.getElementById('overlay').style.display = 'none';
}

// ============================
// COPY CODE
// ============================
function copyCode(btn) {
  const codeBody = btn.closest('.code-block').querySelector('.code-body');
  const text = codeBody.innerText;
  navigator.clipboard.writeText(text).then(() => {
    const orig = btn.textContent;
    btn.textContent = '‚úÖ Copied!';
    setTimeout(() => btn.textContent = orig, 1500);
  });
}

// ============================
// COLLAPSIBLE
// ============================
document.querySelectorAll('.collapsible-toggle').forEach(toggle => {
  toggle.addEventListener('click', () => {
    toggle.classList.toggle('open');
    toggle.nextElementSibling.classList.toggle('open');
  });
});

// ============================
// INTERACTIVE DEMOS
// ============================

// Context Simulator
let ctxVal = 'dark';
let ctxReads = 0;
function toggleCtxVal() {
  ctxVal = ctxVal === 'dark' ? 'light' : 'dark';
  document.getElementById('ctx-val').textContent = ctxVal;
  ctxReads++;
  document.getElementById('ctx-reads').textContent = 'reads: ' + ctxReads;

  // Animate provider and consumer
  const sim = document.getElementById('context-sim');
  const components = sim.querySelectorAll('.render-component');
  components[0].classList.add('rerendering');
  components[3].classList.add('rerendering');
  setTimeout(() => {
    components[0].classList.remove('rerendering');
    components[3].classList.remove('rerendering');
  }, 600);

  document.getElementById('ctx-msg').innerHTML = `üîÑ Provider & ThemeButton re-rendered! Header & App did NOT (they don't consume context).`;
}

function simContext(comp) {
  const messages = {
    provider: 'üü£ This is the Provider ‚Äî it wraps the tree and provides the value to all consumers below',
    app: 'üì¶ App doesn\'t use useContext, so it doesn\'t re-render when context changes',
    header: 'üì¶ Header doesn\'t use useContext either ‚Äî completely unaffected',
    button: 'üü¢ ThemeButton calls useContext(ThemeContext), so it re-renders when the value changes!'
  };
  document.getElementById('ctx-msg').textContent = messages[comp];
}

// Reducer Demo
let reducerCount = 0;
function demoReducer(type) {
  let log = '';
  switch (type) {
    case 'INCREMENT': reducerCount++; log = `dispatch({ type: 'INCREMENT' }) ‚Üí count: ${reducerCount}`; break;
    case 'DECREMENT': reducerCount--; log = `dispatch({ type: 'DECREMENT' }) ‚Üí count: ${reducerCount}`; break;
    case 'RESET': reducerCount = 0; log = `dispatch({ type: 'RESET' }) ‚Üí count: 0`; break;
    case 'SET': reducerCount = 100; log = `dispatch({ type: 'SET', payload: 100 }) ‚Üí count: 100`; break;
  }
  document.getElementById('reducer-count').textContent = reducerCount;
  document.getElementById('reducer-log').textContent = log;
  document.getElementById('reducer-count').style.transform = 'scale(1.3)';
  setTimeout(() => document.getElementById('reducer-count').style.transform = 'scale(1)', 200);
}

// State Machine Demo
let smTodos = [];
function smDispatch(type, payload) {
  const actionEl = document.getElementById('sm-action');
  const reducerEl = document.getElementById('sm-reducer');
  const stateEl = document.getElementById('sm-state');

  document.getElementById('sm-action-text').textContent = `{ type: "${type}" }`;
  actionEl.classList.add('rerendering');

  setTimeout(() => {
    actionEl.classList.remove('rerendering');
    reducerEl.classList.add('rerendering');
  }, 300);

  setTimeout(() => {
    reducerEl.classList.remove('rerendering');
    switch (type) {
      case 'ADD': smTodos.push({ text: payload, done: false }); break;
      case 'TOGGLE': if (smTodos[payload]) smTodos[payload].done = !smTodos[payload].done; break;
      case 'DELETE': smTodos.splice(payload, 1); break;
    }
    const display = smTodos.length === 0 ? '{ todos: [] }' :
      '{ todos: [' + smTodos.map(t => `\n  "${t.text}"${t.done ? ' ‚úÖ' : ''}`).join(',') + '\n] }';
    document.getElementById('sm-state-text').textContent = display;
    stateEl.classList.add('rerendering');
    setTimeout(() => stateEl.classList.remove('rerendering'), 600);
  }, 600);
}

// Reference Equality Tester
function refTest(expr) {
  const results = {
    '42 === 42': { result: true, explain: '‚úÖ true ‚Äî Primitives compare by VALUE' },
    '{} === {}': { result: false, explain: '‚ùå false ‚Äî Objects compare by REFERENCE (two different objects)' },
    '[] === []': { result: false, explain: '‚ùå false ‚Äî Arrays compare by REFERENCE (two different arrays)' },
    'fn === fn': { result: true, explain: '‚úÖ true ‚Äî Strings are primitives, compared by VALUE' },
  };
  const r = results[expr];
  const el = document.getElementById('ref-result');
  el.innerHTML = `<div style="color:${r.result ? 'var(--green)' : 'var(--red)'}">${expr} ‚Üí <strong>${r.result}</strong></div><div style="font-size:.85rem;color:var(--text2)">${r.explain}</div>`;
}

// useMemo Demo
let memoRenders = 0;
let memoComputes = 0;
const memoItems = ['React', 'Redux', 'Next.js', 'TypeScript', 'JavaScript', 'Node.js', 'GraphQL', 'Webpack', 'Vite', 'Tailwind'];

function memoDemo() {
  const query = document.getElementById('memo-search').value.toLowerCase();
  memoComputes++;
  document.getElementById('memo-computes').textContent = memoComputes;
  memoRenders++;
  document.getElementById('memo-renders').textContent = memoRenders;
  const filtered = memoItems.filter(i => i.toLowerCase().includes(query));
  document.getElementById('memo-results').innerHTML = filtered.length ?
    filtered.map(i => `<span class="badge badge-emerald" style="margin:.2rem">${i}</span>`).join('') :
    '<span style="color:var(--red)">No results</span>';
}

function memoUnrelated() {
  memoRenders++;
  document.getElementById('memo-renders').textContent = memoRenders;
  // Note: memoComputes does NOT increase ‚Äî that's the point of useMemo!
}

// Re-render Visualization
const vizCounts = { 1: { parent: 0, child1: 0, child2: 0, child3: 0 }, 2: { parent: 0, child1: 0, child2: 0, child3: 0 } };

function vizRender(set, mode) {
  const prefix = `viz${set}-`;
  vizCounts[set].parent++;
  const parent = document.getElementById(prefix + 'parent');
  parent.querySelector('span').textContent = vizCounts[set].parent;
  parent.classList.add('rerendering');
  setTimeout(() => parent.classList.remove('rerendering'), 600);

  if (mode === 'all') {
    ['child1', 'child2', 'child3'].forEach(c => {
      vizCounts[set][c]++;
      const el = document.getElementById(prefix + c);
      el.querySelector('span').textContent = vizCounts[set][c];
      el.classList.add('rerendering');
      setTimeout(() => el.classList.remove('rerendering'), 600);
    });
  } else {
    // Only footer re-renders (not memoized)
    vizCounts[set].child3++;
    const footer = document.getElementById(prefix + 'child3');
    footer.querySelector('span').textContent = vizCounts[set].child3;
    footer.classList.add('rerendering');
    setTimeout(() => footer.classList.remove('rerendering'), 600);

    // Memoized ones show stable
    ['child1', 'child2'].forEach(c => {
      const el = document.getElementById(prefix + c);
      el.classList.add('stable');
      setTimeout(() => el.classList.remove('stable'), 600);
    });
  }
}

// Toggle Demo
let toggleVal = false;
function demoToggle() {
  toggleVal = !toggleVal;
  document.getElementById('toggle-val').textContent = toggleVal ? 'ON üü¢' : 'OFF üî¥';
}

// Debounce Demo
let debounceTimer = null;
let debounceSaved = 0;
let debounceKeystrokes = 0;
function debounceDemo() {
  const val = document.getElementById('debounce-input').value;
  debounceKeystrokes++;
  document.getElementById('debounce-actual').textContent = `"${val}"`;

  if (debounceTimer) {
    clearTimeout(debounceTimer);
    debounceSaved++;
    document.getElementById('debounce-saved').textContent = debounceSaved;
  }

  debounceTimer = setTimeout(() => {
    document.getElementById('debounce-delayed').textContent = `"${val}"`;
    debounceTimer = null;
  }, 500);
}

// Window Size
function updateWinSize() {
  document.getElementById('win-w').textContent = window.innerWidth;
  document.getElementById('win-h').textContent = window.innerHeight;
}
window.addEventListener('resize', updateWinSize);
updateWinSize();

// ============================
// INITIALIZATION
// ============================
memoDemo(); // Initialize memo demo with empty query

// Initial memo results
document.getElementById('memo-results').innerHTML = memoItems.map(i => `<span class="badge badge-emerald" style="margin:.2rem">${i}</span>`).join('');
memoComputes = 0;
memoRenders = 0;
document.getElementById('memo-computes').textContent = '0';
document.getElementById('memo-renders').textContent = '0';

console.log('üöÄ React Advanced Patterns Learning App loaded!');
console.log('üìù Complete all quizzes and exercises to master these patterns.');
</script>
</body>
</html>