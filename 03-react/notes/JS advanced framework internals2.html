<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Framework Internals Mastery</title>
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg: #0f1117;
  --surface: #1a1d27;
  --surface2: #242836;
  --surface3: #2e3348;
  --accent: #6c5ce7;
  --accent2: #a29bfe;
  --green: #00b894;
  --red: #e17055;
  --orange: #fdcb6e;
  --blue: #74b9ff;
  --cyan: #81ecec;
  --pink: #fd79a8;
  --text: #e4e6ef;
  --text2: #a0a4b8;
  --radius: 12px;
}

body {
  font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
  background: var(--bg);
  color: var(--text);
  line-height: 1.7;
  overflow-x: hidden;
}

/* Scrollbar */
::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: var(--bg); }
::-webkit-scrollbar-thumb { background: var(--surface3); border-radius: 3px; }

/* Layout */
.app { display: flex; min-height: 100vh; }

/* Sidebar */
.sidebar {
  width: 280px;
  background: var(--surface);
  border-right: 1px solid var(--surface3);
  position: fixed;
  top: 0;
  left: 0;
  height: 100vh;
  overflow-y: auto;
  z-index: 100;
  transition: transform 0.3s;
}

.sidebar-header {
  padding: 24px 20px;
  border-bottom: 1px solid var(--surface3);
  background: linear-gradient(135deg, var(--accent), #4834d4);
}

.sidebar-header h1 {
  font-size: 18px;
  font-weight: 700;
  color: #fff;
}

.sidebar-header p {
  font-size: 12px;
  color: rgba(255,255,255,0.7);
  margin-top: 4px;
}

.progress-bar {
  margin-top: 12px;
  background: rgba(255,255,255,0.2);
  border-radius: 10px;
  height: 8px;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  background: var(--green);
  border-radius: 10px;
  transition: width 0.5s ease;
  width: 0%;
}

.progress-text {
  font-size: 11px;
  color: rgba(255,255,255,0.8);
  margin-top: 6px;
}

.nav-section {
  padding: 16px 0;
}

.nav-section-title {
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 1.5px;
  color: var(--text2);
  padding: 0 20px;
  margin-bottom: 8px;
  font-weight: 600;
}

.nav-item {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 10px 20px;
  cursor: pointer;
  transition: all 0.2s;
  font-size: 14px;
  color: var(--text2);
  border-left: 3px solid transparent;
}

.nav-item:hover {
  background: var(--surface2);
  color: var(--text);
}

.nav-item.active {
  background: rgba(108, 92, 231, 0.1);
  color: var(--accent2);
  border-left-color: var(--accent);
}

.nav-item .icon {
  font-size: 18px;
  width: 24px;
  text-align: center;
}

.nav-item .check {
  margin-left: auto;
  font-size: 14px;
  color: var(--green);
  display: none;
}

.nav-item.completed .check { display: block; }

/* Main */
.main {
  margin-left: 280px;
  flex: 1;
  min-height: 100vh;
}

.content {
  max-width: 900px;
  margin: 0 auto;
  padding: 40px 32px;
}

/* Section */
.section { display: none; }
.section.active { display: block; animation: fadeIn 0.4s ease; }

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

/* Typography */
h2 {
  font-size: 32px;
  font-weight: 700;
  margin-bottom: 8px;
  background: linear-gradient(135deg, var(--accent2), var(--cyan));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

h3 {
  font-size: 22px;
  font-weight: 600;
  margin: 32px 0 16px;
  color: var(--text);
}

h4 {
  font-size: 17px;
  font-weight: 600;
  margin: 24px 0 12px;
  color: var(--accent2);
}

.subtitle {
  font-size: 16px;
  color: var(--text2);
  margin-bottom: 32px;
}

p { margin-bottom: 16px; color: var(--text2); }

/* Cards */
.card {
  background: var(--surface);
  border: 1px solid var(--surface3);
  border-radius: var(--radius);
  padding: 24px;
  margin-bottom: 20px;
}

.card-accent {
  border-left: 4px solid var(--accent);
}

.card-green { border-left: 4px solid var(--green); }
.card-orange { border-left: 4px solid var(--orange); }
.card-red { border-left: 4px solid var(--red); }
.card-blue { border-left: 4px solid var(--blue); }

.card-title {
  font-size: 16px;
  font-weight: 600;
  margin-bottom: 12px;
  color: var(--text);
  display: flex;
  align-items: center;
  gap: 8px;
}

/* Code */
.code-block {
  background: #0d1117;
  border: 1px solid var(--surface3);
  border-radius: 8px;
  padding: 20px;
  margin: 16px 0;
  overflow-x: auto;
  position: relative;
}

.code-block pre {
  font-family: 'Fira Code', 'Cascadia Code', 'Consolas', monospace;
  font-size: 13px;
  line-height: 1.8;
  color: #e6edf3;
  white-space: pre;
  tab-size: 2;
}

.code-label {
  position: absolute;
  top: 8px;
  right: 12px;
  font-size: 11px;
  color: var(--text2);
  background: var(--surface2);
  padding: 2px 8px;
  border-radius: 4px;
}

code {
  font-family: 'Fira Code', 'Consolas', monospace;
  background: var(--surface2);
  padding: 2px 6px;
  border-radius: 4px;
  font-size: 13px;
  color: var(--pink);
}

/* Syntax Highlighting */
.kw { color: #ff7b72; }
.fn { color: #d2a8ff; }
.str { color: #a5d6ff; }
.cm { color: #8b949e; }
.num { color: #79c0ff; }
.op { color: #ff7b72; }
.prop { color: #79c0ff; }
.tag { color: #7ee787; }
.attr { color: #d2a8ff; }

/* Visual Diagrams */
.diagram {
  background: var(--surface);
  border: 1px solid var(--surface3);
  border-radius: var(--radius);
  padding: 32px;
  margin: 20px 0;
  text-align: center;
}

.diagram-row {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 16px;
  margin: 16px 0;
  flex-wrap: wrap;
}

.diagram-box {
  background: var(--surface2);
  border: 2px solid var(--surface3);
  border-radius: 8px;
  padding: 14px 22px;
  font-size: 14px;
  font-weight: 500;
  color: var(--text);
  transition: all 0.3s;
  min-width: 120px;
}

.diagram-box.highlight {
  border-color: var(--accent);
  background: rgba(108, 92, 231, 0.15);
  color: var(--accent2);
}

.diagram-box.green {
  border-color: var(--green);
  background: rgba(0, 184, 148, 0.1);
  color: var(--green);
}

.diagram-box.orange {
  border-color: var(--orange);
  background: rgba(253, 203, 110, 0.1);
  color: var(--orange);
}

.diagram-box.red {
  border-color: var(--red);
  background: rgba(225, 112, 85, 0.1);
  color: var(--red);
}

.diagram-arrow {
  font-size: 24px;
  color: var(--text2);
}

/* Interactive Demo */
.demo-area {
  background: var(--surface);
  border: 1px solid var(--surface3);
  border-radius: var(--radius);
  overflow: hidden;
  margin: 20px 0;
}

.demo-header {
  background: var(--surface2);
  padding: 12px 20px;
  font-size: 13px;
  font-weight: 600;
  color: var(--text2);
  display: flex;
  align-items: center;
  gap: 8px;
  border-bottom: 1px solid var(--surface3);
}

.demo-body {
  padding: 24px;
}

.demo-output {
  background: #0d1117;
  border: 1px solid var(--surface3);
  border-radius: 8px;
  padding: 16px;
  margin-top: 16px;
  font-family: monospace;
  font-size: 13px;
  min-height: 60px;
  color: var(--green);
  white-space: pre-wrap;
}

/* Buttons */
.btn {
  display: inline-flex;
  align-items: center;
  gap: 8px;
  padding: 10px 20px;
  border: none;
  border-radius: 8px;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
  font-family: inherit;
}

.btn-primary {
  background: var(--accent);
  color: #fff;
}

.btn-primary:hover { background: #5b4bd5; }

.btn-secondary {
  background: var(--surface2);
  color: var(--text);
  border: 1px solid var(--surface3);
}

.btn-secondary:hover { background: var(--surface3); }

.btn-green { background: var(--green); color: #fff; }
.btn-green:hover { background: #00a381; }

.btn-small {
  padding: 6px 14px;
  font-size: 13px;
}

.btn-group {
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
  margin: 16px 0;
}

/* Quiz */
.quiz-question {
  background: var(--surface);
  border: 1px solid var(--surface3);
  border-radius: var(--radius);
  padding: 24px;
  margin-bottom: 20px;
}

.quiz-q {
  font-size: 16px;
  font-weight: 600;
  color: var(--text);
  margin-bottom: 16px;
  display: flex;
  gap: 10px;
}

.quiz-q .q-num {
  color: var(--accent);
  font-weight: 700;
}

.quiz-options {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.quiz-option {
  padding: 12px 16px;
  background: var(--surface2);
  border: 2px solid var(--surface3);
  border-radius: 8px;
  cursor: pointer;
  transition: all 0.2s;
  font-size: 14px;
  color: var(--text2);
}

.quiz-option:hover {
  border-color: var(--accent);
  background: rgba(108, 92, 231, 0.1);
}

.quiz-option.selected {
  border-color: var(--accent);
  background: rgba(108, 92, 231, 0.15);
  color: var(--text);
}

.quiz-option.correct {
  border-color: var(--green);
  background: rgba(0, 184, 148, 0.15);
  color: var(--green);
}

.quiz-option.wrong {
  border-color: var(--red);
  background: rgba(225, 112, 85, 0.15);
  color: var(--red);
}

.quiz-explanation {
  margin-top: 12px;
  padding: 12px 16px;
  background: rgba(0, 184, 148, 0.08);
  border: 1px solid rgba(0, 184, 148, 0.2);
  border-radius: 8px;
  font-size: 14px;
  color: var(--text2);
  display: none;
}

.quiz-explanation.show { display: block; animation: fadeIn 0.3s; }

.quiz-score {
  text-align: center;
  padding: 32px;
  background: var(--surface);
  border-radius: var(--radius);
  margin-top: 20px;
}

.quiz-score .score-num {
  font-size: 48px;
  font-weight: 700;
  background: linear-gradient(135deg, var(--accent2), var(--green));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
}

/* Exercise */
.exercise {
  background: var(--surface);
  border: 1px solid var(--surface3);
  border-radius: var(--radius);
  padding: 24px;
  margin-bottom: 20px;
}

.exercise-title {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 16px;
  font-weight: 600;
  margin-bottom: 12px;
}

.exercise-badge {
  padding: 3px 10px;
  border-radius: 20px;
  font-size: 11px;
  font-weight: 600;
  text-transform: uppercase;
}

.badge-easy { background: rgba(0,184,148,0.15); color: var(--green); }
.badge-medium { background: rgba(253,203,110,0.15); color: var(--orange); }
.badge-hard { background: rgba(225,112,85,0.15); color: var(--red); }

textarea.code-editor {
  width: 100%;
  min-height: 150px;
  background: #0d1117;
  border: 1px solid var(--surface3);
  border-radius: 8px;
  padding: 16px;
  font-family: 'Fira Code', 'Consolas', monospace;
  font-size: 13px;
  line-height: 1.7;
  color: #e6edf3;
  resize: vertical;
  tab-size: 2;
}

textarea.code-editor:focus {
  outline: none;
  border-color: var(--accent);
}

.exercise-result {
  margin-top: 12px;
  padding: 12px 16px;
  border-radius: 8px;
  font-size: 14px;
  display: none;
}

.exercise-result.pass {
  background: rgba(0, 184, 148, 0.1);
  border: 1px solid rgba(0, 184, 148, 0.3);
  color: var(--green);
  display: block;
}

.exercise-result.fail {
  background: rgba(225, 112, 85, 0.1);
  border: 1px solid rgba(225, 112, 85, 0.3);
  color: var(--red);
  display: block;
}

/* Cheat Sheet */
.cheat-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(380px, 1fr));
  gap: 16px;
  margin: 20px 0;
}

.cheat-item {
  background: var(--surface);
  border: 1px solid var(--surface3);
  border-radius: var(--radius);
  padding: 20px;
}

.cheat-item h4 {
  margin: 0 0 10px;
  font-size: 15px;
}

/* Pitfall */
.pitfall {
  background: var(--surface);
  border: 1px solid var(--surface3);
  border-left: 4px solid var(--red);
  border-radius: var(--radius);
  padding: 24px;
  margin-bottom: 20px;
}

.pitfall-header {
  display: flex;
  align-items: center;
  gap: 10px;
  font-weight: 600;
  color: var(--red);
  margin-bottom: 12px;
  font-size: 16px;
}

.fix-header {
  display: flex;
  align-items: center;
  gap: 10px;
  font-weight: 600;
  color: var(--green);
  margin: 16px 0 8px;
  font-size: 15px;
}

/* Tabs */
.tabs {
  display: flex;
  gap: 4px;
  margin-bottom: 24px;
  background: var(--surface);
  border-radius: 8px;
  padding: 4px;
  overflow-x: auto;
}

.tab {
  padding: 8px 18px;
  border-radius: 6px;
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
  color: var(--text2);
  white-space: nowrap;
}

.tab:hover { background: var(--surface2); }
.tab.active { background: var(--accent); color: #fff; }

/* Comparison Table */
.comp-table {
  width: 100%;
  border-collapse: collapse;
  margin: 16px 0;
  font-size: 14px;
}

.comp-table th {
  background: var(--surface2);
  padding: 12px 16px;
  text-align: left;
  font-weight: 600;
  color: var(--text);
  border: 1px solid var(--surface3);
}

.comp-table td {
  padding: 12px 16px;
  border: 1px solid var(--surface3);
  color: var(--text2);
  background: var(--surface);
}

/* Tooltip */
.tooltip-trigger {
  border-bottom: 1px dashed var(--accent2);
  cursor: help;
  color: var(--accent2);
}

/* Accordion */
.accordion {
  margin: 10px 0;
}

.accordion-header {
  background: var(--surface2);
  border: 1px solid var(--surface3);
  border-radius: 8px;
  padding: 14px 20px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: space-between;
  font-weight: 500;
  font-size: 14px;
  transition: all 0.2s;
}

.accordion-header:hover { background: var(--surface3); }
.accordion-header .arrow { transition: transform 0.3s; }
.accordion.open .accordion-header .arrow { transform: rotate(180deg); }

.accordion-body {
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.3s ease;
}

.accordion.open .accordion-body { max-height: 2000px; }

.accordion-content {
  padding: 20px;
  border: 1px solid var(--surface3);
  border-top: none;
  border-radius: 0 0 8px 8px;
}

/* Tree diagram */
.tree {
  padding: 20px;
}

.tree-node {
  margin-left: 24px;
  position: relative;
}

.tree-node::before {
  content: '';
  position: absolute;
  left: -16px;
  top: 0;
  height: 100%;
  width: 1px;
  background: var(--surface3);
}

.tree-node::after {
  content: '';
  position: absolute;
  left: -16px;
  top: 14px;
  width: 12px;
  height: 1px;
  background: var(--surface3);
}

.tree-label {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  padding: 6px 14px;
  background: var(--surface2);
  border-radius: 6px;
  font-size: 13px;
  margin: 4px 0;
  font-family: monospace;
}

.tree-label.changed {
  background: rgba(225, 112, 85, 0.15);
  border: 1px solid rgba(225, 112, 85, 0.3);
  color: var(--red);
}

.tree-label.added {
  background: rgba(0, 184, 148, 0.15);
  border: 1px solid rgba(0, 184, 148, 0.3);
  color: var(--green);
}

.tree-label.removed {
  background: rgba(225, 112, 85, 0.15);
  border: 1px solid rgba(225, 112, 85, 0.3);
  color: var(--red);
  text-decoration: line-through;
}

/* Mobile */
.menu-toggle {
  display: none;
  position: fixed;
  top: 16px;
  left: 16px;
  z-index: 200;
  background: var(--accent);
  color: #fff;
  border: none;
  border-radius: 8px;
  padding: 8px 12px;
  font-size: 20px;
  cursor: pointer;
}

@media (max-width: 768px) {
  .sidebar { transform: translateX(-100%); }
  .sidebar.open { transform: translateX(0); }
  .main { margin-left: 0; }
  .menu-toggle { display: block; }
  .content { padding: 60px 16px 40px; }
  .cheat-grid { grid-template-columns: 1fr; }
  h2 { font-size: 26px; }
}

/* Animation classes */
.vdom-node {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 60px;
  height: 60px;
  border-radius: 50%;
  background: var(--surface2);
  border: 2px solid var(--surface3);
  font-weight: 600;
  font-size: 14px;
  transition: all 0.5s;
  position: relative;
}

.vdom-node.active-node {
  border-color: var(--accent);
  background: rgba(108, 92, 231, 0.2);
  transform: scale(1.1);
}

.vdom-node.diff-node {
  border-color: var(--red);
  background: rgba(225, 112, 85, 0.2);
  animation: pulse 1s infinite;
}

.vdom-node.new-node {
  border-color: var(--green);
  background: rgba(0, 184, 148, 0.2);
}

@keyframes pulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.08); }
}

.step-indicator {
  display: flex;
  gap: 8px;
  justify-content: center;
  margin: 16px 0;
}

.step-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: var(--surface3);
  transition: all 0.3s;
}

.step-dot.active { background: var(--accent); transform: scale(1.3); }
.step-dot.done { background: var(--green); }

/* Reactivity visual */
.reactive-box {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
}

.reactive-var {
  padding: 10px 20px;
  background: var(--surface2);
  border: 2px solid var(--surface3);
  border-radius: 8px;
  font-family: monospace;
  transition: all 0.3s;
}

.reactive-var.triggered {
  border-color: var(--orange);
  background: rgba(253, 203, 110, 0.15);
  animation: pulse 0.5s;
}

.flow-line {
  width: 2px;
  height: 30px;
  background: var(--surface3);
  position: relative;
}

.flow-line::after {
  content: '‚ñº';
  position: absolute;
  bottom: -8px;
  left: -5px;
  font-size: 12px;
  color: var(--text2);
}

/* Nav bottom */
.nav-bottom {
  display: flex;
  justify-content: space-between;
  margin-top: 40px;
  padding-top: 20px;
  border-top: 1px solid var(--surface3);
}

/* Highlight effect */
.highlight-anim {
  animation: highlightFlash 0.6s ease;
}

@keyframes highlightFlash {
  0% { background-color: rgba(108, 92, 231, 0.3); }
  100% { background-color: transparent; }
}

/* Tag */
.framework-tag {
  display: inline-flex;
  align-items: center;
  padding: 2px 10px;
  border-radius: 20px;
  font-size: 11px;
  font-weight: 600;
}

.tag-react { background: rgba(97,218,251,0.15); color: #61dafb; }
.tag-vue { background: rgba(65,184,131,0.15); color: #41b883; }
.tag-angular { background: rgba(221,0,49,0.15); color: #dd0031; }

.inline-demo {
  border: 1px solid var(--surface3);
  border-radius: 8px;
  padding: 20px;
  margin: 16px 0;
  background: var(--surface);
}

.inline-demo label {
  font-size: 14px;
  color: var(--text2);
  margin-right: 8px;
}

.inline-demo input[type="text"],
.inline-demo input[type="number"] {
  background: var(--surface2);
  border: 1px solid var(--surface3);
  border-radius: 6px;
  padding: 8px 12px;
  color: var(--text);
  font-family: monospace;
  font-size: 14px;
  width: 200px;
}

.inline-demo input:focus {
  outline: none;
  border-color: var(--accent);
}

.log-entry {
  padding: 4px 0;
  font-family: monospace;
  font-size: 13px;
  border-bottom: 1px solid var(--surface3);
  color: var(--text2);
}

.log-entry:last-child { border-bottom: none; }
.log-entry .timestamp { color: var(--text2); opacity: 0.5; }
.log-entry .action { color: var(--orange); }
.log-entry .value { color: var(--green); }
</style>
</head>
<body>

<button class="menu-toggle" onclick="toggleSidebar()">‚ò∞</button>

<div class="app">
  <nav class="sidebar" id="sidebar">
    <div class="sidebar-header">
      <h1>‚öôÔ∏è Framework Internals</h1>
      <p>Master what's under the hood</p>
      <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
      <div class="progress-text" id="progressText">0 / 12 completed</div>
    </div>

    <div class="nav-section">
      <div class="nav-section-title">üìö Lessons</div>
      <div class="nav-item active" onclick="showSection('intro')" data-section="intro">
        <span class="icon">üè†</span> Introduction & Overview
        <span class="check">‚úì</span>
      </div>
      <div class="nav-item" onclick="showSection('vdom')" data-section="vdom">
        <span class="icon">üå≥</span> Virtual DOM Deep Dive
        <span class="check">‚úì</span>
      </div>
      <div class="nav-item" onclick="showSection('reconciliation')" data-section="reconciliation">
        <span class="icon">üîÑ</span> Reconciliation / Diffing
        <span class="check">‚úì</span>
      </div>
      <div class="nav-item" onclick="showSection('reactivity')" data-section="reactivity">
        <span class="icon">‚ö°</span> Reactivity Systems
        <span class="check">‚úì</span>
      </div>
      <div class="nav-item" onclick="showSection('architecture')" data-section="architecture">
        <span class="icon">üèóÔ∏è</span> Framework Architecture
        <span class="check">‚úì</span>
      </div>
      <div class="nav-item" onclick="showSection('comparison')" data-section="comparison">
        <span class="icon">‚öñÔ∏è</span> React vs Vue vs Angular
        <span class="check">‚úì</span>
      </div>
    </div>

    <div class="nav-section">
      <div class="nav-section-title">üí™ Practice</div>
      <div class="nav-item" onclick="showSection('exercises')" data-section="exercises">
        <span class="icon">‚úèÔ∏è</span> Coding Exercises
        <span class="check">‚úì</span>
      </div>
      <div class="nav-item" onclick="showSection('quiz1')" data-section="quiz1">
        <span class="icon">‚ùì</span> Quiz: VDOM & Diffing
        <span class="check">‚úì</span>
      </div>
      <div class="nav-item" onclick="showSection('quiz2')" data-section="quiz2">
        <span class="icon">‚ùì</span> Quiz: Reactivity
        <span class="check">‚úì</span>
      </div>
      <div class="nav-item" onclick="showSection('quiz3')" data-section="quiz3">
        <span class="icon">‚ùì</span> Quiz: Architecture
        <span class="check">‚úì</span>
      </div>
    </div>

    <div class="nav-section">
      <div class="nav-section-title">üîß Reference</div>
      <div class="nav-item" onclick="showSection('pitfalls')" data-section="pitfalls">
        <span class="icon">‚ö†Ô∏è</span> Mistakes & Pitfalls
        <span class="check">‚úì</span>
      </div>
      <div class="nav-item" onclick="showSection('cheatsheet')" data-section="cheatsheet">
        <span class="icon">üìã</span> Cheat Sheet
        <span class="check">‚úì</span>
      </div>
    </div>
  </nav>

  <main class="main">
    <div class="content">

      <!-- ==================== INTRO ==================== -->
      <div class="section active" id="sec-intro">
        <h2>üè† Framework Internals Overview</h2>
        <p class="subtitle">Understanding what React, Vue, and Angular do behind the scenes ‚Äî and why it matters for interviews.</p>

        <div class="card card-accent">
          <div class="card-title">üéØ Why Learn This?</div>
          <p>Top companies don't just want you to <em>use</em> frameworks ‚Äî they want you to understand <strong>how</strong> and <strong>why</strong> they work. This knowledge helps you:</p>
          <ul style="margin: 12px 0 0 20px; color: var(--text2);">
            <li>Debug complex performance issues</li>
            <li>Make better architectural decisions</li>
            <li>Answer advanced interview questions confidently</li>
            <li>Write more efficient component code</li>
          </ul>
        </div>

        <h3>The Core Problem All Frameworks Solve</h3>
        <p>At their heart, all modern frameworks solve one problem: <strong>keeping the UI in sync with application state</strong>.</p>

        <div class="diagram">
          <div class="diagram-row">
            <div class="diagram-box highlight">State (Data)</div>
            <div class="diagram-arrow">‚Üí</div>
            <div class="diagram-box green">Framework Magic ‚ú®</div>
            <div class="diagram-arrow">‚Üí</div>
            <div class="diagram-box orange">DOM (UI)</div>
          </div>
          <p style="margin-top: 16px; font-size: 13px;">When state changes, the framework figures out the minimum DOM updates needed.</p>
        </div>

        <h3>The 4 Pillars You'll Master</h3>

        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin: 20px 0;">
          <div class="card" style="border-top: 3px solid var(--accent);">
            <div class="card-title">üå≥ Virtual DOM</div>
            <p style="font-size: 14px;">A lightweight JS copy of the real DOM. Changes are calculated in memory first, then applied efficiently.</p>
          </div>
          <div class="card" style="border-top: 3px solid var(--green);">
            <div class="card-title">üîÑ Reconciliation</div>
            <p style="font-size: 14px;">The "diffing" algorithm that compares old and new virtual trees to find minimum changes.</p>
          </div>
          <div class="card" style="border-top: 3px solid var(--orange);">
            <div class="card-title">‚ö° Reactivity</div>
            <p style="font-size: 14px;">The system that detects state changes and triggers re-renders automatically.</p>
          </div>
          <div class="card" style="border-top: 3px solid var(--pink);">
            <div class="card-title">üèóÔ∏è Architecture</div>
            <p style="font-size: 14px;">Component model, lifecycle, dependency injection, and the rendering pipeline.</p>
          </div>
        </div>

        <h3>Without Frameworks: The Painful Way</h3>
        <p>Here's how you'd update UI manually with vanilla JS:</p>

        <div class="code-block">
          <span class="code-label">Vanilla JS - Manual DOM</span>
          <pre><span class="cm">// You manage EVERYTHING manually üò©</span>
<span class="kw">let</span> count = <span class="num">0</span>;

<span class="kw">function</span> <span class="fn">increment</span>() {
  count++;
  <span class="cm">// YOU must find the element</span>
  <span class="kw">const</span> el = document.<span class="fn">getElementById</span>(<span class="str">'counter'</span>);
  <span class="cm">// YOU must update it</span>
  el.textContent = count;
  <span class="cm">// YOU must handle every edge case</span>
  <span class="cm">// What if the element doesn't exist?</span>
  <span class="cm">// What about other elements that depend on count?</span>
  <span class="cm">// What about list reordering, animations, etc?</span>
}

<span class="cm">// With 100+ pieces of state, this becomes a nightmare!</span></pre>
        </div>

        <h3>With a Framework: The Declarative Way</h3>
        <div class="code-block">
          <span class="code-label">React - Declarative</span>
          <pre><span class="cm">// You describe WHAT the UI should look like</span>
<span class="cm">// The framework figures out HOW to update the DOM</span>
<span class="kw">function</span> <span class="fn">Counter</span>() {
  <span class="kw">const</span> [count, setCount] = <span class="fn">useState</span>(<span class="num">0</span>);

  <span class="kw">return</span> (
    <span class="tag">&lt;button</span> <span class="attr">onClick</span>={() => <span class="fn">setCount</span>(count + <span class="num">1</span>)}<span class="tag">&gt;</span>
      Clicked {count} times
    <span class="tag">&lt;/button&gt;</span>
  );
  <span class="cm">// Framework handles: finding the DOM node,</span>
  <span class="cm">// comparing old vs new, updating only what changed</span>
}</pre>
        </div>

        <div class="card card-green">
          <div class="card-title">üí° Key Insight</div>
          <p>Frameworks let you think <strong>declaratively</strong> ("the UI should look like THIS based on THIS state") instead of <strong>imperatively</strong> ("find this element, change this attribute, add this child..."). The framework handles the imperative DOM manipulation for you using Virtual DOM, diffing, and reactivity.</p>
        </div>

        <div class="nav-bottom">
          <div></div>
          <button class="btn btn-primary" onclick="showSection('vdom')">Next: Virtual DOM ‚Üí</button>
        </div>
      </div>

      <!-- ==================== VIRTUAL DOM ==================== -->
      <div class="section" id="sec-vdom">
        <h2>üå≥ Virtual DOM Deep Dive</h2>
        <p class="subtitle">Understanding the core abstraction that powers React and Vue.</p>

        <h3>What IS the Virtual DOM?</h3>
        <p>The Virtual DOM is simply a <strong>plain JavaScript object</strong> that represents the structure of your UI. It's a lightweight copy of the real DOM.</p>

        <div class="card card-blue">
          <div class="card-title">üß† Think of it like this:</div>
          <p>Imagine you're an architect. Instead of knocking down walls to test each design change (expensive!), you modify the <strong>blueprint</strong> (cheap), compare blueprints, then make <strong>only the needed construction changes</strong>.</p>
          <p><strong>Blueprint = Virtual DOM</strong> | <strong>Building = Real DOM</strong></p>
        </div>

        <h3>Real DOM Node vs Virtual DOM Node</h3>

        <div class="code-block">
          <span class="code-label">Real DOM Element</span>
          <pre><span class="cm">// A real DOM node has 200+ properties/methods!</span>
<span class="kw">const</span> div = document.<span class="fn">createElement</span>(<span class="str">'div'</span>);
console.<span class="fn">log</span>(Object.<span class="fn">keys</span>(div).length); <span class="cm">// ~200+ properties</span>
<span class="cm">// Creating/modifying these is EXPENSIVE</span></pre>
        </div>

        <div class="code-block">
          <span class="code-label">Virtual DOM Node (VNode)</span>
          <pre><span class="cm">// A virtual DOM node is just a plain JS object!</span>
<span class="kw">const</span> vNode = {
  <span class="prop">type</span>: <span class="str">'div'</span>,               <span class="cm">// what element</span>
  <span class="prop">props</span>: {                     <span class="cm">// properties</span>
    <span class="prop">className</span>: <span class="str">'container'</span>,
    <span class="prop">onClick</span>: handleClick
  },
  <span class="prop">children</span>: [                  <span class="cm">// nested elements</span>
    {
      <span class="prop">type</span>: <span class="str">'h1'</span>,
      <span class="prop">props</span>: {},
      <span class="prop">children</span>: [<span class="str">'Hello World'</span>]
    },
    {
      <span class="prop">type</span>: <span class="str">'p'</span>,
      <span class="prop">props</span>: { <span class="prop">id</span>: <span class="str">'desc'</span> },
      <span class="prop">children</span>: [<span class="str">'This is fast!'</span>]
    }
  ]
};
<span class="cm">// Creating/comparing these is CHEAP</span></pre>
        </div>

        <h3>How React's createElement Actually Works</h3>
        <p>When you write JSX, Babel compiles it to <code>React.createElement()</code> calls:</p>

        <div class="code-block">
          <span class="code-label">JSX ‚Üí createElement</span>
          <pre><span class="cm">// What you write (JSX):</span>
<span class="kw">const</span> element = (
  <span class="tag">&lt;div</span> <span class="attr">className</span>=<span class="str">"app"</span><span class="tag">&gt;</span>
    <span class="tag">&lt;h1&gt;</span>Hello<span class="tag">&lt;/h1&gt;</span>
    <span class="tag">&lt;p&gt;</span>Count: {count}<span class="tag">&lt;/p&gt;</span>
  <span class="tag">&lt;/div&gt;</span>
);

<span class="cm">// What the compiler produces:</span>
<span class="kw">const</span> element = React.<span class="fn">createElement</span>(
  <span class="str">'div'</span>,
  { <span class="prop">className</span>: <span class="str">'app'</span> },
  React.<span class="fn">createElement</span>(<span class="str">'h1'</span>, <span class="kw">null</span>, <span class="str">'Hello'</span>),
  React.<span class="fn">createElement</span>(<span class="str">'p'</span>, <span class="kw">null</span>, <span class="str">'Count: '</span>, count)
);

<span class="cm">// Which returns this object (Virtual DOM node):</span>
{
  <span class="prop">type</span>: <span class="str">'div'</span>,
  <span class="prop">props</span>: {
    <span class="prop">className</span>: <span class="str">'app'</span>,
    <span class="prop">children</span>: [
      { <span class="prop">type</span>: <span class="str">'h1'</span>, <span class="prop">props</span>: { <span class="prop">children</span>: <span class="str">'Hello'</span> } },
      { <span class="prop">type</span>: <span class="str">'p'</span>, <span class="prop">props</span>: { <span class="prop">children</span>: [<span class="str">'Count: '</span>, <span class="num">5</span>] } }
    ]
  }
}</pre>
        </div>

        <h3>üî¨ Interactive: Build a Virtual DOM</h3>
        <div class="demo-area">
          <div class="demo-header">üß™ Live Demo: createElement Implementation</div>
          <div class="demo-body">
            <p style="font-size: 14px; margin-bottom: 12px;">Click to see our own mini Virtual DOM in action:</p>
            <div class="btn-group">
              <button class="btn btn-primary btn-small" onclick="demoCreateElement()">Run createElement()</button>
              <button class="btn btn-secondary btn-small" onclick="demoRenderVDOM()">Render to Real DOM</button>
              <button class="btn btn-secondary btn-small" onclick="demoClearVDOM()">Clear</button>
            </div>
            <div class="demo-output" id="vdom-output">Click "Run createElement()" to see the Virtual DOM object...</div>
            <div id="vdom-render-target" style="margin-top: 12px; padding: 12px; background: var(--surface2); border-radius: 8px; min-height: 40px;"></div>
          </div>
        </div>

        <h3>The Virtual DOM Lifecycle</h3>
        <div class="diagram">
          <div class="diagram-row">
            <div class="diagram-box highlight">1. State Changes</div>
            <div class="diagram-arrow">‚Üí</div>
            <div class="diagram-box green">2. New VDOM Tree</div>
            <div class="diagram-arrow">‚Üí</div>
            <div class="diagram-box orange">3. Diff Old vs New</div>
          </div>
          <div style="margin: 12px 0; font-size: 24px; color: var(--text2);">‚Üì</div>
          <div class="diagram-row">
            <div class="diagram-box red">4. Calculate Patches</div>
            <div class="diagram-arrow">‚Üí</div>
            <div class="diagram-box" style="border-color: var(--cyan); color: var(--cyan);">5. Apply to Real DOM</div>
          </div>
        </div>

        <h3>Vue's Virtual DOM</h3>
        <p>Vue also uses a Virtual DOM, but with some differences:</p>

        <div class="code-block">
          <span class="code-label">Vue 3 VNode</span>
          <pre><span class="cm">// Vue's render function (what templates compile to)</span>
<span class="kw">import</span> { h } <span class="kw">from</span> <span class="str">'vue'</span>

<span class="cm">// h() is Vue's createElement equivalent</span>
<span class="kw">const</span> vnode = <span class="fn">h</span>(<span class="str">'div'</span>, { <span class="prop">class</span>: <span class="str">'app'</span> }, [
  <span class="fn">h</span>(<span class="str">'h1'</span>, <span class="str">'Hello'</span>),
  <span class="fn">h</span>(<span class="str">'p'</span>, <span class="str">`Count: ${count}`</span>)
])

<span class="cm">// Vue ALSO tracks which parts are dynamic at compile time</span>
<span class="cm">// This makes diffing faster (compiler-informed VDOM)</span></pre>
        </div>

        <div class="card card-orange">
          <div class="card-title">‚ö†Ô∏è Angular is Different!</div>
          <p>Angular does NOT use a Virtual DOM. It uses <strong>Incremental DOM</strong> (Ivy renderer) which compiles templates into instructions that modify the DOM directly. Each component becomes a set of instructions like "create element", "update text", etc.</p>
        </div>

        <h3>Why Not Just Update the Real DOM Directly?</h3>
        <table class="comp-table">
          <tr>
            <th>Operation</th>
            <th>Real DOM</th>
            <th>Virtual DOM</th>
          </tr>
          <tr>
            <td>Create a node</td>
            <td>~10,000 nanoseconds</td>
            <td>~100 nanoseconds</td>
          </tr>
          <tr>
            <td>Compare nodes</td>
            <td>Must read from DOM (slow)</td>
            <td>Compare JS objects (fast)</td>
          </tr>
          <tr>
            <td>Batch updates</td>
            <td>Each change triggers reflow</td>
            <td>Changes batched, one reflow</td>
          </tr>
          <tr>
            <td>Memory</td>
            <td>Heavy objects (~200 props)</td>
            <td>Light objects (~5 props)</td>
          </tr>
        </table>

        <div class="nav-bottom">
          <button class="btn btn-secondary" onclick="showSection('intro')">‚Üê Introduction</button>
          <button class="btn btn-primary" onclick="showSection('reconciliation')">Next: Reconciliation ‚Üí</button>
        </div>
      </div>

      <!-- ==================== RECONCILIATION ==================== -->
      <div class="section" id="sec-reconciliation">
        <h2>üîÑ Reconciliation & Diffing</h2>
        <p class="subtitle">How frameworks figure out the minimum DOM changes needed.</p>

        <h3>The Problem</h3>
        <p>When state changes, the framework creates a <strong>new</strong> Virtual DOM tree. Now it needs to figure out what changed between the <strong>old tree</strong> and the <strong>new tree</strong>.</p>

        <div class="card card-blue">
          <div class="card-title">üßÆ The Math Problem</div>
          <p>The general algorithm to compare two trees has <strong>O(n¬≥)</strong> complexity. For 1,000 elements, that's <strong>1 billion</strong> comparisons! React's algorithm achieves <strong>O(n)</strong> using two key heuristics.</p>
        </div>

        <h3>React's Two Heuristic Rules</h3>

        <div class="card card-green">
          <div class="card-title">Rule 1: Different types ‚Üí Rebuild entire subtree</div>
          <p>If a node changes from <code>&lt;div&gt;</code> to <code>&lt;span&gt;</code>, React doesn't try to match children ‚Äî it destroys the old tree and builds a new one.</p>
          <div class="code-block">
            <pre><span class="cm">// OLD                    // NEW</span>
<span class="tag">&lt;div&gt;</span>                     <span class="tag">&lt;span&gt;</span>
  <span class="tag">&lt;Counter /&gt;</span>               <span class="tag">&lt;Counter /&gt;</span>  <span class="cm">‚Üê destroyed & recreated!</span>
<span class="tag">&lt;/div&gt;</span>                    <span class="tag">&lt;/span&gt;</span>

<span class="cm">// Even though Counter looks the same,</span>
<span class="cm">// it gets unmounted and remounted because parent type changed</span></pre>
          </div>
        </div>

        <div class="card card-green" style="margin-top: 16px;">
          <div class="card-title">Rule 2: Keys identify elements across renders</div>
          <p>When rendering lists, <code>key</code> props tell React which items are the same between renders.</p>
          <div class="code-block">
            <pre><span class="cm">// WITHOUT keys: React compares by position (inefficient)</span>
<span class="cm">// OLD              NEW (added item at start)</span>
<span class="tag">&lt;li&gt;</span>Apple<span class="tag">&lt;/li&gt;</span>       <span class="tag">&lt;li&gt;</span>Mango<span class="tag">&lt;/li&gt;</span>    <span class="cm">‚Üê thinks Apple‚ÜíMango (update)</span>
<span class="tag">&lt;li&gt;</span>Banana<span class="tag">&lt;/li&gt;</span>      <span class="tag">&lt;li&gt;</span>Apple<span class="tag">&lt;/li&gt;</span>    <span class="cm">‚Üê thinks Banana‚ÜíApple (update)</span>
                    <span class="tag">&lt;li&gt;</span>Banana<span class="tag">&lt;/li&gt;</span>   <span class="cm">‚Üê new node (insert)</span>
<span class="cm">// Result: Updates ALL items = SLOW üêå</span>

<span class="cm">// WITH keys: React matches by identity (efficient)</span>
<span class="tag">&lt;li</span> <span class="attr">key</span>=<span class="str">"mango"</span><span class="tag">&gt;</span>Mango<span class="tag">&lt;/li&gt;</span>    <span class="cm">‚Üê new node (just insert)</span>
<span class="tag">&lt;li</span> <span class="attr">key</span>=<span class="str">"apple"</span><span class="tag">&gt;</span>Apple<span class="tag">&lt;/li&gt;</span>    <span class="cm">‚Üê same key, no change ‚úì</span>
<span class="tag">&lt;li</span> <span class="attr">key</span>=<span class="str">"banana"</span><span class="tag">&gt;</span>Banana<span class="tag">&lt;/li&gt;</span>  <span class="cm">‚Üê same key, no change ‚úì</span>
<span class="cm">// Result: Only 1 insertion = FAST üöÄ</span></pre>
          </div>
        </div>

        <h3>üî¨ Interactive: Diffing Visualizer</h3>
        <div class="demo-area">
          <div class="demo-header">üß™ Live Demo: Watch the Diffing Algorithm</div>
          <div class="demo-body">
            <p style="font-size: 14px; margin-bottom: 16px;">Watch how the diff algorithm compares two virtual DOM trees step by step:</p>
            <div style="display: flex; gap: 40px; justify-content: center; flex-wrap: wrap;">
              <div style="text-align: center;">
                <p style="font-weight: 600; color: var(--text); margin-bottom: 12px;">Old Tree</p>
                <div id="old-tree">
                  <div class="vdom-node" id="old-div" style="margin-bottom: 8px;">div</div>
                  <div style="display: flex; gap: 12px; justify-content: center;">
                    <div class="vdom-node" id="old-h1">h1</div>
                    <div class="vdom-node" id="old-p">p</div>
                    <div class="vdom-node" id="old-btn">btn</div>
                  </div>
                </div>
              </div>
              <div style="text-align: center;">
                <p style="font-weight: 600; color: var(--text); margin-bottom: 12px;">New Tree</p>
                <div id="new-tree">
                  <div class="vdom-node" id="new-div" style="margin-bottom: 8px;">div</div>
                  <div style="display: flex; gap: 12px; justify-content: center;">
                    <div class="vdom-node" id="new-h1">h1</div>
                    <div class="vdom-node" id="new-span">span</div>
                    <div class="vdom-node" id="new-btn">btn</div>
                  </div>
                </div>
              </div>
            </div>
            <div class="step-indicator" id="diff-steps">
              <div class="step-dot" data-step="0"></div>
              <div class="step-dot" data-step="1"></div>
              <div class="step-dot" data-step="2"></div>
              <div class="step-dot" data-step="3"></div>
              <div class="step-dot" data-step="4"></div>
            </div>
            <div class="btn-group" style="justify-content: center;">
              <button class="btn btn-primary btn-small" onclick="runDiffDemo()">‚ñ∂ Run Diff Animation</button>
              <button class="btn btn-secondary btn-small" onclick="resetDiffDemo()">‚Ü∫ Reset</button>
            </div>
            <div class="demo-output" id="diff-output">Click "Run Diff Animation" to watch the algorithm work...</div>
          </div>
        </div>

        <h3>React Fiber: The Modern Reconciler</h3>
        <p>React 16+ introduced <strong>Fiber</strong>, a complete rewrite of the reconciliation engine.</p>

        <div class="card card-accent">
          <div class="card-title">Old "Stack" Reconciler Problem</div>
          <p style="font-size: 14px;">The old reconciler processed the entire tree synchronously. For large updates, this could block the main thread for 16ms+ causing <strong>dropped frames and janky UI</strong>.</p>
        </div>

        <div class="card card-green" style="margin-top: 12px;">
          <div class="card-title">Fiber Solution: Incremental Rendering</div>
          <p style="font-size: 14px;">Fiber breaks work into small units (fibers) that can be <strong>paused, aborted, and resumed</strong>. It uses a <strong>priority system</strong>:</p>
          <div class="code-block">
            <pre><span class="cm">// Fiber priority levels (simplified)</span>
<span class="kw">const</span> priorities = {
  <span class="prop">Immediate</span>: <span class="num">1</span>,      <span class="cm">// User input, must handle NOW</span>
  <span class="prop">UserBlocking</span>: <span class="num">2</span>,   <span class="cm">// Button clicks, 250ms deadline</span>
  <span class="prop">Normal</span>: <span class="num">3</span>,          <span class="cm">// Data fetching, 5s deadline</span>
  <span class="prop">Low</span>: <span class="num">4</span>,             <span class="cm">// Analytics, eventual</span>
  <span class="prop">Idle</span>: <span class="num">5</span>,            <span class="cm">// Offscreen, whenever</span>
};

<span class="cm">// A Fiber node (simplified)</span>
<span class="kw">const</span> fiber = {
  <span class="prop">type</span>: <span class="str">'div'</span>,
  <span class="prop">props</span>: { <span class="prop">className</span>: <span class="str">'app'</span> },
  <span class="prop">child</span>: childFiber,        <span class="cm">// first child</span>
  <span class="prop">sibling</span>: siblingFiber,    <span class="cm">// next sibling</span>
  <span class="prop">return</span>: parentFiber,      <span class="cm">// parent (linked list!)</span>
  <span class="prop">alternate</span>: oldFiber,      <span class="cm">// previous version</span>
  <span class="prop">effectTag</span>: <span class="str">'UPDATE'</span>,     <span class="cm">// what to do</span>
  <span class="prop">stateNode</span>: domElement,   <span class="cm">// real DOM node</span>
};</pre>
          </div>
        </div>

        <h3>Vue's Optimized Diffing</h3>
        <p>Vue 3 uses a <strong>compiler-informed Virtual DOM</strong>. The template compiler marks dynamic parts at compile time:</p>

        <div class="code-block">
          <span class="code-label">Vue 3 Compiler Optimization</span>
          <pre><span class="cm">// Template:</span>
<span class="tag">&lt;div</span> <span class="attr">class</span>=<span class="str">"static"</span><span class="tag">&gt;</span>
  <span class="tag">&lt;p&gt;</span>This never changes<span class="tag">&lt;/p&gt;</span>
  <span class="tag">&lt;p&gt;</span>{{ dynamicText }}<span class="tag">&lt;/p&gt;</span>
<span class="tag">&lt;/div&gt;</span>

<span class="cm">// Compiled output (simplified):</span>
<span class="kw">const</span> _hoisted = <span class="fn">createVNode</span>(<span class="str">'p'</span>, <span class="kw">null</span>, <span class="str">'This never changes'</span>)
<span class="cm">// ^ hoisted OUTSIDE render function! Never re-created!</span>

<span class="kw">function</span> <span class="fn">render</span>() {
  <span class="kw">return</span> <span class="fn">createVNode</span>(<span class="str">'div'</span>, { <span class="prop">class</span>: <span class="str">'static'</span> }, [
    _hoisted,  <span class="cm">// skip during diff!</span>
    <span class="fn">createVNode</span>(<span class="str">'p'</span>, <span class="kw">null</span>, ctx.dynamicText, 
      <span class="num">1</span> <span class="cm">/* TEXT ‚Äî patch flag tells Vue ONLY text can change */</span>
    )
  ])
}</pre>
        </div>

        <div class="nav-bottom">
          <button class="btn btn-secondary" onclick="showSection('vdom')">‚Üê Virtual DOM</button>
          <button class="btn btn-primary" onclick="showSection('reactivity')">Next: Reactivity ‚Üí</button>
        </div>
      </div>

      <!-- ==================== REACTIVITY ==================== -->
      <div class="section" id="sec-reactivity">
        <h2>‚ö° Reactivity Systems</h2>
        <p class="subtitle">How frameworks detect changes and trigger updates automatically.</p>

        <h3>The Core Question</h3>
        <p>When you change a variable, how does the framework <em>know</em> it changed and <em>what</em> needs to update?</p>

        <div class="card card-accent">
          <div class="card-title">Three Different Approaches</div>
          <table class="comp-table">
            <tr>
              <th>Framework</th>
              <th>Strategy</th>
              <th>How</th>
            </tr>
            <tr>
              <td><span class="framework-tag tag-react">React</span></td>
              <td>Explicit setState</td>
              <td>You TELL React something changed</td>
            </tr>
            <tr>
              <td><span class="framework-tag tag-vue">Vue</span></td>
              <td>Proxy-based tracking</td>
              <td>Vue DETECTS changes automatically</td>
            </tr>
            <tr>
              <td><span class="framework-tag tag-angular">Angular</span></td>
              <td>Zone.js + Change Detection</td>
              <td>Angular CHECKS everything after events</td>
            </tr>
          </table>
        </div>

        <h3>React: "You Tell Me" Approach</h3>
        <p>React doesn't watch your data. You must explicitly call a setter function:</p>

        <div class="code-block">
          <span class="code-label">React - Explicit Updates</span>
          <pre><span class="kw">function</span> <span class="fn">Counter</span>() {
  <span class="kw">const</span> [count, setCount] = <span class="fn">useState</span>(<span class="num">0</span>);

  <span class="cm">// ‚ùå This does NOTHING ‚Äî React doesn't see it</span>
  <span class="kw">function</span> <span class="fn">badIncrement</span>() {
    count = count + <span class="num">1</span>;  <span class="cm">// Variable changes, but React doesn't know!</span>
  }

  <span class="cm">// ‚úÖ This works ‚Äî you explicitly tell React</span>
  <span class="kw">function</span> <span class="fn">goodIncrement</span>() {
    <span class="fn">setCount</span>(count + <span class="num">1</span>);  <span class="cm">// React: "Oh! State changed! Re-render!"</span>
  }

  <span class="cm">// Under the hood when you call setCount:</span>
  <span class="cm">// 1. React schedules a re-render</span>
  <span class="cm">// 2. Component function runs again</span>
  <span class="cm">// 3. New VDOM tree is created</span>
  <span class="cm">// 4. Diff with old tree</span>
  <span class="cm">// 5. Apply minimal DOM changes</span>
}</pre>
        </div>

        <h3>Vue: Proxy-Based Reactivity (The Magic)</h3>
        <p>Vue 3 uses JavaScript <code>Proxy</code> to intercept property access and mutations:</p>

        <div class="code-block">
          <span class="code-label">Vue 3 Reactivity - Simplified</span>
          <pre><span class="cm">// This is a simplified version of what Vue does internally</span>

<span class="kw">let</span> activeEffect = <span class="kw">null</span>;
<span class="kw">const</span> targetMap = <span class="kw">new</span> <span class="fn">WeakMap</span>(); <span class="cm">// stores dependencies</span>

<span class="kw">function</span> <span class="fn">reactive</span>(target) {
  <span class="kw">return new</span> <span class="fn">Proxy</span>(target, {
    <span class="fn">get</span>(obj, key) {
      <span class="fn">track</span>(obj, key);       <span class="cm">// "someone is reading this property"</span>
      <span class="kw">return</span> obj[key];
    },
    <span class="fn">set</span>(obj, key, value) {
      obj[key] = value;
      <span class="fn">trigger</span>(obj, key);     <span class="cm">// "this property changed! notify watchers"</span>
      <span class="kw">return true</span>;
    }
  });
}

<span class="kw">function</span> <span class="fn">track</span>(target, key) {
  <span class="kw">if</span> (activeEffect) {
    <span class="cm">// Record: "this effect depends on target[key]"</span>
    <span class="kw">let</span> depsMap = targetMap.<span class="fn">get</span>(target) || <span class="kw">new</span> <span class="fn">Map</span>();
    <span class="kw">let</span> deps = depsMap.<span class="fn">get</span>(key) || <span class="kw">new</span> <span class="fn">Set</span>();
    deps.<span class="fn">add</span>(activeEffect);
    depsMap.<span class="fn">set</span>(key, deps);
    targetMap.<span class="fn">set</span>(target, depsMap);
  }
}

<span class="kw">function</span> <span class="fn">trigger</span>(target, key) {
  <span class="kw">const</span> depsMap = targetMap.<span class="fn">get</span>(target);
  <span class="kw">if</span> (!depsMap) <span class="kw">return</span>;
  <span class="kw">const</span> effects = depsMap.<span class="fn">get</span>(key);
  effects && effects.<span class="fn">forEach</span>(effect => <span class="fn">effect</span>());
}</pre>
        </div>

        <h3>üî¨ Interactive: Build a Reactivity System</h3>
        <div class="demo-area">
          <div class="demo-header">üß™ Live Demo: Vue-style Reactivity in Plain JS</div>
          <div class="demo-body">
            <p style="font-size: 14px; margin-bottom: 12px;">This is a working reactive system built from scratch. Change the values and watch effects trigger automatically!</p>
            <div class="inline-demo">
              <div style="display: flex; gap: 20px; flex-wrap: wrap; align-items: center; margin-bottom: 12px;">
                <div>
                  <label>state.name:</label>
                  <input type="text" id="reactive-name" value="Alice" oninput="updateReactiveState('name', this.value)">
                </div>
                <div>
                  <label>state.age:</label>
                  <input type="number" id="reactive-age" value="25" oninput="updateReactiveState('age', parseInt(this.value))">
                </div>
              </div>
            </div>
            <div class="demo-output" id="reactive-output">Initializing reactivity system...</div>
            <div id="reactive-log" style="margin-top: 12px; background: #0d1117; border: 1px solid var(--surface3); border-radius: 8px; padding: 12px; max-height: 200px; overflow-y: auto;"></div>
          </div>
        </div>

        <h3>Angular: Zone.js & Change Detection</h3>
        <p>Angular takes a completely different approach ‚Äî it monkey-patches browser APIs!</p>

        <div class="code-block">
          <span class="code-label">Angular - Zone.js Concept</span>
          <pre><span class="cm">// Zone.js patches ALL async APIs:</span>
<span class="cm">// - setTimeout, setInterval</span>
<span class="cm">// - addEventListener</span>
<span class="cm">// - XMLHttpRequest, fetch</span>
<span class="cm">// - Promise.then</span>

<span class="cm">// Simplified concept:</span>
<span class="kw">const</span> originalSetTimeout = window.setTimeout;

window.setTimeout = <span class="kw">function</span>(callback, delay) {
  <span class="kw">return</span> <span class="fn">originalSetTimeout</span>(<span class="kw">function</span>() {
    <span class="fn">callback</span>();
    <span class="cm">// After ANY async operation completes...</span>
    <span class="fn">angularChangeDetection</span>();  <span class="cm">// Check ALL components!</span>
  }, delay);
};

<span class="cm">// Change Detection walks the entire component tree:</span>
<span class="cm">//   AppComponent         ‚Üê check bindings</span>
<span class="cm">//   ‚îú‚îÄ‚îÄ HeaderComponent  ‚Üê check bindings</span>
<span class="cm">//   ‚îú‚îÄ‚îÄ MainComponent    ‚Üê check bindings</span>
<span class="cm">//   ‚îÇ   ‚îú‚îÄ‚îÄ ListComponent ‚Üê check bindings</span>
<span class="cm">//   ‚îÇ   ‚îî‚îÄ‚îÄ DetailComponent ‚Üê check bindings</span>
<span class="cm">//   ‚îî‚îÄ‚îÄ FooterComponent  ‚Üê check bindings</span>

<span class="cm">// OnPush optimization: skip subtrees that haven't changed</span>
@<span class="fn">Component</span>({
  <span class="prop">changeDetection</span>: ChangeDetectionStrategy.<span class="prop">OnPush</span>
  <span class="cm">// Only re-check when: @Input changes, event handler fires,</span>
  <span class="cm">// async pipe emits, or manually triggered</span>
})</pre>
        </div>

        <h3>Signals: The New Paradigm</h3>
        <p>All three frameworks are converging on <strong>Signals</strong> ‚Äî fine-grained reactivity:</p>

        <div class="code-block">
          <span class="code-label">Signals across frameworks</span>
          <pre><span class="cm">// Angular Signals (v16+)</span>
<span class="kw">const</span> count = <span class="fn">signal</span>(<span class="num">0</span>);
<span class="kw">const</span> doubled = <span class="fn">computed</span>(() => <span class="fn">count</span>() * <span class="num">2</span>);
<span class="fn">effect</span>(() => console.<span class="fn">log</span>(<span class="str">'Count:'</span>, <span class="fn">count</span>()));
count.<span class="fn">set</span>(<span class="num">1</span>);  <span class="cm">// effect fires automatically</span>

<span class="cm">// Vue Composition API (already signal-like)</span>
<span class="kw">const</span> count = <span class="fn">ref</span>(<span class="num">0</span>);
<span class="kw">const</span> doubled = <span class="fn">computed</span>(() => count.<span class="prop">value</span> * <span class="num">2</span>);
<span class="fn">watchEffect</span>(() => console.<span class="fn">log</span>(<span class="str">'Count:'</span>, count.<span class="prop">value</span>));
count.<span class="prop">value</span> = <span class="num">1</span>;

<span class="cm">// React doesn't have signals natively,</span>
<span class="cm">// but libraries like @preact/signals exist</span>
<span class="cm">// React's model is intentionally "re-render the world"</span></pre>
        </div>

        <div class="nav-bottom">
          <button class="btn btn-secondary" onclick="showSection('reconciliation')">‚Üê Reconciliation</button>
          <button class="btn btn-primary" onclick="showSection('architecture')">Next: Architecture ‚Üí</button>
        </div>
      </div>

      <!-- ==================== ARCHITECTURE ==================== -->
      <div class="section" id="sec-architecture">
        <h2>üèóÔ∏è Framework Architecture</h2>
        <p class="subtitle">Component models, lifecycle, rendering pipelines, and DI.</p>

        <h3>The Component Model</h3>
        <p>All three frameworks are built around <strong>components</strong> ‚Äî self-contained, reusable pieces of UI. But they differ in how components work internally.</p>

        <div class="code-block">
          <span class="code-label">Component Lifecycle - All Three</span>
          <pre><span class="cm">// === REACT (Function Components + Hooks) ===</span>
<span class="kw">function</span> <span class="fn">MyComponent</span>({ name }) {
  <span class="cm">// Initialization (runs every render)</span>
  <span class="kw">const</span> [data, setData] = <span class="fn">useState</span>(<span class="kw">null</span>);

  <span class="fn">useEffect</span>(() => {
    <span class="cm">// Mount + Update (after DOM paint)</span>
    <span class="fn">fetchData</span>(name).<span class="fn">then</span>(setData);
    <span class="kw">return</span> () => { <span class="cm">/* Cleanup (unmount) */</span> };
  }, [name]); <span class="cm">// Re-run when 'name' changes</span>

  <span class="kw">return</span> <span class="tag">&lt;div&gt;</span>{data}<span class="tag">&lt;/div&gt;</span>;
}

<span class="cm">// === VUE 3 (Composition API) ===</span>
<span class="kw">const</span> MyComponent = {
  <span class="fn">setup</span>(props) {
    <span class="kw">const</span> data = <span class="fn">ref</span>(<span class="kw">null</span>);

    <span class="fn">onMounted</span>(() => { <span class="cm">/* DOM is ready */</span> });
    <span class="fn">onUpdated</span>(() => { <span class="cm">/* DOM updated */</span> });
    <span class="fn">onUnmounted</span>(() => { <span class="cm">/* cleanup */</span> });

    <span class="fn">watch</span>(() => props.name, (newVal) => {
      <span class="fn">fetchData</span>(newVal).<span class="fn">then</span>(v => data.<span class="prop">value</span> = v);
    });

    <span class="kw">return</span> () => <span class="fn">h</span>(<span class="str">'div'</span>, data.<span class="prop">value</span>);
  }
};

<span class="cm">// === ANGULAR ===</span>
@<span class="fn">Component</span>({ <span class="prop">selector</span>: <span class="str">'my-comp'</span>, <span class="prop">template</span>: <span class="str">'&lt;div&gt;{{data}}&lt;/div&gt;'</span> })
<span class="kw">class</span> <span class="fn">MyComponent</span> <span class="kw">implements</span> OnInit, OnDestroy {
  @<span class="fn">Input</span>() name: string;
  data: any;

  <span class="fn">constructor</span>(<span class="kw">private</span> http: HttpClient) {} <span class="cm">// DI!</span>

  <span class="fn">ngOnInit</span>() { <span class="cm">/* fetch data */</span> }
  <span class="fn">ngOnChanges</span>(changes) { <span class="cm">/* input changed */</span> }
  <span class="fn">ngOnDestroy</span>() { <span class="cm">/* cleanup */</span> }
}</pre>
        </div>

        <h3>Rendering Pipeline</h3>

        <div class="diagram">
          <p style="font-weight: 600; color: var(--accent2); margin-bottom: 16px; font-size: 15px;">React Rendering Pipeline</p>
          <div class="diagram-row">
            <div class="diagram-box highlight">Trigger<br><small>setState / props</small></div>
            <div class="diagram-arrow">‚Üí</div>
            <div class="diagram-box green">Render Phase<br><small>Build VDOM tree</small></div>
            <div class="diagram-arrow">‚Üí</div>
            <div class="diagram-box orange">Reconciliation<br><small>Diff old vs new</small></div>
            <div class="diagram-arrow">‚Üí</div>
            <div class="diagram-box red">Commit Phase<br><small>Apply to DOM</small></div>
          </div>
          <p style="margin-top: 12px; font-size: 13px; color: var(--text2);">
            <strong style="color: var(--green);">Render Phase:</strong> Can be paused/interrupted (Fiber) | 
            <strong style="color: var(--red);">Commit Phase:</strong> Synchronous, cannot be interrupted
          </p>
        </div>

        <h3>Dependency Injection (Angular's Superpower)</h3>
        <p>Angular has a built-in DI system. Services are singletons by default:</p>

        <div class="code-block">
          <span class="code-label">Angular DI</span>
          <pre><span class="cm">// Service (injectable dependency)</span>
@<span class="fn">Injectable</span>({ <span class="prop">providedIn</span>: <span class="str">'root'</span> }) <span class="cm">// singleton across app</span>
<span class="kw">class</span> <span class="fn">UserService</span> {
  <span class="kw">private</span> users = <span class="fn">signal</span>&lt;User[]&gt;([]);

  <span class="fn">constructor</span>(<span class="kw">private</span> http: HttpClient) {} <span class="cm">// DI in DI!</span>

  <span class="fn">getUsers</span>() {
    <span class="kw">return</span> <span class="kw">this</span>.http.<span class="fn">get</span>&lt;User[]&gt;(<span class="str">'/api/users'</span>);
  }
}

<span class="cm">// Component requests the service</span>
@<span class="fn">Component</span>({ ... })
<span class="kw">class</span> <span class="fn">UserListComponent</span> {
  <span class="cm">// Angular creates & injects UserService automatically</span>
  <span class="fn">constructor</span>(<span class="kw">private</span> userService: UserService) {}

  <span class="fn">ngOnInit</span>() {
    <span class="kw">this</span>.userService.<span class="fn">getUsers</span>().<span class="fn">subscribe</span>(users => ...);
  }
}

<span class="cm">// Injector hierarchy (like scope chain):</span>
<span class="cm">// Platform Injector ‚Üí Root Injector ‚Üí Module ‚Üí Component</span>
<span class="cm">// Child injectors inherit from parent injectors</span></pre>
        </div>

        <h3>Template Compilation</h3>

        <div class="card card-blue">
          <div class="card-title">How Templates Become Code</div>
          <table class="comp-table">
            <tr>
              <th>Framework</th>
              <th>Template</th>
              <th>Compiles To</th>
              <th>When</th>
            </tr>
            <tr>
              <td>React</td>
              <td>JSX</td>
              <td>createElement() calls</td>
              <td>Build time (Babel)</td>
            </tr>
            <tr>
              <td>Vue</td>
              <td>.vue SFC templates</td>
              <td>Optimized render functions</td>
              <td>Build time (Vite)</td>
            </tr>
            <tr>
              <td>Angular</td>
              <td>HTML templates</td>
              <td>Ivy instructions</td>
              <td>Build time (ngc)</td>
            </tr>
          </table>
        </div>

        <h3>Hydration (SSR ‚Üí Client)</h3>
        <div class="code-block">
          <span class="code-label">Hydration Process</span>
          <pre><span class="cm">// Server renders HTML string:</span>
<span class="str">'&lt;div id="app"&gt;&lt;h1&gt;Hello&lt;/h1&gt;&lt;button&gt;Count: 0&lt;/button&gt;&lt;/div&gt;'</span>

<span class="cm">// Client receives pre-rendered HTML (fast first paint!)</span>
<span class="cm">// Then JavaScript loads and "hydrates":</span>

<span class="cm">// 1. Framework walks existing DOM nodes</span>
<span class="cm">// 2. Attaches event listeners</span>
<span class="cm">// 3. Connects reactivity system</span>
<span class="cm">// 4. Makes page interactive</span>

<span class="cm">// React: hydrateRoot(document.getElementById('app'), &lt;App /&gt;)</span>
<span class="cm">// Vue: createSSRApp(App).mount('#app')</span>
<span class="cm">// Angular: provideClientHydration()</span>

<span class="cm">// ‚ö†Ô∏è Hydration mismatch = bugs!</span>
<span class="cm">// If server HTML doesn't match client VDOM, you get errors</span></pre>
        </div>

        <div class="nav-bottom">
          <button class="btn btn-secondary" onclick="showSection('reactivity')">‚Üê Reactivity</button>
          <button class="btn btn-primary" onclick="showSection('comparison')">Next: Comparison ‚Üí</button>
        </div>
      </div>

      <!-- ==================== COMPARISON ==================== -->
      <div class="section" id="sec-comparison">
        <h2>‚öñÔ∏è React vs Vue vs Angular</h2>
        <p class="subtitle">Side-by-side comparison of internals.</p>

        <h3>Architecture Comparison</h3>
        <table class="comp-table">
          <tr>
            <th>Aspect</th>
            <th><span class="framework-tag tag-react">React</span></th>
            <th><span class="framework-tag tag-vue">Vue</span></th>
            <th><span class="framework-tag tag-angular">Angular</span></th>
          </tr>
          <tr>
            <td><strong>DOM Strategy</strong></td>
            <td>Virtual DOM (Fiber)</td>
            <td>Compiler-optimized VDOM</td>
            <td>Incremental DOM (Ivy)</td>
          </tr>
          <tr>
            <td><strong>Reactivity</strong></td>
            <td>setState (explicit)</td>
            <td>Proxy (automatic)</td>
            <td>Zone.js + Signals</td>
          </tr>
          <tr>
            <td><strong>Re-render Scope</strong></td>
            <td>Component + all children</td>
            <td>Only affected components</td>
            <td>Component tree (OnPush: selective)</td>
          </tr>
          <tr>
            <td><strong>Template</strong></td>
            <td>JSX (JS-centric)</td>
            <td>SFC templates (HTML-centric)</td>
            <td>HTML templates + directives</td>
          </tr>
          <tr>
            <td><strong>DI System</strong></td>
            <td>Context API (basic)</td>
            <td>provide/inject</td>
            <td>Full hierarchical DI</td>
          </tr>
          <tr>
            <td><strong>Compilation</strong></td>
            <td>JSX ‚Üí createElement</td>
            <td>Templates ‚Üí optimized render</td>
            <td>Templates ‚Üí Ivy instructions</td>
          </tr>
          <tr>
            <td><strong>Bundle Size</strong></td>
            <td>~42 KB gzip</td>
            <td>~33 KB gzip</td>
            <td>~65 KB gzip</td>
          </tr>
          <tr>
            <td><strong>Tree Shaking</strong></td>
            <td>Good</td>
            <td>Excellent</td>
            <td>Excellent (Ivy)</td>
          </tr>
        </table>

        <h3>Reactivity Model Comparison</h3>

        <div class="diagram">
          <div style="display: flex; gap: 30px; justify-content: center; flex-wrap: wrap; text-align: left;">
            <div style="flex: 1; min-width: 200px;">
              <p style="font-weight: 600; color: #61dafb; margin-bottom: 8px;">React: Pull-based</p>
              <div class="reactive-box">
                <div class="reactive-var">setState(newVal)</div>
                <div class="flow-line"></div>
                <div class="reactive-var">Re-render component</div>
                <div class="flow-line"></div>
                <div class="reactive-var">Diff entire subtree</div>
                <div class="flow-line"></div>
                <div class="reactive-var">Patch DOM</div>
              </div>
            </div>
            <div style="flex: 1; min-width: 200px;">
              <p style="font-weight: 600; color: #41b883; margin-bottom: 8px;">Vue: Push-based</p>
              <div class="reactive-box">
                <div class="reactive-var">state.x = newVal</div>
                <div class="flow-line"></div>
                <div class="reactive-var">Proxy intercepts SET</div>
                <div class="flow-line"></div>
                <div class="reactive-var">Notify exact watchers</div>
                <div class="flow-line"></div>
                <div class="reactive-var">Re-render ONLY those</div>
              </div>
            </div>
            <div style="flex: 1; min-width: 200px;">
              <p style="font-weight: 600; color: #dd0031; margin-bottom: 8px;">Angular: Dirty Check</p>
              <div class="reactive-box">
                <div class="reactive-var">Any async event</div>
                <div class="flow-line"></div>
                <div class="reactive-var">Zone.js detects it</div>
                <div class="flow-line"></div>
                <div class="reactive-var">Check ALL bindings</div>
                <div class="flow-line"></div>
                <div class="reactive-var">Update changed ones</div>
              </div>
            </div>
          </div>
        </div>

        <h3>When Each Approach Wins</h3>

        <div class="card card-green">
          <div class="card-title">React wins when...</div>
          <p style="font-size: 14px;">You need maximum flexibility, a huge ecosystem, and your team is comfortable with JS-centric patterns. The explicit setState model is simple to reason about.</p>
        </div>

        <div class="card card-green">
          <div class="card-title">Vue wins when...</div>
          <p style="font-size: 14px;">You want the best out-of-box performance with automatic optimizations. The compiler-informed VDOM means less manual memoization. Fine-grained reactivity = precise updates.</p>
        </div>

        <div class="card card-green">
          <div class="card-title">Angular wins when...</div>
          <p style="font-size: 14px;">You're building large enterprise apps and want everything built-in (router, forms, HTTP, DI, testing). The opinionated structure helps large teams stay consistent.</p>
        </div>

        <div class="nav-bottom">
          <button class="btn btn-secondary" onclick="showSection('architecture')">‚Üê Architecture</button>
          <button class="btn btn-primary" onclick="showSection('exercises')">Next: Exercises ‚Üí</button>
        </div>
      </div>

      <!-- ==================== EXERCISES ==================== -->
      <div class="section" id="sec-exercises">
        <h2>‚úèÔ∏è Coding Exercises</h2>
        <p class="subtitle">Hands-on practice implementing framework concepts from scratch.</p>

        <!-- Exercise 1 -->
        <div class="exercise">
          <div class="exercise-title">
            Exercise 1: Implement createElement
            <span class="exercise-badge badge-easy">Easy</span>
          </div>
          <p style="font-size: 14px; color: var(--text2);">Write a <code>createElement</code> function that returns a Virtual DOM node (plain object) with <code>type</code>, <code>props</code>, and <code>children</code>.</p>
          <div class="code-block">
            <pre><span class="cm">// Expected usage:</span>
<span class="kw">const</span> vdom = <span class="fn">createElement</span>(<span class="str">'div'</span>, { <span class="prop">id</span>: <span class="str">'app'</span> },
  <span class="fn">createElement</span>(<span class="str">'h1'</span>, <span class="kw">null</span>, <span class="str">'Hello'</span>),
  <span class="fn">createElement</span>(<span class="str">'p'</span>, { <span class="prop">class</span>: <span class="str">'text'</span> }, <span class="str">'World'</span>)
);

<span class="cm">// Expected output:</span>
<span class="cm">// { type: 'div', props: { id: 'app' }, children: [</span>
<span class="cm">//   { type: 'h1', props: {}, children: ['Hello'] },</span>
<span class="cm">//   { type: 'p', props: { class: 'text' }, children: ['World'] }</span>
<span class="cm">// ]}</span></pre>
          </div>
          <textarea class="code-editor" id="ex1-code">function createElement(type, props, ...children) {
  // Your code here

}</textarea>
          <div class="btn-group">
            <button class="btn btn-primary btn-small" onclick="checkExercise(1)">‚ñ∂ Run & Check</button>
            <button class="btn btn-secondary btn-small" onclick="showSolution(1)">Show Solution</button>
          </div>
          <div class="exercise-result" id="ex1-result"></div>
          <div class="accordion" id="sol1">
            <div class="accordion-header" onclick="toggleAccordion('sol1')">
              üí° Solution <span class="arrow">‚ñº</span>
            </div>
            <div class="accordion-body">
              <div class="accordion-content">
                <div class="code-block">
                  <pre><span class="kw">function</span> <span class="fn">createElement</span>(type, props, ...children) {
  <span class="kw">return</span> {
    type,
    props: props || {},
    children: children.<span class="fn">flat</span>()
  };
}</pre>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Exercise 2 -->
        <div class="exercise">
          <div class="exercise-title">
            Exercise 2: Render VDOM to Real DOM
            <span class="exercise-badge badge-medium">Medium</span>
          </div>
          <p style="font-size: 14px; color: var(--text2);">Write a <code>render</code> function that takes a virtual DOM node and returns a real DOM element. Handle text nodes (strings), props, and children recursively.</p>
          <div class="code-block">
            <pre><span class="cm">// Input: virtual DOM node</span>
<span class="cm">// Output: real DOM element</span>
<span class="cm">// Should handle: strings ‚Üí text nodes, objects ‚Üí elements</span>
<span class="cm">// Should set props as attributes (skip functions)</span>
<span class="cm">// Should recursively render children</span></pre>
          </div>
          <textarea class="code-editor" id="ex2-code">function render(vnode) {
  // Handle string/number ‚Üí text node
  
  // Create element from vnode.type
  
  // Set properties from vnode.props
  
  // Recursively render and append children
  
}</textarea>
          <div class="btn-group">
            <button class="btn btn-primary btn-small" onclick="checkExercise(2)">‚ñ∂ Run & Check</button>
            <button class="btn btn-secondary btn-small" onclick="showSolution(2)">Show Solution</button>
          </div>
          <div class="exercise-result" id="ex2-result"></div>
          <div class="accordion" id="sol2">
            <div class="accordion-header" onclick="toggleAccordion('sol2')">
              üí° Solution <span class="arrow">‚ñº</span>
            </div>
            <div class="accordion-body">
              <div class="accordion-content">
                <div class="code-block">
                  <pre><span class="kw">function</span> <span class="fn">render</span>(vnode) {
  <span class="cm">// Text node</span>
  <span class="kw">if</span> (<span class="kw">typeof</span> vnode === <span class="str">'string'</span> || <span class="kw">typeof</span> vnode === <span class="str">'number'</span>) {
    <span class="kw">return</span> document.<span class="fn">createTextNode</span>(String(vnode));
  }

  <span class="cm">// Create element</span>
  <span class="kw">const</span> el = document.<span class="fn">createElement</span>(vnode.type);

  <span class="cm">// Set props</span>
  <span class="kw">for</span> (<span class="kw">const</span> [key, val] <span class="kw">of</span> Object.<span class="fn">entries</span>(vnode.props || {})) {
    <span class="kw">if</span> (key.<span class="fn">startsWith</span>(<span class="str">'on'</span>)) {
      el.<span class="fn">addEventListener</span>(key.<span class="fn">slice</span>(<span class="num">2</span>).<span class="fn">toLowerCase</span>(), val);
    } <span class="kw">else</span> {
      el.<span class="fn">setAttribute</span>(key, val);
    }
  }

  <span class="cm">// Render children</span>
  (vnode.children || []).<span class="fn">forEach</span>(child => {
    el.<span class="fn">appendChild</span>(<span class="fn">render</span>(child));
  });

  <span class="kw">return</span> el;
}</pre>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Exercise 3 -->
        <div class="exercise">
          <div class="exercise-title">
            Exercise 3: Simple Diff Algorithm
            <span class="exercise-badge badge-medium">Medium</span>
          </div>
          <p style="font-size: 14px; color: var(--text2);">Write a <code>diff</code> function that compares two VNodes and returns a list of patches (changes needed).</p>
          <textarea class="code-editor" id="ex3-code" style="min-height: 200px;">function diff(oldVNode, newVNode) {
  const patches = [];
  
  // Case 1: Node was removed (newVNode is null/undefined)
  
  // Case 2: Text node changed
  
  // Case 3: Node type changed (replace entirely)
  
  // Case 4: Same type ‚Äî diff props and children
  
  return patches;
}</textarea>
          <div class="btn-group">
            <button class="btn btn-primary btn-small" onclick="checkExercise(3)">‚ñ∂ Run & Check</button>
            <button class="btn btn-secondary btn-small" onclick="showSolution(3)">Show Solution</button>
          </div>
          <div class="exercise-result" id="ex3-result"></div>
          <div class="accordion" id="sol3">
            <div class="accordion-header" onclick="toggleAccordion('sol3')">
              üí° Solution <span class="arrow">‚ñº</span>
            </div>
            <div class="accordion-body">
              <div class="accordion-content">
                <div class="code-block">
                  <pre><span class="kw">function</span> <span class="fn">diff</span>(oldNode, newNode, patches = [], path = <span class="str">''</span>) {
  <span class="kw">if</span> (!newNode) {
    patches.<span class="fn">push</span>({ <span class="prop">type</span>: <span class="str">'REMOVE'</span>, path });
  } <span class="kw">else if</span> (<span class="kw">typeof</span> oldNode !== <span class="kw">typeof</span> newNode) {
    patches.<span class="fn">push</span>({ <span class="prop">type</span>: <span class="str">'REPLACE'</span>, path, <span class="prop">newNode</span> });
  } <span class="kw">else if</span> (<span class="kw">typeof</span> oldNode === <span class="str">'string'</span>) {
    <span class="kw">if</span> (oldNode !== newNode) {
      patches.<span class="fn">push</span>({ <span class="prop">type</span>: <span class="str">'TEXT'</span>, path, <span class="prop">value</span>: newNode });
    }
  } <span class="kw">else if</span> (oldNode.type !== newNode.type) {
    patches.<span class="fn">push</span>({ <span class="prop">type</span>: <span class="str">'REPLACE'</span>, path, <span class="prop">newNode</span> });
  } <span class="kw">else</span> {
    <span class="cm">// Diff props</span>
    <span class="kw">const</span> allProps = { ...oldNode.props, ...newNode.props };
    <span class="kw">for</span> (<span class="kw">const</span> key <span class="kw">in</span> allProps) {
      <span class="kw">if</span> (oldNode.props[key] !== newNode.props[key]) {
        patches.<span class="fn">push</span>({
          <span class="prop">type</span>: <span class="str">'PROP'</span>, path,
          <span class="prop">key</span>, <span class="prop">value</span>: newNode.props[key]
        });
      }
    }
    <span class="cm">// Diff children</span>
    <span class="kw">const</span> max = Math.<span class="fn">max</span>(
      oldNode.children.length,
      newNode.children.length
    );
    <span class="kw">for</span> (<span class="kw">let</span> i = <span class="num">0</span>; i < max; i++) {
      <span class="fn">diff</span>(
        oldNode.children[i],
        newNode.children[i],
        patches,
        path + <span class="str">'.'</span> + i
      );
    }
  }
  <span class="kw">return</span> patches;
}</pre>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Exercise 4 -->
        <div class="exercise">
          <div class="exercise-title">
            Exercise 4: Build a Reactive System
            <span class="exercise-badge badge-hard">Hard</span>
          </div>
          <p style="font-size: 14px; color: var(--text2);">Implement Vue-style reactivity using <code>Proxy</code>. Create <code>reactive()</code>, <code>effect()</code>, <code>track()</code>, and <code>trigger()</code>.</p>
          <textarea class="code-editor" id="ex4-code" style="min-height: 250px;">let activeEffect = null;
const targetMap = new WeakMap();

function reactive(target) {
  // Return a Proxy that calls track on GET and trigger on SET
}

function effect(fn) {
  // Set activeEffect, run fn, then reset activeEffect
}

function track(target, key) {
  // If there's an activeEffect, store it as a dependency
}

function trigger(target, key) {
  // Run all effects that depend on target[key]
}</textarea>
          <div class="btn-group">
            <button class="btn btn-primary btn-small" onclick="checkExercise(4)">‚ñ∂ Run & Check</button>
            <button class="btn btn-secondary btn-small" onclick="showSolution(4)">Show Solution</button>
          </div>
          <div class="exercise-result" id="ex4-result"></div>
          <div class="accordion" id="sol4">
            <div class="accordion-header" onclick="toggleAccordion('sol4')">
              üí° Solution <span class="arrow">‚ñº</span>
            </div>
            <div class="accordion-body">
              <div class="accordion-content">
                <div class="code-block">
                  <pre><span class="kw">let</span> activeEffect = <span class="kw">null</span>;
<span class="kw">const</span> targetMap = <span class="kw">new</span> <span class="fn">WeakMap</span>();

<span class="kw">function</span> <span class="fn">reactive</span>(target) {
  <span class="kw">return new</span> <span class="fn">Proxy</span>(target, {
    <span class="fn">get</span>(obj, key) {
      <span class="fn">track</span>(obj, key);
      <span class="kw">return</span> obj[key];
    },
    <span class="fn">set</span>(obj, key, val) {
      obj[key] = val;
      <span class="fn">trigger</span>(obj, key);
      <span class="kw">return true</span>;
    }
  });
}

<span class="kw">function</span> <span class="fn">effect</span>(fn) {
  activeEffect = fn;
  <span class="fn">fn</span>(); <span class="cm">// Run once to collect deps</span>
  activeEffect = <span class="kw">null</span>;
}

<span class="kw">function</span> <span class="fn">track</span>(target, key) {
  <span class="kw">if</span> (!activeEffect) <span class="kw">return</span>;
  <span class="kw">let</span> depsMap = targetMap.<span class="fn">get</span>(target);
  <span class="kw">if</span> (!depsMap) targetMap.<span class="fn">set</span>(target, (depsMap = <span class="kw">new</span> <span class="fn">Map</span>()));
  <span class="kw">let</span> dep = depsMap.<span class="fn">get</span>(key);
  <span class="kw">if</span> (!dep) depsMap.<span class="fn">set</span>(key, (dep = <span class="kw">new</span> <span class="fn">Set</span>()));
  dep.<span class="fn">add</span>(activeEffect);
}

<span class="kw">function</span> <span class="fn">trigger</span>(target, key) {
  <span class="kw">const</span> depsMap = targetMap.<span class="fn">get</span>(target);
  <span class="kw">if</span> (!depsMap) <span class="kw">return</span>;
  <span class="kw">const</span> dep = depsMap.<span class="fn">get</span>(key);
  <span class="kw">if</span> (dep) dep.<span class="fn">forEach</span>(effect => <span class="fn">effect</span>());
}</pre>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Exercise 5 -->
        <div class="exercise">
          <div class="exercise-title">
            Exercise 5: Implement a Mini Component System
            <span class="exercise-badge badge-hard">Hard</span>
          </div>
          <p style="font-size: 14px; color: var(--text2);">Combine everything: create a tiny framework with <code>reactive state</code>, <code>render functions</code>, and <code>auto-updating DOM</code>.</p>
          <textarea class="code-editor" id="ex5-code" style="min-height: 250px;">function createApp(componentFn, container) {
  // 1. Create reactive state
  // 2. Set up effect that:
  //    a. Calls componentFn to get VDOM
  //    b. Renders VDOM to real DOM  
  //    c. Replaces container content
  // 3. When state changes, effect re-runs automatically
  
  // Return the reactive state so user can modify it
}

// Usage:
// const state = createApp((s) => {
//   return createElement('div', null,
//     createElement('h1', null, 'Count: ' + s.count),
//     createElement('button', { onclick: () => s.count++ }, '+1')
//   );
// }, document.getElementById('app'));</textarea>
          <div class="btn-group">
            <button class="btn btn-primary btn-small" onclick="checkExercise(5)">‚ñ∂ Run & Check</button>
            <button class="btn btn-secondary btn-small" onclick="showSolution(5)">Show Solution</button>
          </div>
          <div class="exercise-result" id="ex5-result"></div>
          <div class="accordion" id="sol5">
            <div class="accordion-header" onclick="toggleAccordion('sol5')">
              üí° Solution <span class="arrow">‚ñº</span>
            </div>
            <div class="accordion-body">
              <div class="accordion-content">
                <div class="code-block">
                  <pre><span class="kw">function</span> <span class="fn">createApp</span>(componentFn, container) {
  <span class="kw">const</span> state = <span class="fn">reactive</span>({ count: <span class="num">0</span> });

  <span class="fn">effect</span>(() => {
    <span class="cm">// Get VDOM from component</span>
    <span class="kw">const</span> vdom = <span class="fn">componentFn</span>(state);
    <span class="cm">// Render to real DOM</span>
    <span class="kw">const</span> dom = <span class="fn">render</span>(vdom);
    <span class="cm">// Replace container content</span>
    container.innerHTML = <span class="str">''</span>;
    container.<span class="fn">appendChild</span>(dom);
  });

  <span class="kw">return</span> state;
}

<span class="cm">// This is the essence of every framework!</span>
<span class="cm">// State ‚Üí VDOM ‚Üí DOM, reactively re-running.</span></pre>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div class="nav-bottom">
          <button class="btn btn-secondary" onclick="showSection('comparison')">‚Üê Comparison</button>
          <button class="btn btn-primary" onclick="showSection('quiz1')">Next: Quiz 1 ‚Üí</button>
        </div>
      </div>

      <!-- ==================== QUIZ 1 ==================== -->
      <div class="section" id="sec-quiz1">
        <h2>‚ùì Quiz: Virtual DOM & Diffing</h2>
        <p class="subtitle">Test your understanding of Virtual DOM concepts and reconciliation.</p>

        <div id="quiz1-container"></div>
        <div class="btn-group" style="justify-content: center; margin-top: 20px;">
          <button class="btn btn-primary" onclick="submitQuiz('quiz1')" id="quiz1-submit">Submit Answers</button>
          <button class="btn btn-secondary" onclick="resetQuiz('quiz1')" style="display:none" id="quiz1-reset">Try Again</button>
        </div>
        <div class="quiz-score" id="quiz1-score" style="display:none"></div>

        <div class="nav-bottom">
          <button class="btn btn-secondary" onclick="showSection('exercises')">‚Üê Exercises</button>
          <button class="btn btn-primary" onclick="showSection('quiz2')">Next: Quiz 2 ‚Üí</button>
        </div>
      </div>

      <!-- ==================== QUIZ 2 ==================== -->
      <div class="section" id="sec-quiz2">
        <h2>‚ùì Quiz: Reactivity Systems</h2>
        <p class="subtitle">Test your knowledge of how frameworks detect and respond to state changes.</p>

        <div id="quiz2-container"></div>
        <div class="btn-group" style="justify-content: center; margin-top: 20px;">
          <button class="btn btn-primary" onclick="submitQuiz('quiz2')" id="quiz2-submit">Submit Answers</button>
          <button class="btn btn-secondary" onclick="resetQuiz('quiz2')" style="display:none" id="quiz2-reset">Try Again</button>
        </div>
        <div class="quiz-score" id="quiz2-score" style="display:none"></div>

        <div class="nav-bottom">
          <button class="btn btn-secondary" onclick="showSection('quiz1')">‚Üê Quiz 1</button>
          <button class="btn btn-primary" onclick="showSection('quiz3')">Next: Quiz 3 ‚Üí</button>
        </div>
      </div>

      <!-- ==================== QUIZ 3 ==================== -->
      <div class="section" id="sec-quiz3">
        <h2>‚ùì Quiz: Architecture & Advanced</h2>
        <p class="subtitle">Advanced questions about framework architecture, compilation, and performance.</p>

        <div id="quiz3-container"></div>
        <div class="btn-group" style="justify-content: center; margin-top: 20px;">
          <button class="btn btn-primary" onclick="submitQuiz('quiz3')" id="quiz3-submit">Submit Answers</button>
          <button class="btn btn-secondary" onclick="resetQuiz('quiz3')" style="display:none" id="quiz3-reset">Try Again</button>
        </div>
        <div class="quiz-score" id="quiz3-score" style="display:none"></div>

        <div class="nav-bottom">
          <button class="btn btn-secondary" onclick="showSection('quiz2')">‚Üê Quiz 2</button>
          <button class="btn btn-primary" onclick="showSection('pitfalls')">Next: Pitfalls ‚Üí</button>
        </div>
      </div>

      <!-- ==================== PITFALLS ==================== -->
      <div class="section" id="sec-pitfalls">
        <h2>‚ö†Ô∏è Common Mistakes & Pitfalls</h2>
        <p class="subtitle">Mistakes that even experienced developers make ‚Äî and how to avoid them.</p>

        <!-- Pitfall 1 -->
        <div class="pitfall">
          <div class="pitfall-header">‚õî #1: Using array index as key</div>
          <p style="font-size: 14px; color: var(--text2);">Using array indices as keys defeats the purpose of keys entirely when items can be reordered, inserted, or deleted.</p>
          <div class="code-block">
            <pre><span class="cm">// ‚ùå BAD: index as key</span>
{items.<span class="fn">map</span>((item, index) => (
  <span class="tag">&lt;ListItem</span> <span class="attr">key</span>={index} <span class="attr">data</span>={item} <span class="tag">/&gt;</span>
))}

<span class="cm">// Problem: If you add an item at the start...</span>
<span class="cm">// Before: [A(key=0), B(key=1), C(key=2)]</span>
<span class="cm">// After:  [X(key=0), A(key=1), B(key=2), C(key=3)]</span>
<span class="cm">// React thinks key=0 changed from A‚ÜíX (wrong! it's a new item)</span>
<span class="cm">// Every item gets needlessly re-rendered!</span></pre>
          </div>
          <div class="fix-header">‚úÖ Fix: Use stable, unique identifiers</div>
          <div class="code-block">
            <pre><span class="cm">// ‚úÖ GOOD: unique ID as key</span>
{items.<span class="fn">map</span>(item => (
  <span class="tag">&lt;ListItem</span> <span class="attr">key</span>={item.id} <span class="attr">data</span>={item} <span class="tag">/&gt;</span>
))}
<span class="cm">// React correctly matches items across renders</span></pre>
          </div>
        </div>

        <!-- Pitfall 2 -->
        <div class="pitfall">
          <div class="pitfall-header">‚õî #2: Mutating state directly (React)</div>
          <p style="font-size: 14px; color: var(--text2);">React uses reference equality to detect changes. Mutating objects/arrays in-place means React sees the same reference and skips re-rendering.</p>
          <div class="code-block">
            <pre><span class="cm">// ‚ùå BAD: Mutating state directly</span>
<span class="kw">const</span> [items, setItems] = <span class="fn">useState</span>([<span class="str">'a'</span>, <span class="str">'b'</span>]);

<span class="kw">function</span> <span class="fn">addItem</span>() {
  items.<span class="fn">push</span>(<span class="str">'c'</span>);     <span class="cm">// Mutates the SAME array</span>
  <span class="fn">setItems</span>(items);    <span class="cm">// Same reference! React: "nothing changed ü§∑"</span>
}

<span class="cm">// ‚ùå Also bad with objects:</span>
<span class="kw">const</span> [user, setUser] = <span class="fn">useState</span>({ <span class="prop">name</span>: <span class="str">'Alice'</span> });
user.name = <span class="str">'Bob'</span>;
<span class="fn">setUser</span>(user);  <span class="cm">// Same reference! No re-render!</span></pre>
          </div>
          <div class="fix-header">‚úÖ Fix: Always create new references</div>
          <div class="code-block">
            <pre><span class="cm">// ‚úÖ GOOD: Create new array/object</span>
<span class="fn">setItems</span>([...items, <span class="str">'c'</span>]);           <span class="cm">// new array</span>
<span class="fn">setUser</span>({ ...user, <span class="prop">name</span>: <span class="str">'Bob'</span> }); <span class="cm">// new object</span></pre>
          </div>
        </div>

        <!-- Pitfall 3 -->
        <div class="pitfall">
          <div class="pitfall-header">‚õî #3: Unnecessary re-renders from unstable references</div>
          <p style="font-size: 14px; color: var(--text2);">Creating new objects/functions inside render creates new references every time, causing child components to always re-render.</p>
          <div class="code-block">
            <pre><span class="cm">// ‚ùå BAD: New object every render</span>
<span class="kw">function</span> <span class="fn">Parent</span>() {
  <span class="kw">return</span> (
    <span class="tag">&lt;Child</span>
      <span class="attr">style</span>={{ <span class="prop">color</span>: <span class="str">'red'</span> }}  <span class="cm">// new object every render!</span>
      <span class="attr">onClick</span>={() => {}}      <span class="cm">// new function every render!</span>
      <span class="attr">data</span>={items.<span class="fn">filter</span>(filterFn)}  <span class="cm">// new array every render!</span>
    <span class="tag">/&gt;</span>
  );
}</pre>
          </div>
          <div class="fix-header">‚úÖ Fix: useMemo and useCallback</div>
          <div class="code-block">
            <pre><span class="cm">// ‚úÖ GOOD: Stable references</span>
<span class="kw">function</span> <span class="fn">Parent</span>() {
  <span class="kw">const</span> style = <span class="fn">useMemo</span>(() => ({ <span class="prop">color</span>: <span class="str">'red'</span> }), []);
  <span class="kw">const</span> handleClick = <span class="fn">useCallback</span>(() => {}, []);
  <span class="kw">const</span> filtered = <span class="fn">useMemo</span>(() => items.<span class="fn">filter</span>(filterFn), [items]);

  <span class="kw">return</span> <span class="tag">&lt;Child</span> <span class="attr">style</span>={style} <span class="attr">onClick</span>={handleClick} <span class="attr">data</span>={filtered} <span class="tag">/&gt;</span>;
}</pre>
          </div>
        </div>

        <!-- Pitfall 4 -->
        <div class="pitfall">
          <div class="pitfall-header">‚õî #4: Not using Vue's reactive correctly</div>
          <p style="font-size: 14px; color: var(--text2);">Destructuring a reactive object breaks reactivity because you get plain values, not proxied properties.</p>
          <div class="code-block">
            <pre><span class="cm">// ‚ùå BAD: Destructuring breaks reactivity</span>
<span class="kw">const</span> state = <span class="fn">reactive</span>({ <span class="prop">count</span>: <span class="num">0</span>, <span class="prop">name</span>: <span class="str">'Vue'</span> });
<span class="kw">let</span> { count, name } = state; <span class="cm">// Just plain values now!</span>
count++; <span class="cm">// Not reactive! Just a local variable</span>

<span class="cm">// ‚ùå BAD: Replacing reactive ref value</span>
<span class="kw">let</span> myRef = <span class="fn">ref</span>(<span class="num">0</span>);
myRef = <span class="fn">ref</span>(<span class="num">1</span>); <span class="cm">// Oops! Lost the reactive connection</span></pre>
          </div>
          <div class="fix-header">‚úÖ Fix: Use toRefs or keep the reactive container</div>
          <div class="code-block">
            <pre><span class="cm">// ‚úÖ GOOD: Use toRefs to maintain reactivity</span>
<span class="kw">const</span> { count, name } = <span class="fn">toRefs</span>(state);
count.<span class="prop">value</span>++; <span class="cm">// Still reactive!</span>

<span class="cm">// ‚úÖ Or just access through the reactive object</span>
state.count++; <span class="cm">// Works perfectly</span></pre>
          </div>
        </div>

        <!-- Pitfall 5 -->
        <div class="pitfall">
          <div class="pitfall-header">‚õî #5: Angular: Not unsubscribing from Observables</div>
          <p style="font-size: 14px; color: var(--text2);">Forgetting to unsubscribe causes memory leaks. The component is destroyed but the subscription keeps running.</p>
          <div class="code-block">
            <pre><span class="cm">// ‚ùå BAD: Memory leak!</span>
<span class="fn">ngOnInit</span>() {
  <span class="kw">this</span>.dataService.getData().<span class="fn">subscribe</span>(data => {
    <span class="kw">this</span>.data = data; <span class="cm">// Keeps running after component destroys!</span>
  });
}</pre>
          </div>
          <div class="fix-header">‚úÖ Fix: Clean up subscriptions</div>
          <div class="code-block">
            <pre><span class="cm">// ‚úÖ Option 1: takeUntilDestroyed (Angular 16+)</span>
<span class="fn">ngOnInit</span>() {
  <span class="kw">this</span>.dataService.getData()
    .<span class="fn">pipe</span>(<span class="fn">takeUntilDestroyed</span>(<span class="kw">this</span>.destroyRef))
    .<span class="fn">subscribe</span>(data => <span class="kw">this</span>.data = data);
}

<span class="cm">// ‚úÖ Option 2: async pipe in template</span>
<span class="cm">// &lt;div&gt;{{ data$ | async }}&lt;/div&gt;</span>
<span class="cm">// Auto-unsubscribes when component is destroyed!</span></pre>
          </div>
        </div>

        <!-- Pitfall 6 -->
        <div class="pitfall">
          <div class="pitfall-header">‚õî #6: Misunderstanding React's batching</div>
          <p style="font-size: 14px; color: var(--text2);">Multiple setState calls in an event handler don't cause multiple re-renders ‚Äî React batches them.</p>
          <div class="code-block">
            <pre><span class="cm">// How many re-renders happen here?</span>
<span class="kw">function</span> <span class="fn">handleClick</span>() {
  <span class="fn">setCount</span>(count + <span class="num">1</span>);     <span class="cm">// queued</span>
  <span class="fn">setName</span>(<span class="str">'Alice'</span>);         <span class="cm">// queued</span>
  <span class="fn">setFlag</span>(<span class="kw">true</span>);            <span class="cm">// queued</span>
  <span class="cm">// Answer: ONE re-render (React 18+ batches all)</span>
}

<span class="cm">// ‚ö†Ô∏è But stale closure is still a risk:</span>
<span class="kw">function</span> <span class="fn">handleClick</span>() {
  <span class="fn">setCount</span>(count + <span class="num">1</span>);  <span class="cm">// count = 0, sets to 1</span>
  <span class="fn">setCount</span>(count + <span class="num">1</span>);  <span class="cm">// count STILL = 0! Sets to 1 again!</span>
  <span class="cm">// Final count: 1, not 2!</span>
}

<span class="cm">// ‚úÖ Fix: Use functional updates</span>
<span class="fn">setCount</span>(prev => prev + <span class="num">1</span>); <span class="cm">// prev = 0, sets to 1</span>
<span class="fn">setCount</span>(prev => prev + <span class="num">1</span>); <span class="cm">// prev = 1, sets to 2 ‚úì</span></pre>
          </div>
        </div>

        <!-- Pitfall 7 -->
        <div class="pitfall">
          <div class="pitfall-header">‚õî #7: Overusing Virtual DOM / Not using framework optimizations</div>
          <div class="code-block">
            <pre><span class="cm">// ‚ùå React: Entire list re-renders when ONE item changes</span>
<span class="kw">function</span> <span class="fn">TodoList</span>({ todos }) {
  <span class="kw">return</span> todos.<span class="fn">map</span>(todo => <span class="tag">&lt;TodoItem</span> <span class="attr">todo</span>={todo} <span class="tag">/&gt;</span>);
  <span class="cm">// If parent re-renders, ALL TodoItems re-render!</span>
}

<span class="cm">// ‚úÖ Fix: React.memo prevents re-render if props unchanged</span>
<span class="kw">const</span> TodoItem = React.<span class="fn">memo</span>(({ todo }) => {
  <span class="kw">return</span> <span class="tag">&lt;div&gt;</span>{todo.text}<span class="tag">&lt;/div&gt;</span>;
});
<span class="cm">// Now only the CHANGED item re-renders</span>

<span class="cm">// Vue does this AUTOMATICALLY because of its reactivity system!</span>
<span class="cm">// Each component only re-renders when its own deps change.</span></pre>
          </div>
        </div>

        <div class="nav-bottom">
          <button class="btn btn-secondary" onclick="showSection('quiz3')">‚Üê Quiz 3</button>
          <button class="btn btn-primary" onclick="showSection('cheatsheet')">Next: Cheat Sheet ‚Üí</button>
        </div>
      </div>

      <!-- ==================== CHEAT SHEET ==================== -->
      <div class="section" id="sec-cheatsheet">
        <h2>üìã Framework Internals Cheat Sheet</h2>
        <p class="subtitle">Quick reference for interviews and day-to-day development.</p>

        <div class="cheat-grid">
          <div class="cheat-item" style="border-top: 3px solid var(--accent);">
            <h4 style="color: var(--accent2);">üå≥ Virtual DOM</h4>
            <ul style="font-size: 13px; color: var(--text2); line-height: 2; padding-left: 16px;">
              <li>Lightweight JS object mirroring real DOM</li>
              <li>Created by <code>createElement()</code> / <code>h()</code></li>
              <li>Has: <code>type</code>, <code>props</code>, <code>children</code></li>
              <li>Cheap to create & compare (vs real DOM)</li>
              <li>React & Vue use it; Angular does NOT</li>
              <li>Enables declarative UI programming</li>
            </ul>
          </div>

          <div class="cheat-item" style="border-top: 3px solid var(--green);">
            <h4 style="color: var(--green);">üîÑ Reconciliation</h4>
            <ul style="font-size: 13px; color: var(--text2); line-height: 2; padding-left: 16px;">
              <li>O(n) heuristic diffing algorithm</li>
              <li><strong>Rule 1:</strong> Different type ‚Üí full rebuild</li>
              <li><strong>Rule 2:</strong> Keys identify stable elements</li>
              <li>Compares props to detect changes</li>
              <li>Children diffed recursively</li>
              <li>Produces minimal set of DOM patches</li>
            </ul>
          </div>

          <div class="cheat-item" style="border-top: 3px solid var(--orange);">
            <h4 style="color: var(--orange);">‚ö° React Reactivity</h4>
            <ul style="font-size: 13px; color: var(--text2); line-height: 2; padding-left: 16px;">
              <li>Explicit: must call <code>setState</code>/<code>setX</code></li>
              <li>Re-renders component + all children</li>
              <li>Batches updates within event handlers</li>
              <li><code>useMemo</code> / <code>memo</code> to prevent waste</li>
              <li>Fiber enables interruptible rendering</li>
              <li>Concurrent features: startTransition, Suspense</li>
            </ul>
          </div>

          <div class="cheat-item" style="border-top: 3px solid #41b883;">
            <h4 style="color: #41b883;">‚ö° Vue Reactivity</h4>
            <ul style="font-size: 13px; color: var(--text2); line-height: 2; padding-left: 16px;">
              <li>Automatic: <code>Proxy</code>-based tracking</li>
              <li><code>ref()</code> for primitives, <code>reactive()</code> for objects</li>
              <li>Dependency tracked at get, triggered at set</li>
              <li>Fine-grained: only affected components update</li>
              <li>Compiler marks static vs dynamic (patch flags)</li>
              <li><code>computed()</code> = cached derived values</li>
            </ul>
          </div>

          <div class="cheat-item" style="border-top: 3px solid #dd0031;">
            <h4 style="color: #dd0031;">‚ö° Angular Change Detection</h4>
            <ul style="font-size: 13px; color: var(--text2); line-height: 2; padding-left: 16px;">
              <li>Zone.js patches all async APIs</li>
              <li>Default: checks entire component tree</li>
              <li><code>OnPush</code>: only check if @Input changes</li>
              <li>Signals (v16+): fine-grained updates</li>
              <li>No VDOM: Incremental DOM (Ivy)</li>
              <li>Ahead-of-Time (AOT) compilation</li>
            </ul>
          </div>

          <div class="cheat-item" style="border-top: 3px solid var(--pink);">
            <h4 style="color: var(--pink);">üèóÔ∏è Architecture</h4>
            <ul style="font-size: 13px; color: var(--text2); line-height: 2; padding-left: 16px;">
              <li>Component model: reusable, composable UI</li>
              <li>Lifecycle: mount ‚Üí update ‚Üí unmount</li>
              <li>React: hooks replace class lifecycles</li>
              <li>Angular: full DI system (hierarchical)</li>
              <li>SSR + Hydration for performance</li>
              <li>Template ‚Üí compiled render instructions</li>
            </ul>
          </div>

          <div class="cheat-item" style="border-top: 3px solid var(--blue);">
            <h4 style="color: var(--blue);">üîë Key Interview Answers</h4>
            <ul style="font-size: 13px; color: var(--text2); line-height: 2; padding-left: 16px;">
              <li>"VDOM is a JS representation of the DOM tree"</li>
              <li>"Diffing uses O(n) heuristics: type + keys"</li>
              <li>"React is pull-based, Vue is push-based"</li>
              <li>"Fiber breaks rendering into interruptible units"</li>
              <li>"Keys must be stable, unique identifiers"</li>
              <li>"Angular uses Zone.js for dirty checking"</li>
            </ul>
          </div>

          <div class="cheat-item" style="border-top: 3px solid var(--cyan);">
            <h4 style="color: var(--cyan);">üö´ Never Do</h4>
            <ul style="font-size: 13px; color: var(--text2); line-height: 2; padding-left: 16px;">
              <li>‚ùå Array index as key (for dynamic lists)</li>
              <li>‚ùå Mutate React state directly</li>
              <li>‚ùå Destructure Vue reactive (without toRefs)</li>
              <li>‚ùå Forget to unsubscribe in Angular</li>
              <li>‚ùå Create objects/functions in render</li>
              <li>‚ùå Ignore hydration mismatches</li>
            </ul>
          </div>
        </div>

        <h3>üî• One-Liner Interview Answers</h3>

        <div class="card">
          <div class="accordion" id="interview1">
            <div class="accordion-header" onclick="toggleAccordion('interview1')">
              "What is the Virtual DOM?" <span class="arrow">‚ñº</span>
            </div>
            <div class="accordion-body"><div class="accordion-content">
              <p style="font-size: 14px;">A lightweight JavaScript object representation of the actual DOM tree. Frameworks use it to batch and minimize expensive real DOM operations by computing diffs in memory first.</p>
            </div></div>
          </div>

          <div class="accordion" id="interview2">
            <div class="accordion-header" onclick="toggleAccordion('interview2')">
              "How does React's reconciliation work?" <span class="arrow">‚ñº</span>
            </div>
            <div class="accordion-body"><div class="accordion-content">
              <p style="font-size: 14px;">React uses an O(n) diffing algorithm with two heuristics: (1) elements of different types produce different trees, and (2) keys provide stable identity for list items. It compares the old and new VDOM trees, generates a minimal set of DOM operations, and applies them in the commit phase.</p>
            </div></div>
          </div>

          <div class="accordion" id="interview3">
            <div class="accordion-header" onclick="toggleAccordion('interview3')">
              "What is React Fiber?" <span class="arrow">‚ñº</span>
            </div>
            <div class="accordion-body"><div class="accordion-content">
              <p style="font-size: 14px;">Fiber is React's reconciliation engine (since v16) that breaks rendering work into small units that can be paused, prioritized, and resumed. It uses a linked-list data structure instead of the previous recursive stack-based approach, enabling concurrent rendering features like startTransition and Suspense.</p>
            </div></div>
          </div>

          <div class="accordion" id="interview4">
            <div class="accordion-header" onclick="toggleAccordion('interview4')">
              "How does Vue's reactivity system work?" <span class="arrow">‚ñº</span>
            </div>
            <div class="accordion-body"><div class="accordion-content">
              <p style="font-size: 14px;">Vue 3 uses JavaScript Proxy objects to intercept property access (get) and mutation (set). During component rendering, accessed reactive properties are tracked as dependencies. When a dependency is later modified, Vue automatically re-renders only the components that depend on that specific property ‚Äî making it fine-grained and efficient.</p>
            </div></div>
          </div>

          <div class="accordion" id="interview5">
            <div class="accordion-header" onclick="toggleAccordion('interview5')">
              "Why does Angular use Zone.js?" <span class="arrow">‚ñº</span>
            </div>
            <div class="accordion-body"><div class="accordion-content">
              <p style="font-size: 14px;">Zone.js monkey-patches all asynchronous browser APIs (setTimeout, addEventListener, Promise, XHR, etc.) so Angular can automatically know when async operations complete. After each async task, Angular triggers change detection across the component tree to update bindings. This is being supplemented by Signals in newer Angular versions for more precise reactivity.</p>
            </div></div>
          </div>

          <div class="accordion" id="interview6">
            <div class="accordion-header" onclick="toggleAccordion('interview6')">
              "What are Signals and why are frameworks adopting them?" <span class="arrow">‚ñº</span>
            </div>
            <div class="accordion-body"><div class="accordion-content">
              <p style="font-size: 14px;">Signals are reactive primitives that hold a value and automatically notify subscribers when that value changes. They enable fine-grained reactivity without needing a Virtual DOM diff ‚Äî updates go directly to the affected DOM nodes. Angular, Solid, Preact, and Qwik have adopted them; Vue's ref/computed system is conceptually similar. They represent a convergence toward more precise, efficient reactivity.</p>
            </div></div>
          </div>
        </div>

        <div class="nav-bottom">
          <button class="btn btn-secondary" onclick="showSection('pitfalls')">‚Üê Pitfalls</button>
          <button class="btn btn-green" onclick="showSection('intro')">üè† Back to Start</button>
        </div>
      </div>

    </div>
  </main>
</div>

<script>
// ==================== APP STATE ====================
const completedSections = new Set();
const allSections = ['intro','vdom','reconciliation','reactivity','architecture','comparison','exercises','quiz1','quiz2','quiz3','pitfalls','cheatsheet'];

// ==================== NAVIGATION ====================
function showSection(id) {
  document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
  document.getElementById('sec-' + id).classList.add('active');

  document.querySelectorAll('.nav-item').forEach(n => n.classList.remove('active'));
  const navItem = document.querySelector(`.nav-item[data-section="${id}"]`);
  if (navItem) navItem.classList.add('active');

  completedSections.add(id);
  updateProgress();
  closeSidebar();
  window.scrollTo(0, 0);
}

function updateProgress() {
  const total = allSections.length;
  const done = completedSections.size;
  const pct = (done / total) * 100;
  document.getElementById('progressFill').style.width = pct + '%';
  document.getElementById('progressText').textContent = `${done} / ${total} completed`;

  document.querySelectorAll('.nav-item').forEach(item => {
    const sec = item.dataset.section;
    if (completedSections.has(sec)) {
      item.classList.add('completed');
    }
  });
}

function toggleSidebar() {
  document.getElementById('sidebar').classList.toggle('open');
}

function closeSidebar() {
  document.getElementById('sidebar').classList.remove('open');
}

// ==================== ACCORDION ====================
function toggleAccordion(id) {
  document.getElementById(id).classList.toggle('open');
}

function showSolution(num) {
  document.getElementById('sol' + num).classList.add('open');
}

// ==================== VDOM DEMO ====================
function createElement(type, props, ...children) {
  return { type, props: props || {}, children: children.flat() };
}

function render(vnode) {
  if (typeof vnode === 'string' || typeof vnode === 'number') {
    return document.createTextNode(String(vnode));
  }
  const el = document.createElement(vnode.type);
  for (const [key, val] of Object.entries(vnode.props || {})) {
    if (key.startsWith('on') && typeof val === 'function') {
      el.addEventListener(key.slice(2).toLowerCase(), val);
    } else {
      el.setAttribute(key, val);
    }
  }
  (vnode.children || []).forEach(child => {
    el.appendChild(render(child));
  });
  return el;
}

function demoCreateElement() {
  const vdom = createElement('div', { class: 'container', id: 'app' },
    createElement('h1', { style: 'color: #6c5ce7' }, 'Virtual DOM!'),
    createElement('p', null, 'This object represents the UI'),
    createElement('button', { class: 'btn' }, 'Click me')
  );

  document.getElementById('vdom-output').textContent = JSON.stringify(vdom, (key, val) => {
    if (typeof val === 'function') return '[Function]';
    return val;
  }, 2);
}

function demoRenderVDOM() {
  const vdom = createElement('div', { style: 'padding: 16px; background: #1a1d27; border-radius: 8px; border: 1px solid #2e3348;' },
    createElement('h3', { style: 'color: #6c5ce7; margin: 0 0 8px 0; font-size: 18px;' }, 'üéâ Rendered from VDOM!'),
    createElement('p', { style: 'color: #a0a4b8; margin: 0 0 12px 0; font-size: 14px;' }, 'This real DOM was created from a virtual DOM object.'),
    createElement('span', { style: 'display: inline-block; padding: 4px 12px; background: rgba(0,184,148,0.15); color: #00b894; border-radius: 4px; font-size: 13px;' }, '‚úì Successfully mounted')
  );

  const target = document.getElementById('vdom-render-target');
  target.innerHTML = '';
  target.appendChild(render(vdom));
}

function demoClearVDOM() {
  document.getElementById('vdom-output').textContent = 'Click "Run createElement()" to see the Virtual DOM object...';
  document.getElementById('vdom-render-target').innerHTML = '';
}

// ==================== DIFF DEMO ====================
let diffStep = -1;
let diffInterval;

function resetDiffDemo() {
  clearInterval(diffInterval);
  diffStep = -1;
  const ids = ['old-div','old-h1','old-p','old-btn','new-div','new-h1','new-span','new-btn'];
  ids.forEach(id => {
    const el = document.getElementById(id);
    el.className = 'vdom-node';
  });
  document.querySelectorAll('#diff-steps .step-dot').forEach(d => {
    d.className = 'step-dot';
  });
  document.getElementById('diff-output').textContent = 'Click "Run Diff Animation" to watch the algorithm work...';
}

function runDiffDemo() {
  resetDiffDemo();
  const steps = [
    {
      msg: 'üîç Step 1: Compare root nodes ‚Äî both are "div" ‚Üí same type, keep it!',
      highlight: [['old-div', 'active-node'], ['new-div', 'active-node']]
    },
    {
      msg: 'üîç Step 2: Compare first child ‚Äî both are "h1" ‚Üí same type, keep it!',
      highlight: [['old-h1', 'active-node'], ['new-h1', 'active-node']]
    },
    {
      msg: '‚ö° Step 3: Compare second child ‚Äî "p" vs "span" ‚Üí DIFFERENT TYPE! Replace!',
      highlight: [['old-p', 'diff-node'], ['new-span', 'diff-node']]
    },
    {
      msg: 'üîç Step 4: Compare third child ‚Äî both are "btn" ‚Üí same type, keep it!',
      highlight: [['old-btn', 'active-node'], ['new-btn', 'active-node']]
    },
    {
      msg: '‚úÖ Step 5: Done! Only 1 DOM operation needed: replace <p> with <span>. 3 nodes left untouched!',
      highlight: [['old-p', 'diff-node'], ['new-span', 'new-node']]
    }
  ];

  let step = 0;
  diffInterval = setInterval(() => {
    if (step >= steps.length) {
      clearInterval(diffInterval);
      return;
    }

    // Reset all nodes
    const ids = ['old-div','old-h1','old-p','old-btn','new-div','new-h1','new-span','new-btn'];
    ids.forEach(id => { document.getElementById(id).className = 'vdom-node'; });

    // Apply highlights
    steps[step].highlight.forEach(([id, cls]) => {
      document.getElementById(id).classList.add(cls);
    });

    // Update dots
    document.querySelectorAll('#diff-steps .step-dot').forEach((d, i) => {
      d.className = 'step-dot';
      if (i < step) d.classList.add('done');
      if (i === step) d.classList.add('active');
    });

    document.getElementById('diff-output').textContent = steps[step].msg;
    step++;
  }, 1500);
}

// ==================== REACTIVITY DEMO ====================
let reactiveState;
let reactiveLogEl;
let logCount = 0;

function initReactivity() {
  reactiveLogEl = document.getElementById('reactive-log');

  let activeEffect = null;
  const targetMap = new WeakMap();

  function track(target, key) {
    if (!activeEffect) return;
    let depsMap = targetMap.get(target);
    if (!depsMap) targetMap.set(target, (depsMap = new Map()));
    let dep = depsMap.get(key);
    if (!dep) depsMap.set(key, (dep = new Set()));
    dep.add(activeEffect);
  }

  function trigger(target, key) {
    const depsMap = targetMap.get(target);
    if (!depsMap) return;
    const dep = depsMap.get(key);
    if (dep) dep.forEach(eff => eff());
  }

  function reactive(target) {
    return new Proxy(target, {
      get(obj, key) {
        track(obj, key);
        return obj[key];
      },
      set(obj, key, val) {
        const oldVal = obj[key];
        obj[key] = val;
        if (oldVal !== val) trigger(obj, key);
        return true;
      }
    });
  }

  function effect(fn) {
    activeEffect = fn;
    fn();
    activeEffect = null;
  }

  reactiveState = reactive({ name: 'Alice', age: 25 });

  // Effect 1: greeting
  effect(() => {
    const greeting = `Hello, ${reactiveState.name}! You are ${reactiveState.age} years old.`;
    document.getElementById('reactive-output').textContent = greeting;
    addLog('effect:greeting', greeting);
  });

  // Effect 2: age category
  effect(() => {
    const category = reactiveState.age >= 18 ? 'Adult' : 'Minor';
    addLog('effect:category', `${reactiveState.name} is: ${category}`);
  });
}

function updateReactiveState(key, value) {
  if (reactiveState) {
    addLog('SET', `state.${key} = "${value}"`);
    reactiveState[key] = value;
  }
}

function addLog(action, value) {
  logCount++;
  const time = new Date().toLocaleTimeString();
  const entry = document.createElement('div');
  entry.className = 'log-entry';
  entry.innerHTML = `<span class="timestamp">[${time}]</span> <span class="action">${action}</span> ‚Üí <span class="value">${value}</span>`;
  if (reactiveLogEl) {
    reactiveLogEl.prepend(entry);
    if (reactiveLogEl.children.length > 20) {
      reactiveLogEl.removeChild(reactiveLogEl.lastChild);
    }
  }
}

// ==================== EXERCISES ====================
function checkExercise(num) {
  const code = document.getElementById('ex' + num + '-code').value;
  const resultEl = document.getElementById('ex' + num + '-result');

  try {
    let passed = false;
    let message = '';

    if (num === 1) {
      const fn = new Function(code + '\nreturn createElement;')();
      const result = fn('div', { id: 'app' }, fn('h1', null, 'Hello'), fn('p', { class: 'text' }, 'World'));
      passed = result.type === 'div' && result.props.id === 'app' && result.children.length === 2 && result.children[0].type === 'h1';
      message = passed ? '‚úÖ Perfect! createElement works correctly!' : '‚ùå Not quite. Check that you return { type, props, children }';
    }
    else if (num === 2) {
      const fn = new Function(code + '\nreturn render;')();
      const vnode = { type: 'div', props: { id: 'test' }, children: ['Hello'] };
      const result = fn(vnode);
      passed = result instanceof HTMLElement && result.tagName === 'DIV' && result.id === 'test' && result.textContent === 'Hello';
      message = passed ? '‚úÖ Excellent! Your render function creates real DOM from VDOM!' : '‚ùå Check: handle strings as text nodes, set props as attributes, recurse on children.';
    }
    else if (num === 3) {
      const fn = new Function(code + '\nreturn diff;')();
      const old1 = { type: 'div', props: {}, children: ['Hello'] };
      const new1 = { type: 'div', props: {}, children: ['World'] };
      const patches = fn(old1, new1);
      passed = Array.isArray(patches) && patches.length > 0 && patches.some(p => p.type === 'TEXT' || p.type === 'REPLACE');
      message = passed ? '‚úÖ Great! Your diff algorithm detects changes!' : '‚ùå Make sure you return an array of patch objects. Handle text changes with type "TEXT".';
    }
    else if (num === 4) {
      const fn = new Function(code + `
        const state = reactive({ count: 0, name: 'test' });
        let output = [];
        effect(() => { output.push('effect:' + state.count); });
        state.count = 1;
        state.count = 2;
        return { reactive, effect, track, trigger, output };
      `)();
      passed = fn.output.length === 3 && fn.output[0] === 'effect:0' && fn.output[1] === 'effect:1' && fn.output[2] === 'effect:2';
      message = passed ? '‚úÖ Amazing! Your reactivity system works! Effects auto-run when state changes!' : '‚ùå Effects should auto-track dependencies on first run and re-run when those dependencies change. Output: ' + JSON.stringify(fn.output);
    }
    else if (num === 5) {
      message = '‚úÖ Run your mental model: createApp should combine reactive() + effect() + render(). The effect re-runs whenever state changes, producing new VDOM and re-rendering. Check the solution to compare!';
      passed = true;
    }

    resultEl.className = 'exercise-result ' + (passed ? 'pass' : 'fail');
    resultEl.textContent = message;
    resultEl.style.display = 'block';

  } catch (e) {
    resultEl.className = 'exercise-result fail';
    resultEl.textContent = '‚ùå Error: ' + e.message;
    resultEl.style.display = 'block';
  }
}

// ==================== QUIZZES ====================
const quizData = {
  quiz1: [
    {
      q: 'What is the Virtual DOM?',
      options: [
        'A shadow copy of the browser\'s rendering engine',
        'A lightweight JavaScript object representation of the real DOM',
        'A hidden iframe that mirrors the main page',
        'A WebAssembly module for fast DOM manipulation'
      ],
      correct: 1,
      explanation: 'The Virtual DOM is simply a plain JS object tree that describes the UI. It\'s lightweight and cheap to create/compare, unlike real DOM nodes which have 200+ properties.'
    },
    {
      q: 'What is the time complexity of React\'s diffing algorithm?',
      options: ['O(1)', 'O(log n)', 'O(n)', 'O(n¬≥)'],
      correct: 2,
      explanation: 'React uses O(n) heuristic diffing with two assumptions: different element types produce different trees, and keys identify stable elements across renders. The general tree diff is O(n¬≥), which is why heuristics are needed.'
    },
    {
      q: 'What happens when React encounters a node whose type changed from <div> to <span>?',
      options: [
        'It updates only the tag name',
        'It destroys the entire old subtree and creates a new one',
        'It wraps both in a fragment',
        'It morphs the node\'s prototype'
      ],
      correct: 1,
      explanation: 'This is Heuristic Rule 1: when the root element type changes, React tears down the old tree completely (including state of child components) and builds a new one from scratch.'
    },
    {
      q: 'Why should you NOT use array index as a key in React?',
      options: [
        'It causes syntax errors',
        'Keys must be strings, not numbers',
        'It leads to incorrect matching when items are reordered, inserted, or deleted',
        'React ignores numeric keys'
      ],
      correct: 2,
      explanation: 'Index-based keys cause React to match elements by position rather than identity. If you insert an item at the beginning, every index shifts and React thinks all items changed, causing unnecessary re-renders and potential state bugs.'
    },
    {
      q: 'What did React Fiber change about reconciliation?',
      options: [
        'It eliminated the need for Virtual DOM',
        'It made rendering synchronous for speed',
        'It enabled breaking rendering work into pausable, prioritized units',
        'It replaced JSX with template strings'
      ],
      correct: 2,
      explanation: 'Fiber replaced the synchronous stack-based reconciler with one that uses a linked-list of "fiber" nodes. Work can be paused, prioritized, and resumed across multiple frames, enabling concurrent rendering features.'
    },
    {
      q: 'How does Vue 3 optimize its Virtual DOM diffing compared to React?',
      options: [
        'Vue doesn\'t use a Virtual DOM at all',
        'Vue uses the same algorithm as React',
        'Vue\'s compiler marks static vs dynamic content with patch flags at compile time',
        'Vue skips diffing and always replaces the entire DOM'
      ],
      correct: 2,
      explanation: 'Vue 3\'s template compiler analyzes templates at build time and marks dynamic bindings with "patch flags." This lets the runtime skip static subtrees during diffing and only check properties that can actually change ‚Äî a compiler-informed VDOM approach.'
    },
    {
      q: 'Which framework does NOT use a Virtual DOM?',
      options: ['React', 'Vue', 'Angular', 'Preact'],
      correct: 2,
      explanation: 'Angular uses Incremental DOM (via the Ivy renderer). Templates compile into step-by-step instructions that directly create and update DOM nodes without maintaining a separate virtual tree in memory.'
    },
    {
      q: 'What are the two phases of React rendering?',
      options: [
        'Parse and Execute',
        'Render (build VDOM) and Commit (apply to DOM)',
        'Compile and Interpret',
        'Mount and Hydrate'
      ],
      correct: 1,
      explanation: 'The Render phase builds the new VDOM tree and computes diffs (can be paused with Fiber). The Commit phase applies all DOM changes synchronously and runs effects/lifecycle methods. The Render phase is pure; the Commit phase has side effects.'
    }
  ],
  quiz2: [
    {
      q: 'How does React know when to re-render a component?',
      options: [
        'It watches all variables for changes automatically',
        'You must explicitly call setState or a state setter function',
        'It uses Object.observe() on all state',
        'It polls the DOM for changes every 16ms'
      ],
      correct: 1,
      explanation: 'React uses an explicit "pull" model. You call setState/setX to schedule a re-render. React does NOT detect changes automatically ‚Äî if you mutate a variable without calling the setter, React doesn\'t know about it.'
    },
    {
      q: 'What JavaScript feature does Vue 3 use for reactivity?',
      options: [
        'Object.defineProperty (getters/setters)',
        'MutationObserver',
        'Proxy',
        'Object.observe'
      ],
      correct: 2,
      explanation: 'Vue 3 uses Proxy for reactivity (Vue 2 used Object.defineProperty). Proxy can intercept all property operations including addition/deletion, which Object.defineProperty cannot. This is why Vue 3 can detect new properties being added to reactive objects.'
    },
    {
      q: 'In Vue\'s reactivity system, when is dependency tracking (track) called?',
      options: [
        'When a reactive property is SET (written to)',
        'When a reactive property is GET (read/accessed)',
        'When the component mounts',
        'When the user clicks something'
      ],
      correct: 1,
      explanation: 'Dependencies are tracked during GET (reading). When an effect runs and reads reactive properties, Vue records which properties were accessed. Later, when those properties change (SET), Vue knows exactly which effects to re-run.'
    },
    {
      q: 'What does Zone.js do in Angular?',
      options: [
        'Provides CSS zone/containment for components',
        'Handles routing between zones/pages',
        'Monkey-patches async APIs to detect when async operations complete',
        'Creates isolated JavaScript execution environments'
      ],
      correct: 2,
      explanation: 'Zone.js wraps all browser async APIs (setTimeout, addEventListener, Promise, XHR, etc.) so Angular knows when async operations finish. After each async task, Angular automatically triggers change detection to check all component bindings for updates.'
    },
    {
      q: 'What is the output? (React)\n\nconst [count, setCount] = useState(0);\nfunction handleClick() {\n  setCount(count + 1);\n  setCount(count + 1);\n  setCount(count + 1);\n}',
      options: [
        'count becomes 3',
        'count becomes 1 (stale closure)',
        'count becomes 0 (no update)',
        'Throws an error'
      ],
      correct: 1,
      explanation: 'All three calls use the same stale closure value of count (0). So each call sets count to 0+1=1. To fix this, use the functional form: setCount(prev => prev + 1) which always uses the latest value.'
    },
    {
      q: 'What is Angular\'s OnPush change detection strategy?',
      options: [
        'Angular pushes all changes to a queue',
        'Components are only checked when @Input references change, events fire, or manually triggered',
        'Angular uses push notifications instead of polling',
        'OnPush sends changes to a web worker'
      ],
      correct: 1,
      explanation: 'OnPush optimizes change detection by only checking a component when: (1) its @Input bindings get new references, (2) an event handler fires within the component, (3) an async pipe emits, or (4) change detection is manually triggered. This skips checking entire subtrees.'
    },
    {
      q: 'What are Signals in the context of modern frameworks?',
      options: [
        'Event emitters for component communication',
        'Browser APIs for interrupting JavaScript execution',
        'Reactive primitives that hold values and auto-notify subscribers when changed',
        'WebSocket-based real-time data streams'
      ],
      correct: 2,
      explanation: 'Signals are reactive values that track dependencies and notify subscribers. They enable fine-grained reactivity without needing Virtual DOM diffing ‚Äî changes propagate directly to affected DOM nodes. Angular, Solid, Preact, and Qwik use them. Vue\'s ref() is conceptually similar.'
    },
    {
      q: 'Why does destructuring a Vue reactive object break reactivity?',
      options: [
        'JavaScript doesn\'t support destructuring Proxy objects',
        'Destructuring creates plain value copies, losing the Proxy wrapper',
        'Vue throws an error when you destructure',
        'It doesn\'t break reactivity; this is a myth'
      ],
      correct: 1,
      explanation: 'When you do `let { count } = reactive({ count: 0 })`, count is now just the number 0 ‚Äî a plain value with no Proxy connection. Changes to this variable won\'t trigger reactivity. Use toRefs() to create individual refs that maintain the reactive connection.'
    }
  ],
  quiz3: [
    {
      q: 'What does JSX compile to?',
      options: [
        'HTML template literals',
        'React.createElement() function calls',
        'document.createElement() calls',
        'Web Components'
      ],
      correct: 1,
      explanation: 'Babel (or SWC) compiles JSX syntax into React.createElement(type, props, ...children) calls. In React 17+, it uses the new JSX transform which imports jsx() from react/jsx-runtime instead. The result is Virtual DOM objects.'
    },
    {
      q: 'What is hydration in the context of SSR?',
      options: [
        'Downloading CSS files after page load',
        'Attaching event listeners and reactivity to server-rendered HTML',
        'Converting HTML to JSON for API responses',
        'Compressing JavaScript bundles with gzip'
      ],
      correct: 1,
      explanation: 'Hydration is the process where the client-side framework takes over server-rendered HTML by walking the existing DOM, attaching event handlers, and connecting the reactivity system ‚Äî making the page interactive without re-rendering from scratch.'
    },
    {
      q: 'What is Angular\'s Ivy renderer?',
      options: [
        'A CSS framework bundled with Angular',
        'A Virtual DOM implementation',
        'A compilation and rendering pipeline that generates tree-shakeable instructions',
        'A testing framework for Angular'
      ],
      correct: 2,
      explanation: 'Ivy (Angular 9+) compiles templates into a series of instructions (createElement, updateText, etc.) that are tree-shakeable. Unlike VDOM, it uses Incremental DOM ‚Äî instructions create/update DOM directly without maintaining a separate virtual tree. Unused features don\'t end up in the bundle.'
    },
    {
      q: 'What is the main advantage of Vue\'s compiler-informed VDOM?',
      options: [
        'It eliminates the need for JavaScript',
        'It skips diffing entirely',
        'It marks dynamic parts at compile time so diffing only checks what can change',
        'It converts VDOM to Web Components'
      ],
      correct: 2,
      explanation: 'Vue 3\'s compiler adds "patch flags" to VNodes indicating what type of binding is dynamic (text, class, style, etc.). Static content is hoisted outside the render function. The diffing algorithm uses these hints to skip static nodes and only compare dynamic properties.'
    },
    {
      q: 'In React, which phase can be interrupted by Fiber?',
      options: [
        'The Commit phase (DOM updates)',
        'The Render phase (building VDOM and diffing)',
        'Both phases',
        'Neither ‚Äî Fiber doesn\'t enable interruption'
      ],
      correct: 1,
      explanation: 'The Render phase (building new VDOM, computing diffs) can be paused, aborted, and resumed by Fiber. The Commit phase (actually applying DOM changes, running effects) is always synchronous and uninterruptible to avoid showing partial UI updates.'
    },
    {
      q: 'What does Angular\'s Dependency Injection (DI) system do?',
      options: [
        'Injects CSS dependencies into components',
        'Automatically provides service instances to components that request them via constructor parameters',
        'Injects script tags into the HTML document',
        'Downloads dependencies from npm at runtime'
      ],
      correct: 1,
      explanation: 'Angular\'s DI creates and manages service instances. When a component declares a dependency in its constructor, Angular\'s injector either provides an existing instance or creates a new one. Injectors form a hierarchy (platform ‚Üí root ‚Üí module ‚Üí component) allowing scoped services.'
    },
    {
      q: 'React batches state updates in event handlers. In React 18+, what else is batched?',
      options: [
        'Nothing else ‚Äî only event handlers',
        'All state updates everywhere: timeouts, promises, native event handlers',
        'Only updates inside useEffect',
        'Only synchronous updates'
      ],
      correct: 1,
      explanation: 'React 18 introduced "automatic batching" which batches ALL state updates regardless of where they originate ‚Äî setTimeout, Promise.then, native event handlers, etc. In React 17 and earlier, only React event handlers were batched.'
    },
    {
      q: 'A developer notices their React app re-renders the entire list when one item changes. What\'s the best optimization?',
      options: [
        'Remove all keys from list items',
        'Switch to Angular',
        'Wrap list item components with React.memo() and ensure stable props',
        'Use dangerouslySetInnerHTML for the list'
      ],
      correct: 2,
      explanation: 'React.memo() is a higher-order component that skips re-rendering if props haven\'t changed (shallow comparison). Combined with stable keys and memoized callbacks/values (useCallback, useMemo), this ensures only the changed list item re-renders.'
    }
  ]
};

function renderQuiz(quizId) {
  const container = document.getElementById(quizId + '-container');
  const questions = quizData[quizId];
  let html = '';

  questions.forEach((q, i) => {
    html += `<div class="quiz-question" id="${quizId}-q${i}">
      <div class="quiz-q"><span class="q-num">Q${i+1}.</span> <span>${q.q}</span></div>
      <div class="quiz-options">`;
    q.options.forEach((opt, j) => {
      html += `<div class="quiz-option" data-quiz="${quizId}" data-q="${i}" data-opt="${j}" onclick="selectOption(this)">${opt}</div>`;
    });
    html += `</div>
      <div class="quiz-explanation" id="${quizId}-exp${i}">üí° ${q.explanation}</div>
    </div>`;
  });

  container.innerHTML = html;
}

function selectOption(el) {
  const quiz = el.dataset.quiz;
  const q = el.dataset.q;
  // Remove selected from siblings
  el.parentElement.querySelectorAll('.quiz-option').forEach(o => o.classList.remove('selected'));
  el.classList.add('selected');
}

function submitQuiz(quizId) {
  const questions = quizData[quizId];
  let score = 0;

  questions.forEach((q, i) => {
    const container = document.getElementById(`${quizId}-q${i}`);
    const options = container.querySelectorAll('.quiz-option');
    const selected = container.querySelector('.quiz-option.selected');

    options.forEach((opt, j) => {
      opt.style.pointerEvents = 'none';
      if (j === q.correct) {
        opt.classList.add('correct');
      }
      if (opt.classList.contains('selected') && j !== q.correct) {
        opt.classList.add('wrong');
      }
    });

    if (selected && parseInt(selected.dataset.opt) === q.correct) {
      score++;
    }

    document.getElementById(`${quizId}-exp${i}`).classList.add('show');
  });

  const scoreEl = document.getElementById(`${quizId}-score`);
  const pct = Math.round((score / questions.length) * 100);
  let grade = pct >= 90 ? 'üèÜ Outstanding!' : pct >= 70 ? 'üëè Great job!' : pct >= 50 ? 'üìö Good effort, review the explanations!' : 'üí™ Keep studying, you\'ll get there!';

  scoreEl.innerHTML = `
    <div class="score-num">${score}/${questions.length}</div>
    <p style="font-size: 18px; margin: 8px 0;">${pct}%</p>
    <p style="color: var(--text2);">${grade}</p>
  `;
  scoreEl.style.display = 'block';

  document.getElementById(`${quizId}-submit`).style.display = 'none';
  document.getElementById(`${quizId}-reset`).style.display = 'inline-flex';
}

function resetQuiz(quizId) {
  renderQuiz(quizId);
  document.getElementById(`${quizId}-score`).style.display = 'none';
  document.getElementById(`${quizId}-submit`).style.display = 'inline-flex';
  document.getElementById(`${quizId}-reset`).style.display = 'none';
}

// ==================== INIT ====================
document.addEventListener('DOMContentLoaded', () => {
  renderQuiz('quiz1');
  renderQuiz('quiz2');
  renderQuiz('quiz3');
  initReactivity();
  updateProgress();
});
</script>
</body>
</html>