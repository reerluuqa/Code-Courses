<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Advanced TypeScript Mastery</title>
<style>
:root {
  --bg: #0d1117;
  --bg2: #161b22;
  --bg3: #1c2333;
  --bg4: #252d3a;
  --accent: #3b82f6;
  --accent2: #8b5cf6;
  --accent3: #06b6d4;
  --green: #10b981;
  --red: #ef4444;
  --orange: #f59e0b;
  --text: #e6edf3;
  --text2: #8b949e;
  --text3: #6e7681;
  --border: #30363d;
  --code-bg: #0d1117;
  --keyword: #ff7b72;
  --string: #a5d6ff;
  --type: #79c0ff;
  --func: #d2a8ff;
  --comment: #8b949e;
  --number: #79c0ff;
  --operator: #ff7b72;
  --interface: #ffa657;
}

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
  background: var(--bg);
  color: var(--text);
  line-height: 1.7;
  overflow-x: hidden;
}

/* Scrollbar */
::-webkit-scrollbar { width: 8px; height: 8px; }
::-webkit-scrollbar-track { background: var(--bg2); }
::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }
::-webkit-scrollbar-thumb:hover { background: var(--text3); }

/* Header */
.header {
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
  padding: 30px 20px;
  text-align: center;
  border-bottom: 2px solid var(--accent);
  position: sticky;
  top: 0;
  z-index: 100;
}

.header h1 {
  font-size: 2rem;
  background: linear-gradient(90deg, var(--accent), var(--accent2), var(--accent3));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  margin-bottom: 8px;
}

.header p { color: var(--text2); font-size: 0.95rem; }

.progress-bar-container {
  margin-top: 15px;
  background: var(--bg);
  border-radius: 10px;
  height: 8px;
  max-width: 600px;
  margin-left: auto;
  margin-right: auto;
  overflow: hidden;
}

.progress-bar {
  height: 100%;
  background: linear-gradient(90deg, var(--accent), var(--accent2));
  border-radius: 10px;
  transition: width 0.5s ease;
  width: 0%;
}

.progress-text {
  color: var(--text2);
  font-size: 0.8rem;
  margin-top: 5px;
}

/* Navigation */
.nav {
  background: var(--bg2);
  border-bottom: 1px solid var(--border);
  padding: 0 20px;
  overflow-x: auto;
  white-space: nowrap;
  position: sticky;
  top: 108px;
  z-index: 99;
}

.nav-inner {
  display: flex;
  gap: 0;
  max-width: 1400px;
  margin: 0 auto;
}

.nav-btn {
  background: none;
  border: none;
  color: var(--text2);
  padding: 14px 20px;
  cursor: pointer;
  font-size: 0.9rem;
  border-bottom: 2px solid transparent;
  transition: all 0.3s;
  white-space: nowrap;
  font-family: inherit;
}

.nav-btn:hover { color: var(--text); background: var(--bg3); }
.nav-btn.active {
  color: var(--accent);
  border-bottom-color: var(--accent);
  background: var(--bg3);
}

.nav-btn .nav-icon { margin-right: 6px; }

/* Main */
.main {
  max-width: 1100px;
  margin: 0 auto;
  padding: 30px 20px 80px;
}

.section { display: none; }
.section.active { display: block; animation: fadeIn 0.4s ease; }

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(15px); }
  to { opacity: 1; transform: translateY(0); }
}

/* Section Headers */
.section-header {
  margin-bottom: 30px;
  padding-bottom: 20px;
  border-bottom: 1px solid var(--border);
}

.section-header h2 {
  font-size: 1.8rem;
  margin-bottom: 8px;
  color: var(--text);
}

.section-header .subtitle {
  color: var(--text2);
  font-size: 1rem;
}

/* Lesson Cards */
.lesson {
  background: var(--bg2);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 28px;
  margin-bottom: 25px;
}

.lesson h3 {
  font-size: 1.3rem;
  margin-bottom: 15px;
  color: var(--accent3);
  display: flex;
  align-items: center;
  gap: 10px;
}

.lesson h4 {
  font-size: 1.05rem;
  margin: 20px 0 10px;
  color: var(--accent);
}

.lesson p, .lesson li {
  color: var(--text2);
  margin-bottom: 10px;
  font-size: 0.95rem;
}

.lesson ul, .lesson ol {
  padding-left: 25px;
  margin-bottom: 15px;
}

.lesson li { margin-bottom: 6px; }

/* Code Blocks */
.code-block {
  background: var(--code-bg);
  border: 1px solid var(--border);
  border-radius: 8px;
  margin: 15px 0;
  overflow: hidden;
}

.code-header {
  background: var(--bg4);
  padding: 8px 15px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  border-bottom: 1px solid var(--border);
}

.code-header span {
  font-size: 0.8rem;
  color: var(--text2);
  font-family: 'Fira Code', 'Cascadia Code', monospace;
}

.copy-btn {
  background: var(--bg3);
  border: 1px solid var(--border);
  color: var(--text2);
  padding: 3px 10px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 0.75rem;
  transition: all 0.2s;
}

.copy-btn:hover { background: var(--accent); color: white; border-color: var(--accent); }

pre {
  padding: 18px;
  overflow-x: auto;
  font-family: 'Fira Code', 'Cascadia Code', 'Consolas', monospace;
  font-size: 0.88rem;
  line-height: 1.6;
  tab-size: 2;
}

/* Inline code */
code.inline {
  background: var(--bg4);
  padding: 2px 7px;
  border-radius: 4px;
  font-family: 'Fira Code', 'Cascadia Code', monospace;
  font-size: 0.88rem;
  color: var(--accent3);
}

/* Syntax Highlighting */
.kw { color: var(--keyword); }
.str { color: var(--string); }
.tp { color: var(--type); }
.fn { color: var(--func); }
.cm { color: var(--comment); font-style: italic; }
.num { color: var(--number); }
.op { color: var(--operator); }
.iface { color: var(--interface); }
.param { color: #ffa198; }
.prop { color: #79c0ff; }
.dec { color: #ffa657; }
.gen { color: #d2a8ff; }

/* Callout boxes */
.callout {
  border-radius: 8px;
  padding: 18px 20px;
  margin: 18px 0;
  border-left: 4px solid;
}

.callout.info {
  background: rgba(59, 130, 246, 0.08);
  border-color: var(--accent);
}

.callout.warning {
  background: rgba(245, 158, 11, 0.08);
  border-color: var(--orange);
}

.callout.danger {
  background: rgba(239, 68, 68, 0.08);
  border-color: var(--red);
}

.callout.success {
  background: rgba(16, 185, 129, 0.08);
  border-color: var(--green);
}

.callout-title {
  font-weight: 700;
  margin-bottom: 6px;
  font-size: 0.9rem;
}

.callout.info .callout-title { color: var(--accent); }
.callout.warning .callout-title { color: var(--orange); }
.callout.danger .callout-title { color: var(--red); }
.callout.success .callout-title { color: var(--green); }
.callout p { margin-bottom: 5px; font-size: 0.9rem; }

/* Quiz Styles */
.quiz-container {
  background: var(--bg2);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 25px;
  margin-bottom: 25px;
}

.quiz-question {
  font-size: 1.05rem;
  margin-bottom: 18px;
  color: var(--text);
  font-weight: 600;
}

.quiz-question .q-number {
  color: var(--accent);
  margin-right: 8px;
}

.quiz-options { list-style: none; padding: 0; }

.quiz-option {
  background: var(--bg3);
  border: 2px solid var(--border);
  border-radius: 8px;
  padding: 12px 18px;
  margin-bottom: 10px;
  cursor: pointer;
  transition: all 0.2s;
  font-size: 0.93rem;
  display: flex;
  align-items: flex-start;
  gap: 10px;
}

.quiz-option:hover { border-color: var(--accent); background: var(--bg4); }

.quiz-option.selected { border-color: var(--accent); background: rgba(59,130,246,0.1); }
.quiz-option.correct { border-color: var(--green); background: rgba(16,185,129,0.1); }
.quiz-option.incorrect { border-color: var(--red); background: rgba(239,68,68,0.1); }

.quiz-option .opt-letter {
  min-width: 28px;
  height: 28px;
  border-radius: 50%;
  background: var(--bg);
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 700;
  font-size: 0.8rem;
  color: var(--text2);
  flex-shrink: 0;
}

.quiz-option.correct .opt-letter { background: var(--green); color: white; }
.quiz-option.incorrect .opt-letter { background: var(--red); color: white; }

.quiz-explanation {
  background: var(--bg3);
  border-radius: 8px;
  padding: 15px;
  margin-top: 12px;
  display: none;
  font-size: 0.9rem;
  color: var(--text2);
  border-left: 3px solid var(--accent);
}

.quiz-explanation.show { display: block; animation: fadeIn 0.3s ease; }

.quiz-btn {
  background: var(--accent);
  color: white;
  border: none;
  padding: 10px 25px;
  border-radius: 8px;
  cursor: pointer;
  font-size: 0.95rem;
  font-weight: 600;
  margin-top: 12px;
  transition: all 0.2s;
}

.quiz-btn:hover { background: #2563eb; transform: translateY(-1px); }
.quiz-btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }

.score-display {
  background: linear-gradient(135deg, var(--bg3), var(--bg4));
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 25px;
  text-align: center;
  margin-top: 20px;
}

.score-display .score-number {
  font-size: 3rem;
  font-weight: 800;
  background: linear-gradient(90deg, var(--accent), var(--green));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}

/* Exercise Styles */
.exercise {
  background: var(--bg2);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 25px;
  margin-bottom: 25px;
}

.exercise h3 {
  color: var(--accent2);
  margin-bottom: 10px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.exercise .difficulty {
  font-size: 0.75rem;
  padding: 3px 10px;
  border-radius: 12px;
  font-weight: 600;
}

.difficulty.easy { background: rgba(16,185,129,0.15); color: var(--green); }
.difficulty.medium { background: rgba(245,158,11,0.15); color: var(--orange); }
.difficulty.hard { background: rgba(239,68,68,0.15); color: var(--red); }

.exercise-prompt {
  color: var(--text2);
  margin-bottom: 15px;
  font-size: 0.95rem;
}

.exercise textarea {
  width: 100%;
  min-height: 150px;
  background: var(--code-bg);
  border: 1px solid var(--border);
  border-radius: 8px;
  color: var(--text);
  font-family: 'Fira Code', 'Cascadia Code', monospace;
  font-size: 0.88rem;
  padding: 15px;
  resize: vertical;
  line-height: 1.6;
}

.exercise textarea:focus { outline: none; border-color: var(--accent); }

.reveal-btn {
  background: var(--bg4);
  border: 1px solid var(--border);
  color: var(--text2);
  padding: 8px 18px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 0.88rem;
  margin-top: 10px;
  transition: all 0.2s;
}

.reveal-btn:hover { background: var(--accent2); color: white; border-color: var(--accent2); }

.solution {
  display: none;
  margin-top: 15px;
}

.solution.show { display: block; animation: fadeIn 0.3s ease; }

/* Cheat Sheet */
.cheat-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(480px, 1fr));
  gap: 20px;
}

.cheat-card {
  background: var(--bg2);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 22px;
}

.cheat-card h4 {
  color: var(--accent3);
  margin-bottom: 12px;
  font-size: 1rem;
  display: flex;
  align-items: center;
  gap: 8px;
}

.cheat-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 0.85rem;
}

.cheat-table th, .cheat-table td {
  padding: 8px 12px;
  text-align: left;
  border-bottom: 1px solid var(--border);
}

.cheat-table th {
  color: var(--accent);
  font-weight: 600;
  background: var(--bg3);
}

.cheat-table td { color: var(--text2); }
.cheat-table td:first-child {
  color: var(--accent3);
  font-family: 'Fira Code', monospace;
  font-size: 0.82rem;
}

/* Pitfall Cards */
.pitfall {
  background: var(--bg2);
  border: 1px solid var(--border);
  border-radius: 12px;
  padding: 22px;
  margin-bottom: 20px;
  border-left: 4px solid var(--red);
}

.pitfall h4 {
  color: var(--red);
  margin-bottom: 10px;
  display: flex;
  align-items: center;
  gap: 8px;
}

.pitfall .fix {
  border-left: 4px solid var(--green);
  margin-top: 12px;
}

.vs-container {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
  margin: 12px 0;
}

.vs-bad, .vs-good {
  border-radius: 8px;
  overflow: hidden;
}

.vs-label {
  padding: 6px 12px;
  font-size: 0.8rem;
  font-weight: 700;
}

.vs-bad .vs-label { background: rgba(239,68,68,0.2); color: var(--red); }
.vs-good .vs-label { background: rgba(16,185,129,0.2); color: var(--green); }

/* Tabs inside sections */
.sub-tabs {
  display: flex;
  gap: 0;
  border-bottom: 1px solid var(--border);
  margin-bottom: 25px;
  overflow-x: auto;
}

.sub-tab {
  background: none;
  border: none;
  color: var(--text2);
  padding: 10px 18px;
  cursor: pointer;
  font-size: 0.88rem;
  border-bottom: 2px solid transparent;
  transition: all 0.2s;
  white-space: nowrap;
  font-family: inherit;
}

.sub-tab:hover { color: var(--text); }
.sub-tab.active { color: var(--accent2); border-bottom-color: var(--accent2); }

.sub-content { display: none; }
.sub-content.active { display: block; animation: fadeIn 0.3s ease; }

/* Badges */
.badge {
  display: inline-block;
  padding: 2px 8px;
  border-radius: 4px;
  font-size: 0.75rem;
  font-weight: 600;
}

.badge.ts { background: rgba(49,120,198,0.2); color: #3178c6; }
.badge.new { background: rgba(16,185,129,0.15); color: var(--green); }

/* Responsive */
@media (max-width: 768px) {
  .header h1 { font-size: 1.5rem; }
  .main { padding: 20px 15px 60px; }
  .lesson, .quiz-container, .exercise { padding: 18px; }
  .cheat-grid { grid-template-columns: 1fr; }
  .vs-container { grid-template-columns: 1fr; }
  .nav-btn { padding: 12px 14px; font-size: 0.82rem; }
  pre { font-size: 0.8rem; padding: 12px; }
}

/* Animations */
.bounce { animation: bounce 0.5s ease; }
@keyframes bounce {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}

/* Topic progress indicators */
.topic-progress {
  display: flex;
  gap: 8px;
  flex-wrap: wrap;
  margin-top: 10px;
}

.topic-dot {
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: var(--border);
  transition: background 0.3s;
}

.topic-dot.completed { background: var(--green); }
.topic-dot.current { background: var(--accent); animation: pulse 2s infinite; }

@keyframes pulse {
  0%, 100% { box-shadow: 0 0 0 0 rgba(59,130,246,0.4); }
  50% { box-shadow: 0 0 0 6px rgba(59,130,246,0); }
}

/* Collapsible */
.collapsible-header {
  cursor: pointer;
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 0;
}

.collapsible-header:hover { color: var(--accent); }
.collapsible-content { display: none; padding-top: 5px; }
.collapsible-content.open { display: block; animation: fadeIn 0.3s ease; }
.chevron { transition: transform 0.3s; font-size: 0.8rem; }
.chevron.open { transform: rotate(90deg); }
</style>
</head>
<body>

<div class="header">
  <h1>‚ö° Advanced TypeScript Mastery</h1>
  <p>From intermediate to expert ‚Äî master the type system that powers enterprise apps</p>
  <div class="progress-bar-container">
    <div class="progress-bar" id="mainProgress"></div>
  </div>
  <div class="progress-text" id="progressText">0 / 8 sections completed</div>
</div>

<nav class="nav">
  <div class="nav-inner">
    <button class="nav-btn active" onclick="showSection('intro')"><span class="nav-icon">üó∫Ô∏è</span>Roadmap</button>
    <button class="nav-btn" onclick="showSection('advtypes')"><span class="nav-icon">üß¨</span>Advanced Types</button>
    <button class="nav-btn" onclick="showSection('generics')"><span class="nav-icon">üîÆ</span>Generics</button>
    <button class="nav-btn" onclick="showSection('utility')"><span class="nav-icon">üõ†Ô∏è</span>Utility Types</button>
    <button class="nav-btn" onclick="showSection('conditional')"><span class="nav-icon">üîÄ</span>Conditional Types</button>
    <button class="nav-btn" onclick="showSection('guards')"><span class="nav-icon">üõ°Ô∏è</span>Type Guards</button>
    <button class="nav-btn" onclick="showSection('decorators')"><span class="nav-icon">üé≠</span>Decorators</button>
    <button class="nav-btn" onclick="showSection('gymnastics')"><span class="nav-icon">ü§∏</span>Type Gymnastics</button>
    <button class="nav-btn" onclick="showSection('quiz')"><span class="nav-icon">üìù</span>Quiz</button>
    <button class="nav-btn" onclick="showSection('exercises')"><span class="nav-icon">üí™</span>Exercises</button>
    <button class="nav-btn" onclick="showSection('pitfalls')"><span class="nav-icon">‚ö†Ô∏è</span>Pitfalls</button>
    <button class="nav-btn" onclick="showSection('cheatsheet')"><span class="nav-icon">üìã</span>Cheat Sheet</button>
  </div>
</nav>

<div class="main">

<!-- ========== INTRO / ROADMAP ========== -->
<div class="section active" id="sec-intro">
  <div class="section-header">
    <h2>üó∫Ô∏è Your Learning Roadmap</h2>
    <p class="subtitle">Master advanced TypeScript in the right order</p>
  </div>

  <div class="lesson">
    <h3>Why Advanced TypeScript Matters</h3>
    <p>Top companies (Google, Microsoft, Stripe, Airbnb) use TypeScript extensively. They expect engineers to understand <strong>not just basic types</strong>, but the <strong>deep type system</strong> that makes large codebases safe and maintainable.</p>

    <div class="callout info">
      <div class="callout-title">üí° What You'll Master</div>
      <p>After completing this course, you'll be able to build type-safe APIs, create reusable generic utilities, and write types that <em>prevent bugs at compile time</em> ‚Äî skills that set you apart in interviews.</p>
    </div>

    <h4>üìö Learning Path (Recommended Order)</h4>
    <ol>
      <li><strong>Advanced Types</strong> ‚Äî Union, intersection, literal, mapped, indexed access types</li>
      <li><strong>Advanced Generics</strong> ‚Äî Constraints, inference, default types, higher-order patterns</li>
      <li><strong>Utility Types</strong> ‚Äî Partial, Required, Pick, Omit, Record, and 15+ built-in helpers</li>
      <li><strong>Conditional Types</strong> ‚Äî The <code class="inline">extends</code> keyword as an if-statement for types</li>
      <li><strong>Type Guards</strong> ‚Äî Narrowing types at runtime safely</li>
      <li><strong>Decorators</strong> ‚Äî Meta-programming with class decorators (TC39 Stage 3)</li>
      <li><strong>Type Gymnastics</strong> ‚Äî Combining everything for real-world challenges</li>
    </ol>

    <h4>üéØ How to Use This App</h4>
    <ul>
      <li>Read each lesson <strong>top to bottom</strong> ‚Äî concepts build on each other</li>
      <li>Try to <strong>predict outputs</strong> before reading explanations</li>
      <li>Do every exercise ‚Äî type the code, don't just read it</li>
      <li>Take the quiz to test retention</li>
      <li>Review pitfalls before interviews</li>
      <li>Keep the cheat sheet handy</li>
    </ul>
  </div>

  <div class="lesson">
    <h3>‚öôÔ∏è Prerequisites Check</h3>
    <p>You should already know:</p>
    <ul>
      <li>Basic TypeScript (string, number, boolean, interfaces, basic generics)</li>
      <li>JavaScript ES6+ (arrow functions, destructuring, classes, promises)</li>
      <li>How to run TypeScript (tsc, ts-node, or playground)</li>
    </ul>
    <div class="callout success">
      <div class="callout-title">‚úÖ Ready? Let's go!</div>
      <p>Click <strong>"Advanced Types"</strong> in the navigation to begin.</p>
    </div>
  </div>
</div>

<!-- ========== ADVANCED TYPES ========== -->
<div class="section" id="sec-advtypes">
  <div class="section-header">
    <h2>üß¨ Advanced Types</h2>
    <p class="subtitle">The building blocks of TypeScript's powerful type system</p>
  </div>

  <!-- Union & Intersection -->
  <div class="lesson">
    <h3>1. Union Types ‚Äî "this OR that"</h3>
    <p>A union type says a value can be <strong>one of several types</strong>. Think of it as a logical OR (<code class="inline">|</code>).</p>

    <div class="code-block">
      <div class="code-header"><span>union-basics.ts</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
      <pre><span class="cm">// Simple union</span>
<span class="kw">type</span> <span class="tp">Status</span> = <span class="str">"loading"</span> | <span class="str">"success"</span> | <span class="str">"error"</span>;

<span class="kw">function</span> <span class="fn">showMessage</span>(<span class="param">status</span>: <span class="tp">Status</span>): <span class="tp">string</span> {
  <span class="kw">switch</span> (status) {
    <span class="kw">case</span> <span class="str">"loading"</span>: <span class="kw">return</span> <span class="str">"Please wait..."</span>;
    <span class="kw">case</span> <span class="str">"success"</span>: <span class="kw">return</span> <span class="str">"Done!"</span>;
    <span class="kw">case</span> <span class="str">"error"</span>:   <span class="kw">return</span> <span class="str">"Something went wrong"</span>;
  }
}

<span class="cm">// Union of different shapes</span>
<span class="kw">type</span> <span class="tp">StringOrNumber</span> = <span class="tp">string</span> | <span class="tp">number</span>;

<span class="kw">function</span> <span class="fn">format</span>(<span class="param">value</span>: <span class="tp">StringOrNumber</span>): <span class="tp">string</span> {
  <span class="cm">// Must narrow before using type-specific methods</span>
  <span class="kw">if</span> (<span class="kw">typeof</span> value === <span class="str">"string"</span>) {
    <span class="kw">return</span> value.<span class="fn">toUpperCase</span>();  <span class="cm">// ‚úÖ TS knows it's string here</span>
  }
  <span class="kw">return</span> value.<span class="fn">toFixed</span>(<span class="num">2</span>);        <span class="cm">// ‚úÖ TS knows it's number here</span>
}</pre>
    </div>

    <div class="callout info">
      <div class="callout-title">üîë Key Insight</div>
      <p>With union types, you can only access members that are <strong>common to ALL types</strong> in the union ‚Äî unless you narrow first.</p>
    </div>
  </div>

  <div class="lesson">
    <h3>2. Intersection Types ‚Äî "this AND that"</h3>
    <p>An intersection type <strong>combines</strong> multiple types into one. The result has <strong>all</strong> properties from every type.</p>

    <div class="code-block">
      <div class="code-header"><span>intersection.ts</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
      <pre><span class="kw">type</span> <span class="tp">HasName</span> = { <span class="prop">name</span>: <span class="tp">string</span> };
<span class="kw">type</span> <span class="tp">HasAge</span> = { <span class="prop">age</span>: <span class="tp">number</span> };
<span class="kw">type</span> <span class="tp">HasEmail</span> = { <span class="prop">email</span>: <span class="tp">string</span> };

<span class="cm">// Combine them all</span>
<span class="kw">type</span> <span class="tp">User</span> = <span class="tp">HasName</span> & <span class="tp">HasAge</span> & <span class="tp">HasEmail</span>;

<span class="kw">const</span> user: <span class="tp">User</span> = {
  name: <span class="str">"Alice"</span>,
  age: <span class="num">30</span>,
  email: <span class="str">"alice@example.com"</span>
  <span class="cm">// Must have ALL three properties</span>
};

<span class="cm">// Real-world: adding metadata to any object</span>
<span class="kw">type</span> <span class="tp">Timestamped</span>&lt;<span class="gen">T</span>&gt; = <span class="gen">T</span> & {
  <span class="prop">createdAt</span>: <span class="tp">Date</span>;
  <span class="prop">updatedAt</span>: <span class="tp">Date</span>;
};

<span class="kw">type</span> <span class="tp">TimestampedUser</span> = <span class="tp">Timestamped</span>&lt;<span class="tp">User</span>&gt;;
<span class="cm">// Has: name, age, email, createdAt, updatedAt</span></pre>
    </div>
  </div>

  <div class="lesson">
    <h3>3. Literal Types</h3>
    <p>Instead of just <code class="inline">string</code> or <code class="inline">number</code>, you can specify the <strong>exact value</strong> a variable must hold.</p>

    <div class="code-block">
      <div class="code-header"><span>literal-types.ts</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
      <pre><span class="cm">// String literal types</span>
<span class="kw">type</span> <span class="tp">Direction</span> = <span class="str">"north"</span> | <span class="str">"south"</span> | <span class="str">"east"</span> | <span class="str">"west"</span>;

<span class="cm">// Numeric literal types</span>
<span class="kw">type</span> <span class="tp">DiceRoll</span> = <span class="num">1</span> | <span class="num">2</span> | <span class="num">3</span> | <span class="num">4</span> | <span class="num">5</span> | <span class="num">6</span>;

<span class="cm">// Boolean literal</span>
<span class="kw">type</span> <span class="tp">True</span> = <span class="kw">true</span>;

<span class="cm">// Template literal types (TS 4.1+)</span>
<span class="kw">type</span> <span class="tp">EventName</span> = <span class="str">`on${<span class="tp">Capitalize</span>&lt;<span class="tp">string</span>&gt;}`</span>;
<span class="cm">// Matches: "onClick", "onHover", "onSubmit", etc.</span>

<span class="kw">type</span> <span class="tp">HttpMethod</span> = <span class="str">"GET"</span> | <span class="str">"POST"</span> | <span class="str">"PUT"</span> | <span class="str">"DELETE"</span>;
<span class="kw">type</span> <span class="tp">ApiEndpoint</span> = <span class="str">`/${<span class="tp">string</span>}`</span>;
<span class="kw">type</span> <span class="tp">Route</span> = <span class="str">`${<span class="tp">HttpMethod</span>} ${<span class="tp">ApiEndpoint</span>}`</span>;

<span class="kw">const</span> route: <span class="tp">Route</span> = <span class="str">"GET /users"</span>;  <span class="cm">// ‚úÖ</span>
<span class="cm">// const bad: Route = "PATCH /users"; // ‚ùå Error</span></pre>
    </div>
  </div>

  <div class="lesson">
    <h3>4. Discriminated Unions (Tagged Unions)</h3>
    <p>The most <strong>important pattern</strong> in TypeScript. Each variant has a common property (the <em>discriminant</em>) that TypeScript uses to narrow the type.</p>

    <div class="code-block">
      <div class="code-header"><span>discriminated-union.ts</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
      <pre><span class="cm">// Each shape has a "kind" discriminant</span>
<span class="kw">type</span> <span class="tp">Circle</span> = {
  <span class="prop">kind</span>: <span class="str">"circle"</span>;
  <span class="prop">radius</span>: <span class="tp">number</span>;
};

<span class="kw">type</span> <span class="tp">Rectangle</span> = {
  <span class="prop">kind</span>: <span class="str">"rectangle"</span>;
  <span class="prop">width</span>: <span class="tp">number</span>;
  <span class="prop">height</span>: <span class="tp">number</span>;
};

<span class="kw">type</span> <span class="tp">Triangle</span> = {
  <span class="prop">kind</span>: <span class="str">"triangle"</span>;
  <span class="prop">base</span>: <span class="tp">number</span>;
  <span class="prop">height</span>: <span class="tp">number</span>;
};

<span class="kw">type</span> <span class="tp">Shape</span> = <span class="tp">Circle</span> | <span class="tp">Rectangle</span> | <span class="tp">Triangle</span>;

<span class="kw">function</span> <span class="fn">area</span>(<span class="param">shape</span>: <span class="tp">Shape</span>): <span class="tp">number</span> {
  <span class="kw">switch</span> (shape.<span class="prop">kind</span>) {
    <span class="kw">case</span> <span class="str">"circle"</span>:
      <span class="kw">return</span> Math.PI * shape.<span class="prop">radius</span> ** <span class="num">2</span>;
      <span class="cm">// TS knows: shape is Circle here ‚úÖ</span>
    <span class="kw">case</span> <span class="str">"rectangle"</span>:
      <span class="kw">return</span> shape.<span class="prop">width</span> * shape.<span class="prop">height</span>;
      <span class="cm">// TS knows: shape is Rectangle here ‚úÖ</span>
    <span class="kw">case</span> <span class="str">"triangle"</span>:
      <span class="kw">return</span> <span class="num">0.5</span> * shape.<span class="prop">base</span> * shape.<span class="prop">height</span>;
  }
}

<span class="cm">// Exhaustiveness checking with never</span>
<span class="kw">function</span> <span class="fn">assertNever</span>(<span class="param">x</span>: <span class="tp">never</span>): <span class="tp">never</span> {
  <span class="kw">throw new</span> Error(<span class="str">`Unexpected: ${x}`</span>);
}</pre>
    </div>

    <div class="callout warning">
      <div class="callout-title">‚ö†Ô∏è Interview Favorite</div>
      <p>Discriminated unions come up in <strong>almost every TypeScript interview</strong>. Know this pattern cold. It's used in Redux actions, API responses, state machines, and more.</p>
    </div>
  </div>

  <div class="lesson">
    <h3>5. Mapped Types</h3>
    <p>Create new types by <strong>transforming each property</strong> of an existing type.</p>

    <div class="code-block">
      <div class="code-header"><span>mapped-types.ts</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
      <pre><span class="cm">// Make all properties optional</span>
<span class="kw">type</span> <span class="tp">MyPartial</span>&lt;<span class="gen">T</span>&gt; = {
  [<span class="gen">K</span> <span class="kw">in keyof</span> <span class="gen">T</span>]?: <span class="gen">T</span>[<span class="gen">K</span>];
};

<span class="cm">// Make all properties readonly</span>
<span class="kw">type</span> <span class="tp">MyReadonly</span>&lt;<span class="gen">T</span>&gt; = {
  <span class="kw">readonly</span> [<span class="gen">K</span> <span class="kw">in keyof</span> <span class="gen">T</span>]: <span class="gen">T</span>[<span class="gen">K</span>];
};

<span class="cm">// Make all properties nullable</span>
<span class="kw">type</span> <span class="tp">Nullable</span>&lt;<span class="gen">T</span>&gt; = {
  [<span class="gen">K</span> <span class="kw">in keyof</span> <span class="gen">T</span>]: <span class="gen">T</span>[<span class="gen">K</span>] | <span class="kw">null</span>;
};

<span class="cm">// Key remapping (TS 4.1+)</span>
<span class="kw">type</span> <span class="tp">Getters</span>&lt;<span class="gen">T</span>&gt; = {
  [<span class="gen">K</span> <span class="kw">in keyof</span> <span class="gen">T</span> <span class="kw">as</span> <span class="str">`get${<span class="tp">Capitalize</span>&lt;<span class="gen">K</span> & <span class="tp">string</span>&gt;}`</span>]: () =&gt; <span class="gen">T</span>[<span class="gen">K</span>];
};

<span class="kw">interface</span> <span class="iface">Person</span> {
  <span class="prop">name</span>: <span class="tp">string</span>;
  <span class="prop">age</span>: <span class="tp">number</span>;
}

<span class="kw">type</span> <span class="tp">PersonGetters</span> = <span class="tp">Getters</span>&lt;<span class="iface">Person</span>&gt;;
<span class="cm">// Result: { getName: () => string; getAge: () => number; }</span></pre>
    </div>
  </div>

  <div class="lesson">
    <h3>6. Indexed Access Types</h3>
    <p>Look up the type of a specific property by "indexing into" a type.</p>

    <div class="code-block">
      <div class="code-header"><span>indexed-access.ts</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
      <pre><span class="kw">interface</span> <span class="iface">ApiResponse</span> {
  <span class="prop">data</span>: {
    <span class="prop">users</span>: { <span class="prop">id</span>: <span class="tp">number</span>; <span class="prop">name</span>: <span class="tp">string</span> }[];
    <span class="prop">total</span>: <span class="tp">number</span>;
  };
  <span class="prop">status</span>: <span class="tp">number</span>;
  <span class="prop">message</span>: <span class="tp">string</span>;
}

<span class="cm">// Access nested types</span>
<span class="kw">type</span> <span class="tp">Data</span> = <span class="iface">ApiResponse</span>[<span class="str">"data"</span>];
<span class="cm">// { users: { id: number; name: string }[]; total: number }</span>

<span class="kw">type</span> <span class="tp">Users</span> = <span class="iface">ApiResponse</span>[<span class="str">"data"</span>][<span class="str">"users"</span>];
<span class="cm">// { id: number; name: string }[]</span>

<span class="kw">type</span> <span class="tp">SingleUser</span> = <span class="iface">ApiResponse</span>[<span class="str">"data"</span>][<span class="str">"users"</span>][<span class="tp">number</span>];
<span class="cm">// { id: number; name: string }</span>

<span class="cm">// Use with keyof</span>
<span class="kw">type</span> <span class="tp">ResponseKeys</span> = <span class="kw">keyof</span> <span class="iface">ApiResponse</span>;
<span class="cm">// "data" | "status" | "message"</span>

<span class="kw">type</span> <span class="tp">ResponseValues</span> = <span class="iface">ApiResponse</span>[<span class="kw">keyof</span> <span class="iface">ApiResponse</span>];
<span class="cm">// Data | number | string</span></pre>
    </div>
  </div>

  <button class="quiz-btn" onclick="markComplete('advtypes'); showSection('generics');">Continue to Generics ‚Üí</button>
</div>

<!-- ========== ADVANCED GENERICS ========== -->
<div class="section" id="sec-generics">
  <div class="section-header">
    <h2>üîÆ Advanced Generics</h2>
    <p class="subtitle">Write flexible, reusable, type-safe code</p>
  </div>

  <div class="lesson">
    <h3>1. Generic Constraints ‚Äî <code class="inline">extends</code></h3>
    <p>Restrict what types a generic parameter can accept.</p>

    <div class="code-block">
      <div class="code-header"><span>constraints.ts</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
      <pre><span class="cm">// T must have a .length property</span>
<span class="kw">function</span> <span class="fn">longest</span>&lt;<span class="gen">T</span> <span class="kw">extends</span> { <span class="prop">length</span>: <span class="tp">number</span> }&gt;(
  <span class="param">a</span>: <span class="gen">T</span>,
  <span class="param">b</span>: <span class="gen">T</span>
): <span class="gen">T</span> {
  <span class="kw">return</span> a.length >= b.length ? a : b;
}

<span class="fn">longest</span>(<span class="str">"hello"</span>, <span class="str">"world!"</span>);   <span class="cm">// ‚úÖ string has .length</span>
<span class="fn">longest</span>([<span class="num">1</span>, <span class="num">2</span>], [<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>]);    <span class="cm">// ‚úÖ array has .length</span>
<span class="cm">// longest(10, 20);              // ‚ùå number has no .length</span>

<span class="cm">// Constrain to keys of an object</span>
<span class="kw">function</span> <span class="fn">getProperty</span>&lt;<span class="gen">T</span>, <span class="gen">K</span> <span class="kw">extends keyof</span> <span class="gen">T</span>&gt;(
  <span class="param">obj</span>: <span class="gen">T</span>,
  <span class="param">key</span>: <span class="gen">K</span>
): <span class="gen">T</span>[<span class="gen">K</span>] {
  <span class="kw">return</span> obj[key];
}

<span class="kw">const</span> user = { name: <span class="str">"Alice"</span>, age: <span class="num">30</span> };
<span class="fn">getProperty</span>(user, <span class="str">"name"</span>);  <span class="cm">// ‚úÖ returns string</span>
<span class="fn">getProperty</span>(user, <span class="str">"age"</span>);   <span class="cm">// ‚úÖ returns number</span>
<span class="cm">// getProperty(user, "email"); // ‚ùå "email" is not a key of user</span></pre>
    </div>
  </div>

  <div class="lesson">
    <h3>2. Generic Inference</h3>
    <p>TypeScript can <strong>infer</strong> generic types from arguments ‚Äî you don't always need to specify them.</p>

    <div class="code-block">
      <div class="code-header"><span>inference.ts</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
      <pre><span class="kw">function</span> <span class="fn">map</span>&lt;<span class="gen">T</span>, <span class="gen">U</span>&gt;(
  <span class="param">arr</span>: <span class="gen">T</span>[],
  <span class="param">fn</span>: (<span class="param">item</span>: <span class="gen">T</span>) =&gt; <span class="gen">U</span>
): <span class="gen">U</span>[] {
  <span class="kw">return</span> arr.<span class="fn">map</span>(fn);
}

<span class="cm">// TS infers T=number, U=string</span>
<span class="kw">const</span> result = <span class="fn">map</span>([<span class="num">1</span>, <span class="num">2</span>, <span class="num">3</span>], n =&gt; n.<span class="fn">toString</span>());
<span class="cm">// result: string[]</span>

<span class="cm">// The infer keyword (used in conditional types)</span>
<span class="kw">type</span> <span class="tp">ReturnOf</span>&lt;<span class="gen">T</span>&gt; = <span class="gen">T</span> <span class="kw">extends</span> (...<span class="param">args</span>: <span class="kw">any</span>[]) =&gt; <span class="kw">infer</span> <span class="gen">R</span>
  ? <span class="gen">R</span>
  : <span class="tp">never</span>;

<span class="kw">type</span> <span class="tp">A</span> = <span class="tp">ReturnOf</span>&lt;() =&gt; <span class="tp">string</span>&gt;;        <span class="cm">// string</span>
<span class="kw">type</span> <span class="tp">B</span> = <span class="tp">ReturnOf</span>&lt;(<span class="param">x</span>: <span class="tp">number</span>) =&gt; <span class="tp">boolean</span>&gt;; <span class="cm">// boolean</span>
<span class="kw">type</span> <span class="tp">C</span> = <span class="tp">ReturnOf</span>&lt;<span class="tp">string</span>&gt;;              <span class="cm">// never</span></pre>
    </div>
  </div>

  <div class="lesson">
    <h3>3. Generic Default Types</h3>

    <div class="code-block">
      <div class="code-header"><span>defaults.ts</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
      <pre><span class="cm">// Default generic type parameter</span>
<span class="kw">interface</span> <span class="iface">ApiResponse</span>&lt;<span class="gen">T</span> = <span class="kw">unknown</span>&gt; {
  <span class="prop">data</span>: <span class="gen">T</span>;
  <span class="prop">status</span>: <span class="tp">number</span>;
  <span class="prop">error</span>?: <span class="tp">string</span>;
}

<span class="cm">// Uses default (unknown)</span>
<span class="kw">const</span> res1: <span class="iface">ApiResponse</span> = { data: <span class="str">"anything"</span>, status: <span class="num">200</span> };

<span class="cm">// Override the default</span>
<span class="kw">const</span> res2: <span class="iface">ApiResponse</span>&lt;{ <span class="prop">id</span>: <span class="tp">number</span> }&gt; = {
  data: { id: <span class="num">1</span> },
  status: <span class="num">200</span>
};

<span class="cm">// Generic class with defaults</span>
<span class="kw">class</span> <span class="tp">EventEmitter</span>&lt;<span class="gen">Events</span> <span class="kw">extends</span> <span class="tp">Record</span>&lt;<span class="tp">string</span>, <span class="kw">any</span>&gt; = <span class="tp">Record</span>&lt;<span class="tp">string</span>, <span class="kw">any</span>&gt;&gt; {
  <span class="fn">emit</span>&lt;<span class="gen">K</span> <span class="kw">extends keyof</span> <span class="gen">Events</span>&gt;(<span class="param">event</span>: <span class="gen">K</span>, <span class="param">payload</span>: <span class="gen">Events</span>[<span class="gen">K</span>]): <span class="kw">void</span> {
    <span class="cm">// implementation</span>
  }
}

<span class="cm">// Typed event emitter</span>
<span class="kw">type</span> <span class="tp">MyEvents</span> = {
  <span class="prop">login</span>: { <span class="prop">userId</span>: <span class="tp">string</span> };
  <span class="prop">logout</span>: <span class="kw">void</span>;
  <span class="prop">error</span>: <span class="tp">Error</span>;
};

<span class="kw">const</span> emitter = <span class="kw">new</span> <span class="tp">EventEmitter</span>&lt;<span class="tp">MyEvents</span>&gt;();
emitter.<span class="fn">emit</span>(<span class="str">"login"</span>, { userId: <span class="str">"123"</span> }); <span class="cm">// ‚úÖ</span>
<span class="cm">// emitter.emit("login", "wrong"); // ‚ùå Type error</span></pre>
    </div>
  </div>

  <div class="lesson">
    <h3>4. Generic Patterns You'll See in Interviews</h3>

    <div class="code-block">
      <div class="code-header"><span>patterns.ts</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
      <pre><span class="cm">// Pattern 1: Builder Pattern</span>
<span class="kw">class</span> <span class="tp">QueryBuilder</span>&lt;<span class="gen">T</span>&gt; {
  <span class="kw">private</span> <span class="prop">filters</span>: <span class="tp">Partial</span>&lt;<span class="gen">T</span>&gt; = {};

  <span class="fn">where</span>&lt;<span class="gen">K</span> <span class="kw">extends keyof</span> <span class="gen">T</span>&gt;(<span class="param">key</span>: <span class="gen">K</span>, <span class="param">value</span>: <span class="gen">T</span>[<span class="gen">K</span>]): <span class="kw">this</span> {
    <span class="kw">this</span>.filters[key] = value;
    <span class="kw">return this</span>;
  }
}

<span class="cm">// Pattern 2: Factory with type inference</span>
<span class="kw">function</span> <span class="fn">createStore</span>&lt;<span class="gen">S</span>&gt;(<span class="param">initialState</span>: <span class="gen">S</span>) {
  <span class="kw">let</span> state = initialState;
  <span class="kw">return</span> {
    <span class="fn">getState</span>(): <span class="gen">S</span> { <span class="kw">return</span> state; },
    <span class="fn">setState</span>(<span class="param">newState</span>: <span class="tp">Partial</span>&lt;<span class="gen">S</span>&gt;) {
      state = { ...state, ...newState };
    }
  };
}

<span class="kw">const</span> store = <span class="fn">createStore</span>({ count: <span class="num">0</span>, name: <span class="str">"test"</span> });
store.<span class="fn">setState</span>({ count: <span class="num">1</span> });    <span class="cm">// ‚úÖ</span>
<span class="cm">// store.setState({ invalid: true }); // ‚ùå</span>

<span class="cm">// Pattern 3: Constrained identity function for type narrowing</span>
<span class="kw">function</span> <span class="fn">defineConfig</span>&lt;<span class="gen">T</span> <span class="kw">extends</span> {
  <span class="prop">routes</span>: <span class="tp">Record</span>&lt;<span class="tp">string</span>, () =&gt; <span class="tp">Promise</span>&lt;<span class="kw">any</span>&gt;&gt;;
  <span class="prop">plugins</span>?: <span class="tp">string</span>[];
}&gt;(<span class="param">config</span>: <span class="gen">T</span>): <span class="gen">T</span> {
  <span class="kw">return</span> config;
}</pre>
    </div>
  </div>

  <button class="quiz-btn" onclick="markComplete('generics'); showSection('utility');">Continue to Utility Types ‚Üí</button>
</div>

<!-- ========== UTILITY TYPES ========== -->
<div class="section" id="sec-utility">
  <div class="section-header">
    <h2>üõ†Ô∏è Utility Types</h2>
    <p class="subtitle">Built-in type transformations you must know</p>
  </div>

  <div class="lesson">
    <h3>The Big Picture</h3>
    <p>TypeScript provides <strong>built-in generic types</strong> that transform other types. These are used <em>everywhere</em> in professional codebases.</p>

    <div class="callout info">
      <div class="callout-title">üí° Think of utility types as functions</div>
      <p><code class="inline">Partial&lt;User&gt;</code> is like calling a function: input is <code class="inline">User</code>, output is a new type where all props are optional.</p>
    </div>
  </div>

  <div class="lesson">
    <h3>1. Property Modifiers</h3>

    <div class="code-block">
      <div class="code-header"><span>property-modifiers.ts</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
      <pre><span class="kw">interface</span> <span class="iface">User</span> {
  <span class="prop">id</span>: <span class="tp">number</span>;
  <span class="prop">name</span>: <span class="tp">string</span>;
  <span class="prop">email</span>: <span class="tp">string</span>;
  <span class="prop">age</span>: <span class="tp">number</span>;
}

<span class="cm">// Partial&lt;T&gt; ‚Äî All properties become optional</span>
<span class="kw">type</span> <span class="tp">UpdateUser</span> = <span class="tp">Partial</span>&lt;<span class="iface">User</span>&gt;;
<span class="cm">// { id?: number; name?: string; email?: string; age?: number }</span>
<span class="cm">// USE CASE: update functions where you send only changed fields</span>

<span class="cm">// Required&lt;T&gt; ‚Äî All properties become required</span>
<span class="kw">interface</span> <span class="iface">Config</span> {
  <span class="prop">host</span>?: <span class="tp">string</span>;
  <span class="prop">port</span>?: <span class="tp">number</span>;
}
<span class="kw">type</span> <span class="tp">ResolvedConfig</span> = <span class="tp">Required</span>&lt;<span class="iface">Config</span>&gt;;
<span class="cm">// { host: string; port: number }</span>

<span class="cm">// Readonly&lt;T&gt; ‚Äî All properties become readonly</span>
<span class="kw">type</span> <span class="tp">FrozenUser</span> = <span class="tp">Readonly</span>&lt;<span class="iface">User</span>&gt;;
<span class="cm">// const frozenUser: FrozenUser = { ... };
// frozenUser.name = "Bob"; // ‚ùå Cannot assign to readonly property</span></pre>
    </div>
  </div>

  <div class="lesson">
    <h3>2. Property Selection</h3>

    <div class="code-block">
      <div class="code-header"><span>pick-omit.ts</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
      <pre><span class="kw">interface</span> <span class="iface">User</span> {
  <span class="prop">id</span>: <span class="tp">number</span>;
  <span class="prop">name</span>: <span class="tp">string</span>;
  <span class="prop">email</span>: <span class="tp">string</span>;
  <span class="prop">password</span>: <span class="tp">string</span>;
  <span class="prop">createdAt</span>: <span class="tp">Date</span>;
}

<span class="cm">// Pick&lt;T, K&gt; ‚Äî Select specific properties</span>
<span class="kw">type</span> <span class="tp">UserPreview</span> = <span class="tp">Pick</span>&lt;<span class="iface">User</span>, <span class="str">"id"</span> | <span class="str">"name"</span>&gt;;
<span class="cm">// { id: number; name: string }</span>

<span class="cm">// Omit&lt;T, K&gt; ‚Äî Remove specific properties</span>
<span class="kw">type</span> <span class="tp">PublicUser</span> = <span class="tp">Omit</span>&lt;<span class="iface">User</span>, <span class="str">"password"</span>&gt;;
<span class="cm">// { id: number; name: string; email: string; createdAt: Date }</span>

<span class="cm">// Real-world: API request vs response</span>
<span class="kw">type</span> <span class="tp">CreateUserRequest</span> = <span class="tp">Omit</span>&lt;<span class="iface">User</span>, <span class="str">"id"</span> | <span class="str">"createdAt"</span>&gt;;
<span class="cm">// { name: string; email: string; password: string }</span>

<span class="cm">// Combine them!</span>
<span class="kw">type</span> <span class="tp">UpdateUserRequest</span> = <span class="tp">Partial</span>&lt;<span class="tp">Omit</span>&lt;<span class="iface">User</span>, <span class="str">"id"</span> | <span class="str">"createdAt"</span>&gt;&gt;;
<span class="cm">// { name?: string; email?: string; password?: string }</span></pre>
    </div>
  </div>

  <div class="lesson">
    <h3>3. Record, Extract, Exclude</h3>

    <div class="code-block">
      <div class="code-header"><span>record-extract-exclude.ts</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
      <pre><span class="cm">// Record&lt;K, V&gt; ‚Äî Create an object type with keys K and values V</span>
<span class="kw">type</span> <span class="tp">Roles</span> = <span class="str">"admin"</span> | <span class="str">"editor"</span> | <span class="str">"viewer"</span>;

<span class="kw">type</span> <span class="tp">RolePermissions</span> = <span class="tp">Record</span>&lt;<span class="tp">Roles</span>, {
  <span class="prop">canRead</span>: <span class="tp">boolean</span>;
  <span class="prop">canWrite</span>: <span class="tp">boolean</span>;
  <span class="prop">canDelete</span>: <span class="tp">boolean</span>;
}&gt;;

<span class="kw">const</span> permissions: <span class="tp">RolePermissions</span> = {
  admin:  { canRead: <span class="kw">true</span>,  canWrite: <span class="kw">true</span>,  canDelete: <span class="kw">true</span> },
  editor: { canRead: <span class="kw">true</span>,  canWrite: <span class="kw">true</span>,  canDelete: <span class="kw">false</span> },
  viewer: { canRead: <span class="kw">true</span>,  canWrite: <span class="kw">false</span>, canDelete: <span class="kw">false</span> },
};

<span class="cm">// Extract&lt;T, U&gt; ‚Äî Keep only members of T assignable to U</span>
<span class="kw">type</span> <span class="tp">AllTypes</span> = <span class="tp">string</span> | <span class="tp">number</span> | <span class="tp">boolean</span> | <span class="kw">null</span>;
<span class="kw">type</span> <span class="tp">StringOrNumber</span> = <span class="tp">Extract</span>&lt;<span class="tp">AllTypes</span>, <span class="tp">string</span> | <span class="tp">number</span>&gt;;
<span class="cm">// string | number</span>

<span class="cm">// Exclude&lt;T, U&gt; ‚Äî Remove members of T assignable to U</span>
<span class="kw">type</span> <span class="tp">NonNull</span> = <span class="tp">Exclude</span>&lt;<span class="tp">AllTypes</span>, <span class="kw">null</span>&gt;;
<span class="cm">// string | number | boolean</span>

<span class="cm">// NonNullable&lt;T&gt; ‚Äî Remove null and undefined</span>
<span class="kw">type</span> <span class="tp">MaybeString</span> = <span class="tp">string</span> | <span class="kw">null</span> | <span class="kw">undefined</span>;
<span class="kw">type</span> <span class="tp">DefiniteString</span> = <span class="tp">NonNullable</span>&lt;<span class="tp">MaybeString</span>&gt;;
<span class="cm">// string</span></pre>
    </div>
  </div>

  <div class="lesson">
    <h3>4. Function Utility Types</h3>

    <div class="code-block">
      <div class="code-header"><span>function-utils.ts</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
      <pre><span class="kw">function</span> <span class="fn">createUser</span>(<span class="param">name</span>: <span class="tp">string</span>, <span class="param">age</span>: <span class="tp">number</span>, <span class="param">admin</span>: <span class="tp">boolean</span>) {
  <span class="kw">return</span> { name, age, admin, id: Math.<span class="fn">random</span>() };
}

<span class="cm">// ReturnType&lt;T&gt; ‚Äî Extract the return type</span>
<span class="kw">type</span> <span class="tp">UserResult</span> = <span class="tp">ReturnType</span>&lt;<span class="kw">typeof</span> createUser&gt;;
<span class="cm">// { name: string; age: number; admin: boolean; id: number }</span>

<span class="cm">// Parameters&lt;T&gt; ‚Äî Extract parameter types as a tuple</span>
<span class="kw">type</span> <span class="tp">CreateUserParams</span> = <span class="tp">Parameters</span>&lt;<span class="kw">typeof</span> createUser&gt;;
<span class="cm">// [string, number, boolean]</span>

<span class="cm">// ConstructorParameters&lt;T&gt;</span>
<span class="kw">class</span> <span class="tp">HttpClient</span> {
  <span class="kw">constructor</span>(<span class="param">baseUrl</span>: <span class="tp">string</span>, <span class="param">timeout</span>: <span class="tp">number</span>) {}
}
<span class="kw">type</span> <span class="tp">HttpArgs</span> = <span class="tp">ConstructorParameters</span>&lt;<span class="kw">typeof</span> <span class="tp">HttpClient</span>&gt;;
<span class="cm">// [string, number]</span>

<span class="cm">// InstanceType&lt;T&gt;</span>
<span class="kw">type</span> <span class="tp">HttpInstance</span> = <span class="tp">InstanceType</span>&lt;<span class="kw">typeof</span> <span class="tp">HttpClient</span>&gt;;
<span class="cm">// HttpClient</span>

<span class="cm">// Awaited&lt;T&gt; (TS 4.5+) ‚Äî Unwrap Promise types</span>
<span class="kw">type</span> <span class="tp">A</span> = <span class="tp">Awaited</span>&lt;<span class="tp">Promise</span>&lt;<span class="tp">string</span>&gt;&gt;; <span class="cm">// string</span>
<span class="kw">type</span> <span class="tp">B</span> = <span class="tp">Awaited</span>&lt;<span class="tp">Promise</span>&lt;<span class="tp">Promise</span>&lt;<span class="tp">number</span>&gt;&gt;&gt;; <span class="cm">// number</span></pre>
    </div>
  </div>

  <div class="lesson">
    <h3>5. How Utility Types Work Internally</h3>
    <p>Understanding the implementation makes you dangerous in interviews.</p>

    <div class="code-block">
      <div class="code-header"><span>implementations.ts</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
      <pre><span class="cm">// These are the ACTUAL implementations in TypeScript's lib</span>

<span class="cm">// Partial ‚Äî adds ? to every key</span>
<span class="kw">type</span> <span class="tp">Partial</span>&lt;<span class="gen">T</span>&gt; = {
  [<span class="gen">P</span> <span class="kw">in keyof</span> <span class="gen">T</span>]?: <span class="gen">T</span>[<span class="gen">P</span>];
};

<span class="cm">// Required ‚Äî removes ? from every key (note the -?)</span>
<span class="kw">type</span> <span class="tp">Required</span>&lt;<span class="gen">T</span>&gt; = {
  [<span class="gen">P</span> <span class="kw">in keyof</span> <span class="gen">T</span>]-?: <span class="gen">T</span>[<span class="gen">P</span>];
};

<span class="cm">// Readonly ‚Äî adds readonly to every key</span>
<span class="kw">type</span> <span class="tp">Readonly</span>&lt;<span class="gen">T</span>&gt; = {
  <span class="kw">readonly</span> [<span class="gen">P</span> <span class="kw">in keyof</span> <span class="gen">T</span>]: <span class="gen">T</span>[<span class="gen">P</span>];
};

<span class="cm">// Pick ‚Äî iterate over K only</span>
<span class="kw">type</span> <span class="tp">Pick</span>&lt;<span class="gen">T</span>, <span class="gen">K</span> <span class="kw">extends keyof</span> <span class="gen">T</span>&gt; = {
  [<span class="gen">P</span> <span class="kw">in</span> <span class="gen">K</span>]: <span class="gen">T</span>[<span class="gen">P</span>];
};

<span class="cm">// Record ‚Äî map keys to value type</span>
<span class="kw">type</span> <span class="tp">Record</span>&lt;<span class="gen">K</span> <span class="kw">extends</span> <span class="tp">string</span> | <span class="tp">number</span> | <span class="tp">symbol</span>, <span class="gen">V</span>&gt; = {
  [<span class="gen">P</span> <span class="kw">in</span> <span class="gen">K</span>]: <span class="gen">V</span>;
};

<span class="cm">// Exclude ‚Äî conditional type on union distribution</span>
<span class="kw">type</span> <span class="tp">Exclude</span>&lt;<span class="gen">T</span>, <span class="gen">U</span>&gt; = <span class="gen">T</span> <span class="kw">extends</span> <span class="gen">U</span> ? <span class="tp">never</span> : <span class="gen">T</span>;

<span class="cm">// Extract ‚Äî opposite of Exclude</span>
<span class="kw">type</span> <span class="tp">Extract</span>&lt;<span class="gen">T</span>, <span class="gen">U</span>&gt; = <span class="gen">T</span> <span class="kw">extends</span> <span class="gen">U</span> ? <span class="gen">T</span> : <span class="tp">never</span>;

<span class="cm">// ReturnType ‚Äî infer the return type of a function</span>
<span class="kw">type</span> <span class="tp">ReturnType</span>&lt;<span class="gen">T</span> <span class="kw">extends</span> (...<span class="param">args</span>: <span class="kw">any</span>) =&gt; <span class="kw">any</span>&gt; =
  <span class="gen">T</span> <span class="kw">extends</span> (...<span class="param">args</span>: <span class="kw">any</span>) =&gt; <span class="kw">infer</span> <span class="gen">R</span> ? <span class="gen">R</span> : <span class="kw">any</span>;</pre>
    </div>
  </div>

  <button class="quiz-btn" onclick="markComplete('utility'); showSection('conditional');">Continue to Conditional Types ‚Üí</button>
</div>

<!-- ========== CONDITIONAL TYPES ========== -->
<div class="section" id="sec-conditional">
  <div class="section-header">
    <h2>üîÄ Conditional Types</h2>
    <p class="subtitle">If-else logic at the type level</p>
  </div>

  <div class="lesson">
    <h3>1. Basic Syntax</h3>
    <p>Conditional types look like ternary expressions: <code class="inline">T extends U ? X : Y</code></p>

    <div class="code-block">
      <div class="code-header"><span>conditional-basics.ts</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
      <pre><span class="cm">// Simple conditional type</span>
<span class="kw">type</span> <span class="tp">IsString</span>&lt;<span class="gen">T</span>&gt; = <span class="gen">T</span> <span class="kw">extends</span> <span class="tp">string</span> ? <span class="kw">true</span> : <span class="kw">false</span>;

<span class="kw">type</span> <span class="tp">A</span> = <span class="tp">IsString</span>&lt;<span class="str">"hello"</span>&gt;;  <span class="cm">// true</span>
<span class="kw">type</span> <span class="tp">B</span> = <span class="tp">IsString</span>&lt;<span class="num">42</span>&gt;;       <span class="cm">// false</span>
<span class="kw">type</span> <span class="tp">C</span> = <span class="tp">IsString</span>&lt;<span class="tp">string</span>&gt;;   <span class="cm">// true</span>

<span class="cm">// "extends" means "is assignable to"</span>
<span class="cm">// Read it as: "If T can be assigned to string, then true, else false"</span>

<span class="cm">// Practical example: different return types</span>
<span class="kw">type</span> <span class="tp">MessageFor</span>&lt;<span class="gen">T</span>&gt; = <span class="gen">T</span> <span class="kw">extends</span> { <span class="prop">message</span>: <span class="tp">string</span> }
  ? <span class="gen">T</span>[<span class="str">"message"</span>]
  : <span class="tp">never</span>;

<span class="kw">type</span> <span class="tp">EmailMsg</span> = <span class="tp">MessageFor</span>&lt;{ message: <span class="str">"Hi"</span>; from: <span class="tp">string</span> }&gt;; <span class="cm">// "Hi"</span>
<span class="kw">type</span> <span class="tp">NoMsg</span> = <span class="tp">MessageFor</span>&lt;{ from: <span class="tp">string</span> }&gt;;                 <span class="cm">// never</span></pre>
    </div>
  </div>

  <div class="lesson">
    <h3>2. Distributive Conditional Types</h3>
    <p>When the checked type is a <strong>naked type parameter</strong> (not wrapped), conditional types <strong>distribute</strong> over union members.</p>

    <div class="code-block">
      <div class="code-header"><span>distributive.ts</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
      <pre><span class="kw">type</span> <span class="tp">ToArray</span>&lt;<span class="gen">T</span>&gt; = <span class="gen">T</span> <span class="kw">extends</span> <span class="kw">any</span> ? <span class="gen">T</span>[] : <span class="tp">never</span>;

<span class="cm">// Distribution happens! Each union member is checked separately:</span>
<span class="kw">type</span> <span class="tp">Result</span> = <span class="tp">ToArray</span>&lt;<span class="tp">string</span> | <span class="tp">number</span>&gt;;
<span class="cm">// = ToArray&lt;string&gt; | ToArray&lt;number&gt;</span>
<span class="cm">// = string[] | number[]</span>

<span class="cm">// To PREVENT distribution, wrap both sides in []</span>
<span class="kw">type</span> <span class="tp">ToArrayNonDist</span>&lt;<span class="gen">T</span>&gt; = [<span class="gen">T</span>] <span class="kw">extends</span> [<span class="kw">any</span>] ? <span class="gen">T</span>[] : <span class="tp">never</span>;

<span class="kw">type</span> <span class="tp">Result2</span> = <span class="tp">ToArrayNonDist</span>&lt;<span class="tp">string</span> | <span class="tp">number</span>&gt;;
<span class="cm">// = (string | number)[]  ‚Äî one array that holds both!</span>

<span class="cm">// This is how Exclude works (distribution!):</span>
<span class="kw">type</span> <span class="tp">MyExclude</span>&lt;<span class="gen">T</span>, <span class="gen">U</span>&gt; = <span class="gen">T</span> <span class="kw">extends</span> <span class="gen">U</span> ? <span class="tp">never</span> : <span class="gen">T</span>;

<span class="kw">type</span> <span class="tp">Test</span> = <span class="tp">MyExclude</span>&lt;<span class="str">"a"</span> | <span class="str">"b"</span> | <span class="str">"c"</span>, <span class="str">"a"</span>&gt;;
<span class="cm">// Step by step:
//   "a" extends "a" ? never : "a"  ‚Üí never
//   "b" extends "a" ? never : "b"  ‚Üí "b"
//   "c" extends "a" ? never : "c"  ‚Üí "c"
// Result: "b" | "c"</span></pre>
    </div>

    <div class="callout warning">
      <div class="callout-title">‚ö†Ô∏è Distribution is a Common Interview Trap</div>
      <p>Many candidates get confused by this. Remember: distribution ONLY happens when the type parameter is "naked" (not wrapped in <code class="inline">[]</code>, <code class="inline">{}</code>, <code class="inline">Promise&lt;&gt;</code>, etc.).</p>
    </div>
  </div>

  <div class="lesson">
    <h3>3. The <code class="inline">infer</code> Keyword</h3>
    <p><code class="inline">infer</code> lets you <strong>extract</strong> a type from within a pattern. It's like destructuring but for types.</p>

    <div class="code-block">
      <div class="code-header"><span>infer.ts</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
      <pre><span class="cm">// Extract return type of a function</span>
<span class="kw">type</span> <span class="tp">MyReturnType</span>&lt;<span class="gen">T</span>&gt; =
  <span class="gen">T</span> <span class="kw">extends</span> (...<span class="param">args</span>: <span class="kw">any</span>[]) =&gt; <span class="kw">infer</span> <span class="gen">R</span> ? <span class="gen">R</span> : <span class="tp">never</span>;

<span class="cm">// Extract element type of an array</span>
<span class="kw">type</span> <span class="tp">ElementOf</span>&lt;<span class="gen">T</span>&gt; =
  <span class="gen">T</span> <span class="kw">extends</span> (<span class="kw">infer</span> <span class="gen">E</span>)[] ? <span class="gen">E</span> : <span class="tp">never</span>;

<span class="kw">type</span> <span class="tp">E1</span> = <span class="tp">ElementOf</span>&lt;<span class="tp">string</span>[]&gt;;      <span class="cm">// string</span>
<span class="kw">type</span> <span class="tp">E2</span> = <span class="tp">ElementOf</span>&lt;<span class="tp">number</span>[]&gt;;      <span class="cm">// number</span>
<span class="kw">type</span> <span class="tp">E3</span> = <span class="tp">ElementOf</span>&lt;<span class="tp">string</span>&gt;;        <span class="cm">// never (not an array)</span>

<span class="cm">// Extract the type inside a Promise</span>
<span class="kw">type</span> <span class="tp">UnwrapPromise</span>&lt;<span class="gen">T</span>&gt; =
  <span class="gen">T</span> <span class="kw">extends</span> <span class="tp">Promise</span>&lt;<span class="kw">infer</span> <span class="gen">V</span>&gt; ? <span class="gen">V</span> : <span class="gen">T</span>;

<span class="kw">type</span> <span class="tp">P1</span> = <span class="tp">UnwrapPromise</span>&lt;<span class="tp">Promise</span>&lt;<span class="tp">string</span>&gt;&gt;;  <span class="cm">// string</span>
<span class="kw">type</span> <span class="tp">P2</span> = <span class="tp">UnwrapPromise</span>&lt;<span class="tp">number</span>&gt;;          <span class="cm">// number</span>

<span class="cm">// Extract first argument of a function</span>
<span class="kw">type</span> <span class="tp">FirstArg</span>&lt;<span class="gen">T</span>&gt; =
  <span class="gen">T</span> <span class="kw">extends</span> (<span class="param">first</span>: <span class="kw">infer</span> <span class="gen">F</span>, ...<span class="param">rest</span>: <span class="kw">any</span>[]) =&gt; <span class="kw">any</span>
    ? <span class="gen">F</span>
    : <span class="tp">never</span>;

<span class="kw">type</span> <span class="tp">F1</span> = <span class="tp">FirstArg</span>&lt;(<span class="param">name</span>: <span class="tp">string</span>, <span class="param">age</span>: <span class="tp">number</span>) =&gt; <span class="kw">void</span>&gt;; <span class="cm">// string</span>

<span class="cm">// Extract tuple elements</span>
<span class="kw">type</span> <span class="tp">Head</span>&lt;<span class="gen">T</span> <span class="kw">extends</span> <span class="kw">any</span>[]&gt; =
  <span class="gen">T</span> <span class="kw">extends</span> [<span class="kw">infer</span> <span class="gen">First</span>, ...<span class="kw">infer</span> <span class="gen">Rest</span>] ? <span class="gen">First</span> : <span class="tp">never</span>;

<span class="kw">type</span> <span class="tp">Tail</span>&lt;<span class="gen">T</span> <span class="kw">extends</span> <span class="kw">any</span>[]&gt; =
  <span class="gen">T</span> <span class="kw">extends</span> [<span class="kw">infer</span> <span class="gen">First</span>, ...<span class="kw">infer</span> <span class="gen">Rest</span>] ? <span class="gen">Rest</span> : [];

<span class="kw">type</span> <span class="tp">H</span> = <span class="tp">Head</span>&lt;[<span class="tp">string</span>, <span class="tp">number</span>, <span class="tp">boolean</span>]&gt;; <span class="cm">// string</span>
<span class="kw">type</span> <span class="tp">T</span> = <span class="tp">Tail</span>&lt;[<span class="tp">string</span>, <span class="tp">number</span>, <span class="tp">boolean</span>]&gt;; <span class="cm">// [number, boolean]</span></pre>
    </div>
  </div>

  <div class="lesson">
    <h3>4. Nested Conditional Types</h3>

    <div class="code-block">
      <div class="code-header"><span>nested-conditionals.ts</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
      <pre><span class="cm">// Chain conditions like if/else if/else</span>
<span class="kw">type</span> <span class="tp">TypeName</span>&lt;<span class="gen">T</span>&gt; =
  <span class="gen">T</span> <span class="kw">extends</span> <span class="tp">string</span>  ? <span class="str">"string"</span> :
  <span class="gen">T</span> <span class="kw">extends</span> <span class="tp">number</span>  ? <span class="str">"number"</span> :
  <span class="gen">T</span> <span class="kw">extends</span> <span class="tp">boolean</span> ? <span class="str">"boolean"</span> :
  <span class="gen">T</span> <span class="kw">extends</span> <span class="kw">undefined</span> ? <span class="str">"undefined"</span> :
  <span class="gen">T</span> <span class="kw">extends</span> <span class="tp">Function</span> ? <span class="str">"function"</span> :
  <span class="str">"object"</span>;

<span class="kw">type</span> <span class="tp">T1</span> = <span class="tp">TypeName</span>&lt;<span class="tp">string</span>&gt;;  <span class="cm">// "string"</span>
<span class="kw">type</span> <span class="tp">T2</span> = <span class="tp">TypeName</span>&lt;() =&gt; <span class="kw">void</span>&gt;;  <span class="cm">// "function"</span>
<span class="kw">type</span> <span class="tp">T3</span> = <span class="tp">TypeName</span>&lt;<span class="tp">string</span>[]&gt;;  <span class="cm">// "object"</span>

<span class="cm">// Real-world: deep recursive unwrapping</span>
<span class="kw">type</span> <span class="tp">DeepAwaited</span>&lt;<span class="gen">T</span>&gt; =
  <span class="gen">T</span> <span class="kw">extends</span> <span class="tp">Promise</span>&lt;<span class="kw">infer</span> <span class="gen">U</span>&gt; ? <span class="tp">DeepAwaited</span>&lt;<span class="gen">U</span>&gt; : <span class="gen">T</span>;

<span class="kw">type</span> <span class="tp">D</span> = <span class="tp">DeepAwaited</span>&lt;<span class="tp">Promise</span>&lt;<span class="tp">Promise</span>&lt;<span class="tp">Promise</span>&lt;<span class="tp">string</span>&gt;&gt;&gt;&gt;;
<span class="cm">// string (unwraps all layers)</span></pre>
    </div>
  </div>

  <button class="quiz-btn" onclick="markComplete('conditional'); showSection('guards');">Continue to Type Guards ‚Üí</button>
</div>

<!-- ========== TYPE GUARDS ========== -->
<div class="section" id="sec-guards">
  <div class="section-header">
    <h2>üõ°Ô∏è Type Guards</h2>
    <p class="subtitle">Narrow types at runtime ‚Äî the bridge between types and JavaScript</p>
  </div>

  <div class="lesson">
    <h3>1. Built-in Type Guards</h3>

    <div class="code-block">
      <div class="code-header"><span>built-in-guards.ts</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
      <pre><span class="kw">function</span> <span class="fn">process</span>(<span class="param">value</span>: <span class="tp">string</span> | <span class="tp">number</span> | <span class="tp">boolean</span> | <span class="kw">null</span>) {
  <span class="cm">// typeof guard</span>
  <span class="kw">if</span> (<span class="kw">typeof</span> value === <span class="str">"string"</span>) {
    value.<span class="fn">toUpperCase</span>();  <span class="cm">// TS knows: string</span>
  }

  <span class="cm">// typeof guard (numbers)</span>
  <span class="kw">if</span> (<span class="kw">typeof</span> value === <span class="str">"number"</span>) {
    value.<span class="fn">toFixed</span>(<span class="num">2</span>);  <span class="cm">// TS knows: number</span>
  }

  <span class="cm">// Truthiness narrowing (removes null/undefined/false/0/"")</span>
  <span class="kw">if</span> (value) {
    <span class="cm">// TS knows: string | number | true (null is gone)</span>
  }

  <span class="cm">// Equality narrowing</span>
  <span class="kw">if</span> (value === <span class="kw">null</span>) {
    <span class="cm">// TS knows: null</span>
  }

  <span class="cm">// instanceof guard</span>
  <span class="kw">if</span> (value <span class="kw">instanceof</span> Date) {
    value.<span class="fn">getFullYear</span>(); <span class="cm">// TS knows: Date</span>
  }
}

<span class="cm">// "in" operator narrowing</span>
<span class="kw">type</span> <span class="tp">Fish</span> = { <span class="fn">swim</span>(): <span class="kw">void</span> };
<span class="kw">type</span> <span class="tp">Bird</span> = { <span class="fn">fly</span>(): <span class="kw">void</span> };

<span class="kw">function</span> <span class="fn">move</span>(<span class="param">animal</span>: <span class="tp">Fish</span> | <span class="tp">Bird</span>) {
  <span class="kw">if</span> (<span class="str">"swim"</span> <span class="kw">in</span> animal) {
    animal.<span class="fn">swim</span>();  <span class="cm">// TS knows: Fish</span>
  } <span class="kw">else</span> {
    animal.<span class="fn">fly</span>();   <span class="cm">// TS knows: Bird</span>
  }
}</pre>
    </div>
  </div>

  <div class="lesson">
    <h3>2. Custom Type Guards (Type Predicates)</h3>
    <p>Write your own functions that narrow types using the <code class="inline">is</code> keyword.</p>

    <div class="code-block">
      <div class="code-header"><span>type-predicates.ts</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
      <pre><span class="cm">// Basic type predicate</span>
<span class="kw">function</span> <span class="fn">isString</span>(<span class="param">value</span>: <span class="kw">unknown</span>): value <span class="kw">is</span> <span class="tp">string</span> {
  <span class="kw">return typeof</span> value === <span class="str">"string"</span>;
}

<span class="cm">// Usage</span>
<span class="kw">function</span> <span class="fn">doSomething</span>(<span class="param">x</span>: <span class="kw">unknown</span>) {
  <span class="kw">if</span> (<span class="fn">isString</span>(x)) {
    x.<span class="fn">toUpperCase</span>();  <span class="cm">// ‚úÖ TS knows x is string</span>
  }
}

<span class="cm">// Complex type predicate</span>
<span class="kw">interface</span> <span class="iface">ApiError</span> {
  <span class="prop">code</span>: <span class="tp">number</span>;
  <span class="prop">message</span>: <span class="tp">string</span>;
  <span class="prop">details</span>?: <span class="tp">string</span>;
}

<span class="kw">function</span> <span class="fn">isApiError</span>(<span class="param">error</span>: <span class="kw">unknown</span>): error <span class="kw">is</span> <span class="iface">ApiError</span> {
  <span class="kw">return</span> (
    <span class="kw">typeof</span> error === <span class="str">"object"</span> &&
    error !== <span class="kw">null</span> &&
    <span class="str">"code"</span> <span class="kw">in</span> error &&
    <span class="str">"message"</span> <span class="kw">in</span> error &&
    <span class="kw">typeof</span> (error <span class="kw">as</span> <span class="iface">ApiError</span>).code === <span class="str">"number"</span> &&
    <span class="kw">typeof</span> (error <span class="kw">as</span> <span class="iface">ApiError</span>).message === <span class="str">"string"</span>
  );
}

<span class="cm">// Filter arrays with type predicates</span>
<span class="kw">const</span> mixed: (<span class="tp">string</span> | <span class="kw">null</span>)[] = [<span class="str">"a"</span>, <span class="kw">null</span>, <span class="str">"b"</span>, <span class="kw">null</span>, <span class="str">"c"</span>];

<span class="cm">// Without type predicate: string | null</span>
<span class="kw">const</span> bad = mixed.<span class="fn">filter</span>(x =&gt; x !== <span class="kw">null</span>);
<span class="cm">// Type: (string | null)[]  ‚Üê still includes null!</span>

<span class="cm">// With type predicate: string</span>
<span class="kw">const</span> good = mixed.<span class="fn">filter</span>(
  (x): x <span class="kw">is</span> <span class="tp">string</span> =&gt; x !== <span class="kw">null</span>
);
<span class="cm">// Type: string[]  ‚Üê null removed! ‚úÖ</span></pre>
    </div>

    <div class="callout success">
      <div class="callout-title">‚úÖ Pro Tip: Array.filter with Type Predicates</div>
      <p>This is one of the most practical uses of type predicates. It comes up in real code <em>constantly</em> and interviewers love it.</p>
    </div>
  </div>

  <div class="lesson">
    <h3>3. Assertion Functions</h3>
    <p>Instead of returning a boolean, throw if the check fails.</p>

    <div class="code-block">
      <div class="code-header"><span>assertion-functions.ts</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
      <pre><span class="cm">// Assertion function (asserts condition)</span>
<span class="kw">function</span> <span class="fn">assertDefined</span>&lt;<span class="gen">T</span>&gt;(
  <span class="param">value</span>: <span class="gen">T</span> | <span class="kw">null</span> | <span class="kw">undefined</span>,
  <span class="param">message</span>?: <span class="tp">string</span>
): <span class="kw">asserts</span> value <span class="kw">is</span> <span class="gen">T</span> {
  <span class="kw">if</span> (value === <span class="kw">null</span> || value === <span class="kw">undefined</span>) {
    <span class="kw">throw new</span> Error(message ?? <span class="str">"Value is not defined"</span>);
  }
}

<span class="cm">// Usage</span>
<span class="kw">function</span> <span class="fn">processUser</span>(<span class="param">user</span>: <span class="iface">User</span> | <span class="kw">null</span>) {
  <span class="fn">assertDefined</span>(user, <span class="str">"User must exist"</span>);
  <span class="cm">// After this line, TS knows user is User (not null)</span>
  console.<span class="fn">log</span>(user.name);  <span class="cm">// ‚úÖ No null check needed</span>
}

<span class="cm">// Assert a specific type</span>
<span class="kw">function</span> <span class="fn">assertIsString</span>(
  <span class="param">value</span>: <span class="kw">unknown</span>
): <span class="kw">asserts</span> value <span class="kw">is</span> <span class="tp">string</span> {
  <span class="kw">if</span> (<span class="kw">typeof</span> value !== <span class="str">"string"</span>) {
    <span class="kw">throw new</span> Error(<span class="str">`Expected string, got ${<span class="kw">typeof</span> value}`</span>);
  }
}</pre>
    </div>
  </div>

  <div class="lesson">
    <h3>4. Exhaustive Checks with <code class="inline">never</code></h3>

    <div class="code-block">
      <div class="code-header"><span>exhaustive.ts</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
      <pre><span class="kw">type</span> <span class="tp">Shape</span> =
  | { <span class="prop">kind</span>: <span class="str">"circle"</span>; <span class="prop">radius</span>: <span class="tp">number</span> }
  | { <span class="prop">kind</span>: <span class="str">"square"</span>; <span class="prop">side</span>: <span class="tp">number</span> }
  | { <span class="prop">kind</span>: <span class="str">"triangle"</span>; <span class="prop">base</span>: <span class="tp">number</span>; <span class="prop">height</span>: <span class="tp">number</span> };

<span class="kw">function</span> <span class="fn">area</span>(<span class="param">shape</span>: <span class="tp">Shape</span>): <span class="tp">number</span> {
  <span class="kw">switch</span> (shape.<span class="prop">kind</span>) {
    <span class="kw">case</span> <span class="str">"circle"</span>:
      <span class="kw">return</span> Math.PI * shape.radius ** <span class="num">2</span>;
    <span class="kw">case</span> <span class="str">"square"</span>:
      <span class="kw">return</span> shape.side ** <span class="num">2</span>;
    <span class="kw">case</span> <span class="str">"triangle"</span>:
      <span class="kw">return</span> <span class="num">0.5</span> * shape.base * shape.height;
    <span class="kw">default</span>: {
      <span class="cm">// This ensures ALL cases are handled</span>
      <span class="cm">// If you add a new shape and forget a case,</span>
      <span class="cm">// TS will error here because shape won't be 'never'</span>
      <span class="kw">const</span> _exhaustive: <span class="tp">never</span> = shape;
      <span class="kw">return</span> _exhaustive;
    }
  }
}</pre>
    </div>
  </div>

  <button class="quiz-btn" onclick="markComplete('guards'); showSection('decorators');">Continue to Decorators ‚Üí</button>
</div>

<!-- ========== DECORATORS ========== -->
<div class="section" id="sec-decorators">
  <div class="section-header">
    <h2>üé≠ Decorators</h2>
    <p class="subtitle">Meta-programming ‚Äî modify classes and methods with annotations</p>
  </div>

  <div class="lesson">
    <h3>What Are Decorators?</h3>
    <p>Decorators are <strong>special functions</strong> that add behavior to classes, methods, properties, or parameters. They use the <code class="inline">@</code> syntax.</p>

    <div class="callout warning">
      <div class="callout-title">‚ö†Ô∏è Two Versions of Decorators</div>
      <p><strong>Legacy decorators</strong> (experimentalDecorators) are widely used (Angular, NestJS). <strong>TC39 Stage 3 decorators</strong> are the future standard (TS 5.0+). We cover both.</p>
    </div>
  </div>

  <div class="lesson">
    <h3>1. Class Decorators</h3>

    <div class="code-block">
      <div class="code-header"><span>class-decorator.ts</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
      <pre><span class="cm">// Legacy decorator (experimentalDecorators: true)</span>
<span class="kw">function</span> <span class="fn">Sealed</span>(<span class="param">constructor</span>: <span class="tp">Function</span>) {
  Object.<span class="fn">seal</span>(constructor);
  Object.<span class="fn">seal</span>(constructor.prototype);
}

<span class="dec">@Sealed</span>
<span class="kw">class</span> <span class="tp">BankAccount</span> {
  <span class="prop">balance</span> = <span class="num">0</span>;
}

<span class="cm">// Decorator Factory (returns a decorator)</span>
<span class="kw">function</span> <span class="fn">Logger</span>(<span class="param">prefix</span>: <span class="tp">string</span>) {
  <span class="kw">return function</span>(<span class="param">target</span>: <span class="tp">Function</span>) {
    console.<span class="fn">log</span>(<span class="str">`${prefix}: ${target.name} created`</span>);
  };
}

<span class="dec">@Logger</span>(<span class="str">"APP"</span>)
<span class="kw">class</span> <span class="tp">UserService</span> {
  <span class="cm">// Logs: "APP: UserService created"</span>
}

<span class="cm">// TC39 Stage 3 Decorators (TS 5.0+)</span>
<span class="kw">function</span> <span class="fn">logged</span>(
  <span class="param">target</span>: <span class="kw">any</span>,
  <span class="param">context</span>: <span class="tp">ClassDecoratorContext</span>
) {
  console.<span class="fn">log</span>(<span class="str">`Class ${<span class="tp">String</span>(context.name)} defined`</span>);
}</pre>
    </div>
  </div>

  <div class="lesson">
    <h3>2. Method Decorators</h3>

    <div class="code-block">
      <div class="code-header"><span>method-decorator.ts</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
      <pre><span class="cm">// Legacy: Log every method call</span>
<span class="kw">function</span> <span class="fn">Log</span>(
  <span class="param">target</span>: <span class="kw">any</span>,
  <span class="param">propertyKey</span>: <span class="tp">string</span>,
  <span class="param">descriptor</span>: <span class="tp">PropertyDescriptor</span>
) {
  <span class="kw">const</span> original = descriptor.value;

  descriptor.value = <span class="kw">function</span>(...<span class="param">args</span>: <span class="kw">any</span>[]) {
    console.<span class="fn">log</span>(<span class="str">`Calling ${propertyKey} with`</span>, args);
    <span class="kw">const</span> result = original.<span class="fn">apply</span>(<span class="kw">this</span>, args);
    console.<span class="fn">log</span>(<span class="str">`${propertyKey} returned`</span>, result);
    <span class="kw">return</span> result;
  };

  <span class="kw">return</span> descriptor;
}

<span class="kw">class</span> <span class="tp">Calculator</span> {
  <span class="dec">@Log</span>
  <span class="fn">add</span>(<span class="param">a</span>: <span class="tp">number</span>, <span class="param">b</span>: <span class="tp">number</span>): <span class="tp">number</span> {
    <span class="kw">return</span> a + b;
  }
}

<span class="cm">// Practical: Memoize decorator</span>
<span class="kw">function</span> <span class="fn">Memoize</span>(
  <span class="param">target</span>: <span class="kw">any</span>,
  <span class="param">key</span>: <span class="tp">string</span>,
  <span class="param">descriptor</span>: <span class="tp">PropertyDescriptor</span>
) {
  <span class="kw">const</span> original = descriptor.value;
  <span class="kw">const</span> cache = <span class="kw">new</span> Map();

  descriptor.value = <span class="kw">function</span>(...<span class="param">args</span>: <span class="kw">any</span>[]) {
    <span class="kw">const</span> cacheKey = JSON.<span class="fn">stringify</span>(args);
    <span class="kw">if</span> (cache.<span class="fn">has</span>(cacheKey)) <span class="kw">return</span> cache.<span class="fn">get</span>(cacheKey);
    <span class="kw">const</span> result = original.<span class="fn">apply</span>(<span class="kw">this</span>, args);
    cache.<span class="fn">set</span>(cacheKey, result);
    <span class="kw">return</span> result;
  };
}

<span class="kw">class</span> <span class="tp">MathService</span> {
  <span class="dec">@Memoize</span>
  <span class="fn">fibonacci</span>(<span class="param">n</span>: <span class="tp">number</span>): <span class="tp">number</span> {
    <span class="kw">if</span> (n &lt;= <span class="num">1</span>) <span class="kw">return</span> n;
    <span class="kw">return this</span>.<span class="fn">fibonacci</span>(n - <span class="num">1</span>) + <span class="kw">this</span>.<span class="fn">fibonacci</span>(n - <span class="num">2</span>);
  }
}</pre>
    </div>
  </div>

  <div class="lesson">
    <h3>3. Property & Parameter Decorators</h3>

    <div class="code-block">
      <div class="code-header"><span>property-decorator.ts</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
      <pre><span class="cm">// Property decorator: validation</span>
<span class="kw">function</span> <span class="fn">MinLength</span>(<span class="param">min</span>: <span class="tp">number</span>) {
  <span class="kw">return function</span>(<span class="param">target</span>: <span class="kw">any</span>, <span class="param">propertyKey</span>: <span class="tp">string</span>) {
    <span class="kw">let</span> value: <span class="tp">string</span>;

    Object.<span class="fn">defineProperty</span>(target, propertyKey, {
      <span class="fn">get</span>() { <span class="kw">return</span> value; },
      <span class="fn">set</span>(<span class="param">newVal</span>: <span class="tp">string</span>) {
        <span class="kw">if</span> (newVal.length &lt; min) {
          <span class="kw">throw new</span> Error(
            <span class="str">`${propertyKey} must be at least ${min} chars`</span>
          );
        }
        value = newVal;
      }
    });
  };
}

<span class="kw">class</span> <span class="tp">User</span> {
  <span class="dec">@MinLength</span>(<span class="num">3</span>)
  <span class="prop">name</span>: <span class="tp">string</span> = <span class="str">""</span>;

  <span class="dec">@MinLength</span>(<span class="num">8</span>)
  <span class="prop">password</span>: <span class="tp">string</span> = <span class="str">""</span>;
}

<span class="kw">const</span> user = <span class="kw">new</span> <span class="tp">User</span>();
user.name = <span class="str">"Alice"</span>;    <span class="cm">// ‚úÖ OK</span>
<span class="cm">// user.name = "Al";     // ‚ùå Throws: must be at least 3 chars</span></pre>
    </div>
  </div>

  <div class="lesson">
    <h3>4. Decorator Composition</h3>

    <div class="code-block">
      <div class="code-header"><span>decorator-composition.ts</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
      <pre><span class="cm">// Multiple decorators: evaluate top-down, execute bottom-up</span>
<span class="kw">function</span> <span class="fn">First</span>() {
  console.<span class="fn">log</span>(<span class="str">"First(): evaluated"</span>);
  <span class="kw">return function</span>(<span class="param">target</span>: <span class="kw">any</span>, <span class="param">key</span>: <span class="tp">string</span>, <span class="param">desc</span>: <span class="kw">any</span>) {
    console.<span class="fn">log</span>(<span class="str">"First(): called"</span>);
  };
}

<span class="kw">function</span> <span class="fn">Second</span>() {
  console.<span class="fn">log</span>(<span class="str">"Second(): evaluated"</span>);
  <span class="kw">return function</span>(<span class="param">target</span>: <span class="kw">any</span>, <span class="param">key</span>: <span class="tp">string</span>, <span class="param">desc</span>: <span class="kw">any</span>) {
    console.<span class="fn">log</span>(<span class="str">"Second(): called"</span>);
  };
}

<span class="kw">class</span> <span class="tp">Example</span> {
  <span class="dec">@First</span>()
  <span class="dec">@Second</span>()
  <span class="fn">method</span>() {}
}

<span class="cm">// Output:
// First(): evaluated    ‚Üê factories run top to bottom
// Second(): evaluated
// Second(): called      ‚Üê decorators apply bottom to top
// First(): called</span></pre>
    </div>
  </div>

  <button class="quiz-btn" onclick="markComplete('decorators'); showSection('gymnastics');">Continue to Type Gymnastics ‚Üí</button>
</div>

<!-- ========== TYPE GYMNASTICS ========== -->
<div class="section" id="sec-gymnastics">
  <div class="section-header">
    <h2>ü§∏ Type Gymnastics</h2>
    <p class="subtitle">Combine everything ‚Äî real-world type challenges</p>
  </div>

  <div class="lesson">
    <h3>1. Deep Partial</h3>
    <p>Built-in <code class="inline">Partial</code> only works one level deep. Let's make it recursive.</p>

    <div class="code-block">
      <div class="code-header"><span>deep-partial.ts</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
      <pre><span class="kw">type</span> <span class="tp">DeepPartial</span>&lt;<span class="gen">T</span>&gt; = {
  [<span class="gen">K</span> <span class="kw">in keyof</span> <span class="gen">T</span>]?: <span class="gen">T</span>[<span class="gen">K</span>] <span class="kw">extends</span> <span class="tp">object</span>
    ? <span class="tp">DeepPartial</span>&lt;<span class="gen">T</span>[<span class="gen">K</span>]&gt;
    : <span class="gen">T</span>[<span class="gen">K</span>];
};

<span class="kw">interface</span> <span class="iface">Config</span> {
  <span class="prop">database</span>: {
    <span class="prop">host</span>: <span class="tp">string</span>;
    <span class="prop">port</span>: <span class="tp">number</span>;
    <span class="prop">credentials</span>: {
      <span class="prop">username</span>: <span class="tp">string</span>;
      <span class="prop">password</span>: <span class="tp">string</span>;
    };
  };
  <span class="prop">cache</span>: {
    <span class="prop">ttl</span>: <span class="tp">number</span>;
    <span class="prop">enabled</span>: <span class="tp">boolean</span>;
  };
}

<span class="cm">// Override just what you need</span>
<span class="kw">const</span> override: <span class="tp">DeepPartial</span>&lt;<span class="iface">Config</span>&gt; = {
  database: {
    credentials: {
      password: <span class="str">"new-password"</span>
      <span class="cm">// Don't need to specify username, host, port, etc.</span>
    }
  }
};</pre>
    </div>
  </div>

  <div class="lesson">
    <h3>2. Deep Readonly</h3>

    <div class="code-block">
      <div class="code-header"><span>deep-readonly.ts</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
      <pre><span class="kw">type</span> <span class="tp">DeepReadonly</span>&lt;<span class="gen">T</span>&gt; =
  <span class="gen">T</span> <span class="kw">extends</span> <span class="tp">Function</span> ? <span class="gen">T</span> :
  <span class="gen">T</span> <span class="kw">extends</span> <span class="tp">object</span> ? {
    <span class="kw">readonly</span> [<span class="gen">K</span> <span class="kw">in keyof</span> <span class="gen">T</span>]: <span class="tp">DeepReadonly</span>&lt;<span class="gen">T</span>[<span class="gen">K</span>]&gt;;
  } : <span class="gen">T</span>;

<span class="kw">const</span> config: <span class="tp">DeepReadonly</span>&lt;<span class="iface">Config</span>&gt; = {
  database: {
    host: <span class="str">"localhost"</span>,
    port: <span class="num">5432</span>,
    credentials: { username: <span class="str">"admin"</span>, password: <span class="str">"secret"</span> }
  },
  cache: { ttl: <span class="num">300</span>, enabled: <span class="kw">true</span> }
};

<span class="cm">// config.database.port = 3000;  // ‚ùå Error: readonly</span>
<span class="cm">// config.database.credentials.password = "x"; // ‚ùå Also readonly!</span></pre>
    </div>
  </div>

  <div class="lesson">
    <h3>3. Path Types (Dot-notation access)</h3>

    <div class="code-block">
      <div class="code-header"><span>path-types.ts</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
      <pre><span class="cm">// Generate all possible dot-notation paths of an object</span>
<span class="kw">type</span> <span class="tp">Paths</span>&lt;<span class="gen">T</span>, <span class="gen">D</span> <span class="kw">extends</span> <span class="tp">number</span> = <span class="num">10</span>&gt; =
  [<span class="gen">D</span>] <span class="kw">extends</span> [<span class="tp">never</span>] ? <span class="tp">never</span> :
  <span class="gen">T</span> <span class="kw">extends</span> <span class="tp">object</span> ? {
    [<span class="gen">K</span> <span class="kw">in keyof</span> <span class="gen">T</span>]-?: <span class="gen">K</span> <span class="kw">extends</span> <span class="tp">string</span> | <span class="tp">number</span>
      ? <span class="str">`${<span class="gen">K</span>}`</span> | <span class="str">`${<span class="gen">K</span>}.${<span class="tp">Paths</span>&lt;<span class="gen">T</span>[<span class="gen">K</span>]&gt;}`</span>
      : <span class="tp">never</span>;
  }[<span class="kw">keyof</span> <span class="gen">T</span>] : <span class="tp">never</span>;

<span class="kw">type</span> <span class="tp">ConfigPaths</span> = <span class="tp">Paths</span>&lt;<span class="iface">Config</span>&gt;;
<span class="cm">// "database" | "database.host" | "database.port" |
// "database.credentials" | "database.credentials.username" |
// "database.credentials.password" | "cache" | "cache.ttl" |
// "cache.enabled"</span>

<span class="cm">// Type-safe get function</span>
<span class="kw">function</span> <span class="fn">get</span>&lt;<span class="gen">T</span>, <span class="gen">P</span> <span class="kw">extends</span> <span class="tp">Paths</span>&lt;<span class="gen">T</span>&gt;&gt;(
  <span class="param">obj</span>: <span class="gen">T</span>,
  <span class="param">path</span>: <span class="gen">P</span>
): <span class="kw">any</span> {
  <span class="kw">return</span> (<span class="param">path</span> <span class="kw">as</span> <span class="tp">string</span>).<span class="fn">split</span>(<span class="str">"."</span>)
    .<span class="fn">reduce</span>((<span class="param">o</span>, <span class="param">k</span>) =&gt; o?.[k], obj <span class="kw">as</span> <span class="kw">any</span>);
}</pre>
    </div>
  </div>

  <div class="lesson">
    <h3>4. Type-Safe Event Emitter</h3>

    <div class="code-block">
      <div class="code-header"><span>typed-events.ts</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
      <pre><span class="kw">type</span> <span class="tp">EventMap</span> = {
  <span class="prop">userLogin</span>: { <span class="prop">userId</span>: <span class="tp">string</span>; <span class="prop">timestamp</span>: <span class="tp">Date</span> };
  <span class="prop">userLogout</span>: { <span class="prop">userId</span>: <span class="tp">string</span> };
  <span class="prop">pageView</span>: { <span class="prop">url</span>: <span class="tp">string</span>; <span class="prop">duration</span>: <span class="tp">number</span> };
  <span class="prop">error</span>: <span class="tp">Error</span>;
};

<span class="kw">class</span> <span class="tp">TypedEmitter</span>&lt;<span class="gen">Events</span> <span class="kw">extends</span> <span class="tp">Record</span>&lt;<span class="tp">string</span>, <span class="kw">any</span>&gt;&gt; {
  <span class="kw">private</span> listeners = <span class="kw">new</span> Map&lt;<span class="tp">string</span>, Set&lt;<span class="tp">Function</span>&gt;&gt;();

  <span class="fn">on</span>&lt;<span class="gen">K</span> <span class="kw">extends keyof</span> <span class="gen">Events</span> & <span class="tp">string</span>&gt;(
    <span class="param">event</span>: <span class="gen">K</span>,
    <span class="param">handler</span>: (<span class="param">payload</span>: <span class="gen">Events</span>[<span class="gen">K</span>]) =&gt; <span class="kw">void</span>
  ): <span class="kw">void</span> {
    <span class="kw">if</span> (!<span class="kw">this</span>.listeners.<span class="fn">has</span>(event))
      <span class="kw">this</span>.listeners.<span class="fn">set</span>(event, <span class="kw">new</span> Set());
    <span class="kw">this</span>.listeners.<span class="fn">get</span>(event)!.<span class="fn">add</span>(handler);
  }

  <span class="fn">emit</span>&lt;<span class="gen">K</span> <span class="kw">extends keyof</span> <span class="gen">Events</span> & <span class="tp">string</span>&gt;(
    <span class="param">event</span>: <span class="gen">K</span>,
    <span class="param">payload</span>: <span class="gen">Events</span>[<span class="gen">K</span>]
  ): <span class="kw">void</span> {
    <span class="kw">this</span>.listeners.<span class="fn">get</span>(event)
      ?.<span class="fn">forEach</span>(<span class="param">fn</span> =&gt; <span class="fn">fn</span>(payload));
  }
}

<span class="kw">const</span> emitter = <span class="kw">new</span> <span class="tp">TypedEmitter</span>&lt;<span class="tp">EventMap</span>&gt;();

emitter.<span class="fn">on</span>(<span class="str">"userLogin"</span>, (<span class="param">payload</span>) =&gt; {
  <span class="cm">// payload is { userId: string; timestamp: Date } ‚úÖ</span>
  console.<span class="fn">log</span>(payload.userId);
});

emitter.<span class="fn">emit</span>(<span class="str">"pageView"</span>, { url: <span class="str">"/home"</span>, duration: <span class="num">1200</span> }); <span class="cm">// ‚úÖ</span>
<span class="cm">// emitter.emit("pageView", { url: "/home" }); // ‚ùå missing duration</span></pre>
    </div>
  </div>

  <div class="lesson">
    <h3>5. Builder Pattern with Fluent Generics</h3>

    <div class="code-block">
      <div class="code-header"><span>builder.ts</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
      <pre><span class="cm">// Type accumulates as you chain methods</span>
<span class="kw">class</span> <span class="tp">FormBuilder</span>&lt;<span class="gen">T</span> <span class="kw">extends</span> <span class="tp">Record</span>&lt;<span class="tp">string</span>, <span class="kw">any</span>&gt; = {}&gt; {
  <span class="kw">private</span> <span class="prop">fields</span>: <span class="gen">T</span> = {} <span class="kw">as</span> <span class="gen">T</span>;

  <span class="fn">addField</span>&lt;<span class="gen">K</span> <span class="kw">extends</span> <span class="tp">string</span>, <span class="gen">V</span>&gt;(
    <span class="param">name</span>: <span class="gen">K</span>,
    <span class="param">defaultValue</span>: <span class="gen">V</span>
  ): <span class="tp">FormBuilder</span>&lt;<span class="gen">T</span> & <span class="tp">Record</span>&lt;<span class="gen">K</span>, <span class="gen">V</span>&gt;&gt; {
    (<span class="kw">this</span>.fields <span class="kw">as</span> <span class="kw">any</span>)[name] = defaultValue;
    <span class="kw">return this</span> <span class="kw">as</span> <span class="kw">any</span>;
  }

  <span class="fn">build</span>(): <span class="gen">T</span> {
    <span class="kw">return</span> { ...<span class="kw">this</span>.fields };
  }
}

<span class="kw">const</span> form = <span class="kw">new</span> <span class="tp">FormBuilder</span>()
  .<span class="fn">addField</span>(<span class="str">"name"</span>, <span class="str">""</span>)
  .<span class="fn">addField</span>(<span class="str">"age"</span>, <span class="num">0</span>)
  .<span class="fn">addField</span>(<span class="str">"email"</span>, <span class="str">""</span>)
  .<span class="fn">build</span>();

<span class="cm">// form type: { name: string; age: number; email: string }</span>
form.name;  <span class="cm">// ‚úÖ string</span>
form.age;   <span class="cm">// ‚úÖ number</span>
<span class="cm">// form.phone; // ‚ùå Property 'phone' does not exist</span></pre>
    </div>
  </div>

  <button class="quiz-btn" onclick="markComplete('gymnastics'); showSection('quiz');">Continue to Quiz ‚Üí</button>
</div>

<!-- ========== QUIZ ========== -->
<div class="section" id="sec-quiz">
  <div class="section-header">
    <h2>üìù Knowledge Quiz</h2>
    <p class="subtitle">Test your understanding ‚Äî 15 questions covering all topics</p>
  </div>

  <div id="quizArea"></div>
  <div id="quizScore" class="score-display" style="display:none;">
    <div class="score-number" id="scoreNum"></div>
    <p id="scoreText" style="color:var(--text2); margin-top:8px;"></p>
    <button class="quiz-btn" onclick="resetQuiz()" style="margin-top:15px;">üîÑ Retake Quiz</button>
  </div>
</div>

<!-- ========== EXERCISES ========== -->
<div class="section" id="sec-exercises">
  <div class="section-header">
    <h2>üí™ Practice Exercises</h2>
    <p class="subtitle">Build muscle memory ‚Äî solve these challenges</p>
  </div>

  <div id="exerciseArea"></div>
</div>

<!-- ========== PITFALLS ========== -->
<div class="section" id="sec-pitfalls">
  <div class="section-header">
    <h2>‚ö†Ô∏è Mistakes & Pitfalls</h2>
    <p class="subtitle">Common traps that catch even experienced developers</p>
  </div>

  <div id="pitfallArea"></div>
</div>

<!-- ========== CHEAT SHEET ========== -->
<div class="section" id="sec-cheatsheet">
  <div class="section-header">
    <h2>üìã Cheat Sheet</h2>
    <p class="subtitle">Quick reference for interviews and daily work</p>
  </div>

  <div id="cheatArea"></div>
</div>

</div><!-- /main -->

<script>
// ============================================================
// APP STATE
// ============================================================
const completed = new Set();
const totalSections = 8;

function showSection(id) {
  document.querySelectorAll('.section').forEach(s => s.classList.remove('active'));
  document.querySelectorAll('.nav-btn').forEach(b => b.classList.remove('active'));
  const sec = document.getElementById('sec-' + id);
  if (sec) sec.classList.add('active');
  const btns = document.querySelectorAll('.nav-btn');
  btns.forEach(b => {
    if (b.getAttribute('onclick')?.includes(id)) b.classList.add('active');
  });
  window.scrollTo({ top: 0, behavior: 'smooth' });
}

function markComplete(id) {
  completed.add(id);
  updateProgress();
}

function updateProgress() {
  const pct = (completed.size / totalSections) * 100;
  document.getElementById('mainProgress').style.width = pct + '%';
  document.getElementById('progressText').textContent =
    `${completed.size} / ${totalSections} sections completed`;
}

function copyCode(btn) {
  const pre = btn.closest('.code-block').querySelector('pre');
  const text = pre.textContent;
  navigator.clipboard.writeText(text).then(() => {
    btn.textContent = 'Copied!';
    setTimeout(() => btn.textContent = 'Copy', 1500);
  });
}

// ============================================================
// QUIZ ENGINE
// ============================================================
const quizQuestions = [
  {
    q: "What does `type A = string & number` resolve to?",
    opts: ["`string`", "`number`", "`never`", "`string | number`"],
    correct: 2,
    explanation: "No value can be both string AND number simultaneously, so the intersection is `never`."
  },
  {
    q: "What is the result of `Exclude<'a' | 'b' | 'c', 'a' | 'c'>`?",
    opts: ["`'a' | 'c'`", "`'b'`", "`never`", "`'a' | 'b' | 'c'`"],
    correct: 1,
    explanation: "Exclude removes union members assignable to the second argument. 'a' and 'c' are removed, leaving 'b'."
  },
  {
    q: "What keyword narrows a type in a custom type guard function?",
    opts: ["`as`", "`is`", "`extends`", "`infer`"],
    correct: 1,
    explanation: "The `is` keyword in `param is Type` creates a type predicate that narrows the type when the function returns true."
  },
  {
    q: "Given `type X = { a: string }; type Y = Partial<X>;`, what is `Y`?",
    opts: [
      "`{ a: string }`",
      "`{ a?: string }`",
      "`{ a: string | undefined }`",
      "`{}`"
    ],
    correct: 1,
    explanation: "Partial<T> makes all properties optional by adding `?` to each one."
  },
  {
    q: "What does the `infer` keyword do in conditional types?",
    opts: [
      "Declares a type parameter",
      "Extracts/captures a type from a pattern",
      "Creates a type alias",
      "Validates a type constraint"
    ],
    correct: 1,
    explanation: "`infer` captures a type variable within a conditional type pattern, like destructuring for types."
  },
  {
    q: "Which distributes over unions?\n`type A<T> = T extends any ? T[] : never`\nvs\n`type B<T> = [T] extends [any] ? T[] : never`\n\nFor `string | number`:",
    opts: [
      "Both give `(string | number)[]`",
      "A gives `string[] | number[]`, B gives `(string | number)[]`",
      "Both give `string[] | number[]`",
      "A gives `(string | number)[]`, B gives `string[] | number[]`"
    ],
    correct: 1,
    explanation: "A has a 'naked' type parameter, so it distributes (each member checked separately). B wraps T in a tuple, preventing distribution."
  },
  {
    q: "What is the type of `ReturnType<typeof JSON.parse>`?",
    opts: ["`string`", "`object`", "`any`", "`unknown`"],
    correct: 2,
    explanation: "JSON.parse returns `any` in TypeScript's type definitions."
  },
  {
    q: "In decorator execution order, if you stack `@A` above `@B` on a method, which executes FIRST?",
    opts: [
      "A (top to bottom)",
      "B (bottom to top)",
      "They execute simultaneously",
      "It depends on the decorator type"
    ],
    correct: 1,
    explanation: "Decorator factories evaluate top-to-bottom, but the resulting decorators are applied bottom-to-top."
  },
  {
    q: "What type does `unknown & string` simplify to?",
    opts: ["`unknown`", "`string`", "`never`", "`any`"],
    correct: 1,
    explanation: "`unknown` is the top type. Intersecting with string gives string, because anything & string = string (string is more specific)."
  },
  {
    q: "What does `Record<'a' | 'b', number>` produce?",
    opts: [
      "`{ a: number } | { b: number }`",
      "`{ a: number; b: number }`",
      "`{ a?: number; b?: number }`",
      "`Map<string, number>`"
    ],
    correct: 1,
    explanation: "Record<K, V> creates an object type with all keys from K mapped to value type V."
  },
  {
    q: "What's the difference between `any` and `unknown`?",
    opts: [
      "They're identical",
      "`unknown` requires type checking before use; `any` bypasses all checks",
      "`any` is safer than `unknown`",
      "`unknown` only works with primitives"
    ],
    correct: 1,
    explanation: "`unknown` is the type-safe counterpart of `any`. You must narrow it before using it."
  },
  {
    q: "`keyof { a: 1; b: 2; c: 3 }` evaluates to:",
    opts: [
      "`1 | 2 | 3`",
      "`'a' | 'b' | 'c'`",
      "`string`",
      "`string | number`"
    ],
    correct: 1,
    explanation: "`keyof` extracts the property names (keys) as a union of string literal types."
  },
  {
    q: "How do you make a type guard filter nulls from an array with `.filter()`?",
    opts: [
      "`.filter(x => x !== null)`",
      "`.filter((x): x is NonNullable<typeof x> => x !== null)`",
      "`.filter<NonNull>(x => !!x)`",
      "`.filter(Boolean)`"
    ],
    correct: 1,
    explanation: "Using a type predicate `(x): x is T => ...` in .filter() correctly narrows the resulting array type."
  },
  {
    q: "What does `asserts value is string` mean in a function return type?",
    opts: [
      "The function returns a boolean indicating if value is string",
      "The function throws if value isn't string; otherwise TS narrows the type",
      "The function converts value to string",
      "The function returns the string version of value"
    ],
    correct: 1,
    explanation: "Assertion functions narrow the type for subsequent code, but throw instead of returning false."
  },
  {
    q: "What does `-?` mean in `{ [K in keyof T]-?: T[K] }`?",
    opts: [
      "Makes properties optional",
      "Removes the optional modifier",
      "Makes properties nullable",
      "It's a syntax error"
    ],
    correct: 1,
    explanation: "The `-?` modifier removes optionality. This is exactly how the built-in `Required<T>` type works."
  }
];

let quizState = { answers: {}, submitted: false };

function renderQuiz() {
  const area = document.getElementById('quizArea');
  let html = '';
  quizQuestions.forEach((q, i) => {
    html += `<div class="quiz-container" id="quiz-${i}">
      <div class="quiz-question"><span class="q-number">Q${i+1}.</span> ${q.q.replace(/\n/g, '<br>')}</div>
      <ul class="quiz-options">
        ${q.opts.map((o, j) => `
          <li class="quiz-option" data-q="${i}" data-opt="${j}" onclick="selectOption(${i}, ${j})">
            <span class="opt-letter">${String.fromCharCode(65+j)}</span>
            <span>${o}</span>
          </li>
        `).join('')}
      </ul>
      <div class="quiz-explanation" id="qexp-${i}">${q.explanation}</div>
    </div>`;
  });
  html += `<button class="quiz-btn" id="submitQuiz" onclick="submitQuiz()">Submit All Answers</button>`;
  area.innerHTML = html;
}

function selectOption(qIdx, optIdx) {
  if (quizState.submitted) return;
  quizState.answers[qIdx] = optIdx;
  const options = document.querySelectorAll(`[data-q="${qIdx}"]`);
  options.forEach(o => o.classList.remove('selected'));
  options[optIdx].classList.add('selected');
}

function submitQuiz() {
  quizState.submitted = true;
  let score = 0;
  quizQuestions.forEach((q, i) => {
    const userAnswer = quizState.answers[i];
    const options = document.querySelectorAll(`[data-q="${i}"]`);
    options.forEach(o => o.style.cursor = 'default');
    if (userAnswer !== undefined) {
      if (userAnswer === q.correct) {
        options[userAnswer].classList.add('correct');
        score++;
      } else {
        options[userAnswer].classList.add('incorrect');
        options[q.correct].classList.add('correct');
      }
    } else {
      options[q.correct].classList.add('correct');
    }
    document.getElementById('qexp-' + i).classList.add('show');
  });

  document.getElementById('submitQuiz').style.display = 'none';
  const scoreArea = document.getElementById('quizScore');
  scoreArea.style.display = 'block';
  document.getElementById('scoreNum').textContent = `${score} / ${quizQuestions.length}`;
  const pct = Math.round((score / quizQuestions.length) * 100);
  let msg = pct >= 90 ? 'üèÜ Outstanding! You\'re interview-ready!' :
            pct >= 70 ? 'üëè Great job! Review the ones you missed.' :
            pct >= 50 ? 'üìö Good start. Re-read the lessons and try again.' :
            'üí™ Keep studying! Review each section carefully.';
  document.getElementById('scoreText').textContent = msg;
  markComplete('quiz');
}

function resetQuiz() {
  quizState = { answers: {}, submitted: false };
  document.getElementById('quizScore').style.display = 'none';
  renderQuiz();
}

// ============================================================
// EXERCISES
// ============================================================
const exercises = [
  {
    title: "Implement MyPick<T, K>",
    difficulty: "easy",
    prompt: "Implement the built-in Pick utility type from scratch. It should select only the keys K from type T.",
    starter: `type MyPick<T, K> = // your code here

// Test:
// type Result = MyPick<{ a: 1; b: 2; c: 3 }, 'a' | 'c'>;
// Should be: { a: 1; c: 3 }`,
    solution: `type MyPick<T, K extends keyof T> = {
  [P in K]: T[P];
};

// Test:
type Result = MyPick<{ a: 1; b: 2; c: 3 }, 'a' | 'c'>;
// { a: 1; c: 3 } ‚úÖ`
  },
  {
    title: "Implement MyOmit<T, K>",
    difficulty: "easy",
    prompt: "Implement Omit without using the built-in. Hint: use Exclude to filter keys.",
    starter: `type MyOmit<T, K> = // your code here

// Test:
// type Result = MyOmit<{ a: 1; b: 2; c: 3 }, 'a'>;
// Should be: { b: 2; c: 3 }`,
    solution: `type MyOmit<T, K extends keyof any> = {
  [P in Exclude<keyof T, K>]: T[P];
};

// Or using key remapping (TS 4.1+):
type MyOmit2<T, K extends keyof any> = {
  [P in keyof T as P extends K ? never : P]: T[P];
};`
  },
  {
    title: "Implement NonNullable<T>",
    difficulty: "easy",
    prompt: "Remove null and undefined from a union type.",
    starter: `type MyNonNullable<T> = // your code here

// Test:
// type Result = MyNonNullable<string | null | undefined>;
// Should be: string`,
    solution: `type MyNonNullable<T> = T extends null | undefined ? never : T;

// This works because of distributive conditional types!
// string | null | undefined distributes to:
// string extends null | undefined ? never : string ‚Üí string
// null extends null | undefined ? never : null ‚Üí never
// undefined extends null | undefined ? never : undefined ‚Üí never
// Result: string | never | never = string ‚úÖ`
  },
  {
    title: "Type-Safe Object.keys",
    difficulty: "medium",
    prompt: "Create a typed version of Object.keys that returns the actual key names instead of string[].",
    starter: `function typedKeys<T extends object>(obj: T) {
  // your code here
}

// Should return ('name' | 'age')[] instead of string[]
// const keys = typedKeys({ name: "Alice", age: 30 });`,
    solution: `function typedKeys<T extends object>(obj: T): (keyof T)[] {
  return Object.keys(obj) as (keyof T)[];
}

const keys = typedKeys({ name: "Alice", age: 30 });
// Type: ("name" | "age")[]

// Note: This has a subtle caveat ‚Äî at runtime, objects
// can have more keys than the type says (structural typing).
// That's why TS makes Object.keys return string[] by default.`
  },
  {
    title: "Implement DeepRequired<T>",
    difficulty: "medium",
    prompt: "Like Required<T>, but works recursively on all nested objects.",
    starter: `type DeepRequired<T> = // your code here

// Test:
// interface Config {
//   db?: { host?: string; port?: number };
//   cache?: { ttl?: number };
// }
// type Result = DeepRequired<Config>;
// All properties should be required, even nested ones.`,
    solution: `type DeepRequired<T> = {
  [K in keyof T]-?: T[K] extends object
    ? DeepRequired<T[K]>
    : T[K];
};

// Better version that handles arrays and functions:
type DeepRequired2<T> = T extends Function
  ? T
  : T extends Array<infer U>
    ? Array<DeepRequired2<U>>
    : T extends object
      ? { [K in keyof T]-?: DeepRequired2<T[K]> }
      : T;`
  },
  {
    title: "Implement Flatten<T>",
    difficulty: "medium",
    prompt: "If T is an array, extract the element type. If T is not an array, return T unchanged.",
    starter: `type Flatten<T> = // your code here

// Tests:
// type A = Flatten<string[]>;     // string
// type B = Flatten<number[][]>;   // number[]
// type C = Flatten<string>;       // string`,
    solution: `type Flatten<T> = T extends Array<infer U> ? U : T;

// Deep flatten (recursive):
type DeepFlatten<T> = T extends Array<infer U>
  ? DeepFlatten<U>
  : T;

// type D = DeepFlatten<number[][][]>;  // number`
  },
  {
    title: "Implement TupleToUnion<T>",
    difficulty: "medium",
    prompt: "Convert a tuple type to a union of its element types.",
    starter: `type TupleToUnion<T> = // your code here

// Test:
// type Result = TupleToUnion<[string, number, boolean]>;
// Should be: string | number | boolean`,
    solution: `// Method 1: Indexed access with number
type TupleToUnion<T extends any[]> = T[number];

// Method 2: Using infer
type TupleToUnion2<T> = T extends (infer U)[] ? U : never;

// Method 3: Recursive
type TupleToUnion3<T extends any[]> =
  T extends [infer First, ...infer Rest]
    ? First | TupleToUnion3<Rest>
    : never;`
  },
  {
    title: "Create a Strict Function Type",
    difficulty: "hard",
    prompt: "Create a type that ensures a function receives EXACTLY the right argument types (no extra properties allowed in object arguments).",
    starter: `// Hint: TypeScript allows excess properties in some cases.
// Create StrictFn that prevents this.

type Exact<T, Shape> = // your code here`,
    solution: `// TypeScript's structural typing allows excess properties
// when assigning to broader types. To be strict:

type Exact<T, Shape> = T extends Shape
  ? Exclude<keyof T, keyof Shape> extends never
    ? T
    : never
  : never;

// Usage:
function createUser<T extends { name: string }>(
  user: T & Exact<T, { name: string }>
) { }

createUser({ name: "Alice" });         // ‚úÖ
// createUser({ name: "Alice", age: 30 }); // ‚ùå

// Alternative using mapped types:
type Strict<T> = T & {
  [K in Exclude<string, keyof T>]?: never;
};`
  },
  {
    title: "Implement a Type-Safe API Client",
    difficulty: "hard",
    prompt: "Create types for an API client where each endpoint is typed with its request/response.",
    starter: `// Define your endpoint types and create a
// type-safe fetch wrapper.

type ApiEndpoints = {
  '/users': { /* ??? */ };
  '/posts': { /* ??? */ };
};`,
    solution: `type ApiEndpoints = {
  '/users': {
    GET: { response: { id: number; name: string }[] };
    POST: { body: { name: string }; response: { id: number; name: string } };
  };
  '/posts': {
    GET: { response: { id: number; title: string }[] };
    DELETE: { response: { success: boolean } };
  };
};

type Method = 'GET' | 'POST' | 'PUT' | 'DELETE';

async function api<
  Path extends keyof ApiEndpoints,
  M extends keyof ApiEndpoints[Path] & Method
>(
  path: Path,
  method: M,
  ...args: 'body' extends keyof ApiEndpoints[Path][M]
    ? [body: ApiEndpoints[Path][M]['body']]
    : []
): Promise<ApiEndpoints[Path][M]['response']> {
  // implementation
  const res = await fetch(path, {
    method,
    body: args[0] ? JSON.stringify(args[0]) : undefined,
  });
  return res.json();
}

// Usage:
// const users = await api('/users', 'GET');
// Type: { id: number; name: string }[] ‚úÖ
// const newUser = await api('/users', 'POST', { name: "Alice" });
// Type: { id: number; name: string } ‚úÖ`
  },
  {
    title: "Implement StringToUnion<S>",
    difficulty: "hard",
    prompt: "Convert a string literal type into a union of its characters.",
    starter: `type StringToUnion<S extends string> = // your code here

// Test:
// type Result = StringToUnion<"hello">;
// Should be: "h" | "e" | "l" | "o"`,
    solution: `type StringToUnion<S extends string> =
  S extends \`\${infer First}\${infer Rest}\`
    ? First | StringToUnion<Rest>
    : never;

// Step by step for "hello":
// "hello" ‚Üí "h" | StringToUnion<"ello">
// "ello"  ‚Üí "e" | StringToUnion<"llo">
// "llo"   ‚Üí "l" | StringToUnion<"lo">
// "lo"    ‚Üí "l" | StringToUnion<"o">
// "o"     ‚Üí "o" | StringToUnion<"">
// ""      ‚Üí never
// Result: "h" | "e" | "l" | "l" | "o" = "h" | "e" | "l" | "o"
// (duplicate "l" collapses in union)`
  }
];

function renderExercises() {
  const area = document.getElementById('exerciseArea');
  let html = '';
  exercises.forEach((ex, i) => {
    html += `<div class="exercise">
      <h3>
        Exercise ${i+1}: ${ex.title}
        <span class="difficulty ${ex.difficulty}">${ex.difficulty.toUpperCase()}</span>
      </h3>
      <p class="exercise-prompt">${ex.prompt}</p>
      <div class="code-block">
        <div class="code-header"><span>starter code</span></div>
        <pre>${escapeHtml(ex.starter)}</pre>
      </div>
      <textarea placeholder="Write your solution here...">${ex.starter}</textarea>
      <br>
      <button class="reveal-btn" onclick="toggleSolution(${i})">üëÅÔ∏è Reveal Solution</button>
      <div class="solution" id="sol-${i}">
        <div class="code-block">
          <div class="code-header"><span>solution</span><button class="copy-btn" onclick="copyCode(this)">Copy</button></div>
          <pre>${escapeHtml(ex.solution)}</pre>
        </div>
      </div>
    </div>`;
  });
  area.innerHTML = html;
}

function toggleSolution(idx) {
  const sol = document.getElementById('sol-' + idx);
  sol.classList.toggle('show');
}

function escapeHtml(str) {
  return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

// ============================================================
// PITFALLS
// ============================================================
const pitfalls = [
  {
    title: "1. Using `any` instead of `unknown`",
    problem: "`any` disables ALL type checking. It's a virus that spreads through your codebase.",
    badCode: `function parse(input: any) {
  // No errors ‚Äî but input could be anything!
  return input.data.users[0].name;
}`,
    goodCode: `function parse(input: unknown) {
  if (
    typeof input === "object" && input !== null &&
    "data" in input
  ) {
    // Now safely narrow the type
  }
}`,
    tip: "Use `unknown` for values you don't know. Use `any` only as a last resort (e.g., legacy code migration)."
  },
  {
    title: "2. Forgetting that `Object.keys()` returns `string[]`",
    problem: "TypeScript intentionally returns `string[]` from Object.keys, not `(keyof T)[]`.",
    badCode: `const user = { name: "Alice", age: 30 };
Object.keys(user).forEach(key => {
  // key is string, not "name" | "age"
  console.log(user[key]); // ‚ùå Error
});`,
    goodCode: `// Option 1: Type assertion
(Object.keys(user) as (keyof typeof user)[])
  .forEach(key => console.log(user[key]));

// Option 2: Use Object.entries
Object.entries(user).forEach(([key, value]) => {
  console.log(value); // ‚úÖ
});

// Option 3: for-in with narrowing
for (const key in user) {
  if (key in user)
    console.log(user[key as keyof typeof user]);
}`,
    tip: "This is intentional! Objects can have more keys at runtime than TypeScript knows about (structural typing)."
  },
  {
    title: "3. Type assertion `as` doesn't validate anything",
    problem: "`as` is just telling the compiler 'trust me'. It doesn't convert or check values.",
    badCode: `const input = "not a number";
const num = input as unknown as number;
// num is typed as number but is actually "not a number"
console.log(num.toFixed(2)); // üí• Runtime error!`,
    goodCode: `const input = "42";
const num = Number(input);
if (isNaN(num)) {
  throw new Error("Invalid number");
}
// num is safely a number here`,
    tip: "Use type guards and validation instead of `as`. Type assertions are only for cases where YOU know more than the compiler."
  },
  {
    title: "4. Confusing `interface extends` with `type &` (intersection)",
    problem: "Intersecting incompatible object types creates impossible types silently.",
    badCode: `type A = { name: string };
type B = { name: number };
type C = A & B;
// C's name is: string & number = never
// You can never create a valid C!`,
    goodCode: `// With interfaces, extending catches the conflict:
interface A { name: string }
// interface C extends A { name: number }
// ‚ùå Error! Types of 'name' are incompatible

// Or use Omit to override:
type C = Omit<A, 'name'> & { name: number };`,
    tip: "Prefer `interface extends` for catching conflicts early. Use `&` carefully."
  },
  {
    title: "5. Distributive conditional types surprise",
    problem: "Union types distribute through conditional types, producing unexpected results.",
    badCode: `type IsString<T> = T extends string ? true : false;

// Surprise!
type Test = IsString<string | number>;
// Expected: false (string | number is not just string)
// Actual: true | false = boolean (distributed!)`,
    goodCode: `// Wrap in tuple to prevent distribution
type IsString<T> = [T] extends [string] ? true : false;

type Test = IsString<string | number>;
// Now correctly: false`,
    tip: "If you don't want distribution, wrap both sides of extends in `[]`."
  },
  {
    title: "6. Enum pitfalls ‚Äî numeric enums are not type-safe",
    problem: "TypeScript allows any number to be assigned to a numeric enum.",
    badCode: `enum Status {
  Active = 0,
  Inactive = 1,
}

const s: Status = 999; // ‚úÖ No error! Any number works!`,
    goodCode: `// Use string enums or union types instead
type Status = "active" | "inactive";

// Or const enum (but has its own issues with --isolatedModules)
const enum Direction {
  Up = "UP",
  Down = "DOWN",
}`,
    tip: "Prefer string literal unions over enums. They're simpler, don't generate runtime code, and are truly type-safe."
  },
  {
    title: "7. Forgetting that `readonly` is shallow",
    problem: "Built-in Readonly<T> only makes the top-level properties readonly.",
    badCode: `type User = Readonly<{
  name: string;
  settings: { theme: string; lang: string };
}>;

const user: User = {
  name: "Alice",
  settings: { theme: "dark", lang: "en" }
};

// user.name = "Bob";  // ‚ùå Correctly blocked
user.settings.theme = "light"; // ‚úÖ Allowed! Shallow readonly!`,
    goodCode: `type DeepReadonly<T> = T extends Function ? T :
  T extends object ? {
    readonly [K in keyof T]: DeepReadonly<T[K]>;
  } : T;

type User = DeepReadonly<{
  name: string;
  settings: { theme: string; lang: string };
}>;
// Now settings.theme is also readonly ‚úÖ`,
    tip: "Use DeepReadonly for immutable data structures, or use libraries like immer."
  },
  {
    title: "8. Using `Function` type",
    problem: "The `Function` type is too loose ‚Äî it accepts any function with any args.",
    badCode: `function execute(fn: Function) {
  fn(1, 2, 3); // No type safety at all
}`,
    goodCode: `// Be specific about the function signature
function execute(fn: (x: number) => string) {
  const result = fn(42); // result is string ‚úÖ
}

// Or use generic for flexibility
function execute2<T extends (...args: any[]) => any>(
  fn: T,
  ...args: Parameters<T>
): ReturnType<T> {
  return fn(...args);
}`,
    tip: "Never use `Function`, `Object`, or `{}` as types. Be specific."
  }
];

function renderPitfalls() {
  const area = document.getElementById('pitfallArea');
  let html = '';
  pitfalls.forEach(p => {
    html += `<div class="pitfall">
      <h4>‚ö†Ô∏è ${p.title}</h4>
      <p style="color:var(--text2); margin-bottom:12px;">${p.problem}</p>
      <div class="vs-container">
        <div class="vs-bad">
          <div class="vs-label">‚ùå DON'T</div>
          <div class="code-block" style="margin:0; border-radius:0 0 8px 8px;">
            <pre style="font-size:0.82rem;">${escapeHtml(p.badCode)}</pre>
          </div>
        </div>
        <div class="vs-good">
          <div class="vs-label">‚úÖ DO</div>
          <div class="code-block" style="margin:0; border-radius:0 0 8px 8px;">
            <pre style="font-size:0.82rem;">${escapeHtml(p.goodCode)}</pre>
          </div>
        </div>
      </div>
      <div class="callout info" style="margin-top:10px;">
        <div class="callout-title">üí° Remember</div>
        <p>${p.tip}</p>
      </div>
    </div>`;
  });
  area.innerHTML = html;
  markComplete('pitfalls');
}

// ============================================================
// CHEAT SHEET
// ============================================================
function renderCheatSheet() {
  const area = document.getElementById('cheatArea');
  area.innerHTML = `
  <div class="cheat-grid">
    <div class="cheat-card">
      <h4>üì¶ Utility Types ‚Äî Property Modifiers</h4>
      <table class="cheat-table">
        <tr><th>Type</th><th>What it Does</th></tr>
        <tr><td>Partial&lt;T&gt;</td><td>All props optional</td></tr>
        <tr><td>Required&lt;T&gt;</td><td>All props required</td></tr>
        <tr><td>Readonly&lt;T&gt;</td><td>All props readonly</td></tr>
        <tr><td>Pick&lt;T, K&gt;</td><td>Only keep keys K</td></tr>
        <tr><td>Omit&lt;T, K&gt;</td><td>Remove keys K</td></tr>
        <tr><td>Record&lt;K, V&gt;</td><td>Object with keys K, values V</td></tr>
      </table>
    </div>

    <div class="cheat-card">
      <h4>üîÄ Utility Types ‚Äî Union/Conditional</h4>
      <table class="cheat-table">
        <tr><th>Type</th><th>What it Does</th></tr>
        <tr><td>Exclude&lt;T, U&gt;</td><td>Remove U from union T</td></tr>
        <tr><td>Extract&lt;T, U&gt;</td><td>Keep only U from union T</td></tr>
        <tr><td>NonNullable&lt;T&gt;</td><td>Remove null & undefined</td></tr>
        <tr><td>ReturnType&lt;T&gt;</td><td>Return type of function T</td></tr>
        <tr><td>Parameters&lt;T&gt;</td><td>Param types as tuple</td></tr>
        <tr><td>Awaited&lt;T&gt;</td><td>Unwrap Promise&lt;&gt;</td></tr>
        <tr><td>InstanceType&lt;T&gt;</td><td>Instance type of class</td></tr>
        <tr><td>ConstructorParameters&lt;T&gt;</td><td>Constructor args as tuple</td></tr>
      </table>
    </div>

    <div class="cheat-card">
      <h4>üß¨ Type Operators</h4>
      <table class="cheat-table">
        <tr><th>Syntax</th><th>Meaning</th></tr>
        <tr><td>keyof T</td><td>Union of property names</td></tr>
        <tr><td>T[K]</td><td>Indexed access (lookup)</td></tr>
        <tr><td>T extends U ? X : Y</td><td>Conditional type</td></tr>
        <tr><td>[K in keyof T]</td><td>Mapped type iteration</td></tr>
        <tr><td>infer R</td><td>Capture type in conditional</td></tr>
        <tr><td>T & U</td><td>Intersection (AND)</td></tr>
        <tr><td>T | U</td><td>Union (OR)</td></tr>
        <tr><td>as const</td><td>Narrow to literal types</td></tr>
        <tr><td>satisfies T</td><td>Validate without widening</td></tr>
      </table>
    </div>

    <div class="cheat-card">
      <h4>üõ°Ô∏è Type Narrowing</h4>
      <table class="cheat-table">
        <tr><th>Guard</th><th>Usage</th></tr>
        <tr><td>typeof x === "string"</td><td>Primitives</td></tr>
        <tr><td>x instanceof Class</td><td>Class instances</td></tr>
        <tr><td>"prop" in x</td><td>Property existence</td></tr>
        <tr><td>x === null</td><td>Equality check</td></tr>
        <tr><td>Array.isArray(x)</td><td>Array check</td></tr>
        <tr><td>(x): x is T => ...</td><td>Custom type predicate</td></tr>
        <tr><td>asserts x is T</td><td>Assertion function</td></tr>
        <tr><td>switch (x.kind)</td><td>Discriminated union</td></tr>
      </table>
    </div>

    <div class="cheat-card">
      <h4>üîÆ Generic Patterns</h4>
      <table class="cheat-table">
        <tr><th>Pattern</th><th>Example</th></tr>
        <tr><td>Constraint</td><td>T extends { length: number }</td></tr>
        <tr><td>Key constraint</td><td>K extends keyof T</td></tr>
        <tr><td>Default</td><td>T = unknown</td></tr>
        <tr><td>Multiple</td><td>&lt;T, K extends keyof T&gt;</td></tr>
        <tr><td>Function</td><td>&lt;T&gt;(x: T): T</td></tr>
        <tr><td>Class</td><td>class Box&lt;T&gt; { value: T }</td></tr>
        <tr><td>Mapped</td><td>{ [K in keyof T]: ... }</td></tr>
      </table>
    </div>

    <div class="cheat-card">
      <h4>üé≠ Decorator Signatures</h4>
      <table class="cheat-table">
        <tr><th>Type</th><th>Signature</th></tr>
        <tr><td>Class</td><td>(target: Function)</td></tr>
        <tr><td>Method</td><td>(target, key, descriptor)</td></tr>
        <tr><td>Property</td><td>(target, key)</td></tr>
        <tr><td>Parameter</td><td>(target, key, index)</td></tr>
        <tr><td>Factory</td><td>(args) => decorator</td></tr>
      </table>
    </div>

    <div class="cheat-card">
      <h4>üìê Template Literal Types</h4>
      <table class="cheat-table">
        <tr><th>Type</th><th>Result</th></tr>
        <tr><td>\`\${string}px\`</td><td>"10px", "200px", etc.</td></tr>
        <tr><td>Uppercase&lt;T&gt;</td><td>"hello" ‚Üí "HELLO"</td></tr>
        <tr><td>Lowercase&lt;T&gt;</td><td>"HELLO" ‚Üí "hello"</td></tr>
        <tr><td>Capitalize&lt;T&gt;</td><td>"hello" ‚Üí "Hello"</td></tr>
        <tr><td>Uncapitalize&lt;T&gt;</td><td>"Hello" ‚Üí "hello"</td></tr>
      </table>
    </div>

    <div class="cheat-card">
      <h4>‚ö° Quick Tips</h4>
      <table class="cheat-table">
        <tr><th>Tip</th><th>Details</th></tr>
        <tr><td>Prefer unknown over any</td><td>Forces type checking</td></tr>
        <tr><td>Use const assertions</td><td>as const for literals</td></tr>
        <tr><td>Use satisfies (TS 4.9+)</td><td>Validate without widening</td></tr>
        <tr><td>Avoid enums</td><td>Use union types instead</td></tr>
        <tr><td>Never use Function/Object</td><td>Be specific</td></tr>
        <tr><td>Use strict mode</td><td>"strict": true in tsconfig</td></tr>
        <tr><td>noUncheckedIndexedAccess</td><td>Catch undefined access</td></tr>
      </table>
    </div>
  </div>

  <div class="lesson" style="margin-top:25px;">
    <h3>üî• Interview Power Phrases</h3>
    <p>Drop these naturally in interviews to signal expertise:</p>
    <ul>
      <li>"I'd use a <strong>discriminated union</strong> here to get exhaustive checking in the switch."</li>
      <li>"We can <strong>distribute over the union</strong> using a conditional type."</li>
      <li>"I'll add a <strong>type predicate</strong> to the filter so the array is properly narrowed."</li>
      <li>"Let's make this generic <strong>constrained to keyof T</strong> so we get autocomplete."</li>
      <li>"I'd use <strong>Omit and Pick</strong> to derive the request type from the model."</li>
      <li>"The <strong>infer keyword</strong> lets us extract the inner type from the wrapper."</li>
      <li>"Using <strong>satisfies</strong> here validates the type without widening it."</li>
      <li>"I prefer <strong>unknown over any</strong> because it forces explicit narrowing."</li>
    </ul>
  </div>
  `;
  markComplete('cheatsheet');
}

// ============================================================
// INIT
// ============================================================
document.addEventListener('DOMContentLoaded', () => {
  renderQuiz();
  renderExercises();
  renderPitfalls();
  renderCheatSheet();
});
</script>
</body>
</html>